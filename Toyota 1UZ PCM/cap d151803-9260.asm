

;
; ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
; º	This file is generated by The Interactive Disassembler (IDA)	    º
; º	Copyright (c) 2006 by DataRescue sa/nv,	<ida@datarescue.com>	    º
; º			 Licensed to: Freeware version			    º
; ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
;

; ; Processor:	      D8X
; ; Target assembler: Table Driven Assembler (TASM) by Speech Technology Inc.

; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

; Segment type:	Pure data
		;.segment FSR
DDRA:		.block 1		; DATA XREF: __RESET+7r __RESET+1741r
					; Port A i/o config
DDRB:		.block 1		; DATA XREF: __RESET+Dr __RESET+1744r
					; Port B i/o config
WDC:		.block 1		; watch	dog timer
TIMER3:		.block 1		; DATA XREF: sub_C010:loc_C025r
					; sub_C010+18r	...
					; Timer	LSB (bit0~bit2)
TIMER:		.block 2		; DATA XREF: DoInjector+13r
					; DoInjector:DoInj6r ...
					; Timer	MSB (bit11~bit18)
SIDR_SODR:	.block 1		; DATA XREF: sub_D45F+8w sub_D45F+18r	...
					; Serial Input/Output Data Register
SMRC_SIR:	.block 1		; DATA XREF: sub_D45F+13r __RESET+40r	...
					; Serial Master	Register Control
CPR0:		.block 2		; DATA XREF: Cmp0IGTdwell+3w
					; Cmp0NOW+6w
					; Timer	comparison #0 MSB
CPR1:		.block 2		; DATA XREF: ROM:ED38w
					; Timer	comparison #1 MSB
CPR2:		.block 2		; Timer	comparison #2 MSB
CPR3:		.block 2		; Timer	comparison #3 MSB
ASR0P:		.block 1		; DATA XREF: __RESET+12r __RESET+1747r
					; ASR0 pos edge	counter	value MSB
ASR0PL:		.block 1		; DATA XREF: __RESET+2Er __RESET+174Ar
					; ASR0 pos edge	counter	value LSB
ASR0N:		.block 1		; DATA XREF: sub_C003+Aw sub_C010+11w	...
					; ASR0 neg edge	counter	value MSB
ASR0NL:		.block 1		; DATA XREF: __RESET+18r __RESET+1750r
					; ASR0 neg edge	counter	value LSB
ASR1P:		.block 2		; DATA XREF: __RESET+37r __RESET+174Dr
					; ASR1 pos edge	counter	value MSB
ASR1N:		.block 1		; DATA XREF: __RESET+28r intASR1r ...
					; ASR1 neg edge	counter	value MSB
ASR1NL:		.block 1		; DATA XREF: __RESET+2Br
					; ASR1 neg edge	counter	value LSB
ASR2:		.block 2		; DATA XREF: sub_C010+52w intSINx+14w	...
					; ASR2 edge counter value MSB
ASR3:		.block 1		; DATA XREF: sub_C010+31w __RESET+26w	...
					; ASR3 edge counter value MSB
ASR3L:		.block 1		; ASR3 edge counter value LSB
unk_1C:		.block 1		; DATA XREF: intSINx+2r
unk_1D:		.block 1		; DATA XREF: write6336:loc_D489r
					; __RESET+15r ...
					; bit3 seems to	be a uart global clock output enable
SIDR_SODR2:	.block 1		; DATA XREF: write6336+6w
					; write	data is	tx'd on pin 47, read data is from pin 48
OMODE:		.block 1		; DATA XREF: __RESETr
					; Mode control Register
PORTA:		.block 1		; DATA XREF: sub_D2B9+61r portAclrB0r	...
					; Port A Data Register
PORTAL:		.block 1		; Port A Latch
PORTB:		.block 1		; DATA XREF: sub_D2B9+93r sub_D2B9+96r ...
					; Port B Data Register
PBCS:		.block 1		; DATA XREF: sub_D3D5+3r __RESET+10w ...
					; Port B Control Register
TAIT:		.block 1		; DATA XREF: __RESET+34r __RESET+173Er
					; Timer	ASR Control
LDOUT:		.block 1		; DATA XREF: NEsub1_18+11r
					; NEsub1_18+32r ...
					; Latch	DOUT
DOUT:		.block 1		; DATA XREF: sub_D2B9+13w __RESET+3Ar	...
					; DOUT Data Register
DOM:		.block 1		; DATA XREF: sub_D2B9:loc_D2C8w
					; __RESET+3Dr ...
					; DOUT Control Register
PORTC:		.block 1		; DATA XREF: sub_D2B9+72r sub_D2B9+90r ...
					; Port C Data Register
PORTD_ASRIN:	.block 1		; DATA XREF: __RESET+31r __RESET+645r	...
					; Port D Data Register / ASR Input Data
RAMST:		.block 1		; DATA XREF: intSINxr ROM:CE8Er ...
					; Built-in RAM status
SSD:		.block 1		; DATA XREF: sub_D2B9:loc_D3B5r
					; sub_D45F+16r	...
					; Serial Status	Data Register
IRQL:		.block 1		; DATA XREF: __RESET+4Ew
					; __RESET:main_321r ...
					; Interrupt Request Flag MSB
IRQLL:		.block 1		; DATA XREF: ROM:intASR2_17r ROM:EDB5r ...
					; Interrupt Request Flag LSB
IMASK:		.block 1		; DATA XREF: sub_D2B9+Aw __RESET+50w ...
					; Interrupt Request Mask MSB
IMASKL:		.block 1		; Interrupt Request Mask LSB
unk_30:		.block 1
unk_31:		.block 1
unk_32:		.block 1
unk_33:		.block 1
unk_34:		.block 1
		.block 1
		.block 1
unk_37:		.block 1
CPR4:		.block 2		; Timer	comparison #0 MSB, injectors #10, left bank
CPR5:		.block 2		; Timer	comparison #1 MSB, injectors #20, right	bank
CPR6:		.block 2		; Timer	comparison #2 MSB, injectors #30, right	bank
CPR7:		.block 2		; Timer	comparison #3 MSB, injectors #40, left bank
; end of 'FSR'

; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

; Segment type:	Pure data
		;.segment RAM
		.org 40h
flags_40:	.block 1		; DATA XREF: sub_C64D+28r sub_C64D+A6r ...
					; B3 : forced timing to	5/10 deg BTDC
flags_41:	.block 1		; DATA XREF: sub_C64D+19Ar ROM:CC23r ...
					; B0 IDL1, b5 indidcates something about ram stats during last suspend
flags_42:	.block 1		; DATA XREF: __RESET+57Er __RESET+581r ...
flags_43:	.block 1		; DATA XREF: sub_C64D+67r ROM:CC77r ...
					; bit3:	AFM bad	bit4: rev limiter
flags_44:	.block 1		; DATA XREF: sub_C64D+59r ROM:CC71r ...
					; bit 1	is igf1	related, bit2 igf2 related
flags_45:	.block 1		; DATA XREF: ROM:SUB_C918r
					; ROM:loc_C952r ...
<<<<<<< HEAD
					; IC303	input chip: B7 /TE2, B6	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
flags_46:	.block 1		; DATA XREF: __RESET:fuel_142r
					; __RESET+B2Cr	...
					; bit 1	flags limp in injection	mode, B5 RPM under 5200ish
=======
					; IC303	input chip: B7 /TE2, B /TE1, B5	/NSW, B4 IGSW,	B3, B2 IDL2, B1	, B0 STA
flags_46:	.block 1		; DATA XREF: __RESET:main_142r
					; __RESET+B2Cr	...
					; bit 1	flags limp in injection	mode
>>>>>>> origin/master
flags_47:	.block 1		; DATA XREF: sub_C64D+4Dr sub_C64D+84r ...
					; bit4:	high when hot (but how hot?)
flags_48:	.block 1		; DATA XREF: __RESET+A49r
					; __RESET:main_163r ...
flags_49:	.block 1		; DATA XREF: sub_C64D:loc_C666r
					; sub_C64D+1Cr	...
					; bits 1-3-4-5 are oxl1-oxr1-oxl2-oxr2 - Oxygen	sensors
flags_4A:	.block 1		; DATA XREF: __RESET:main_63r
					; __RESET+8B0r	...
					; bits 6,5,4 are inherited from	109. 6 seems to	always be low when no sub throttle exists
flags_4B:	.block 1		; DATA XREF: ROM:C91Br	ROM:C95Er ...
flags_4C:	.block 1		; DATA XREF: sub_C64D+2r ROM:C965r ...
					; bit 7	set when not running (300 to 400 RPM gap)
flags_4D:	.block 1		; DATA XREF: ROM:C920r	ROM:C923r ...
flags_4E:	.block 1		; DATA XREF: ROM:C928r	ROM:C92Ew ...
					; bit1 is igf1 related,	bit2 igf2 related
flags_4F:	.block 1		; DATA XREF: ROM:loc_C946r ROM:C94Aw ...
flags_50:	.block 1		; DATA XREF: orFlags_50+1r
					; andFlags_50+1r ...
<<<<<<< HEAD
					; could	be bits	for 6336 output	chip, B0 probably HTR L+R1, B1 probably	HTR L+R2
=======
					; could	be bits	for 6336 output	chip
>>>>>>> origin/master
temp_51:	.block 1		; DATA XREF: divDbyXw divDbyX+9r ...
temp_52:	.block 1		; DATA XREF: sub_C64D+10Cw
					; sub_C64D+15Br ...
temp_53:	.block 1		; DATA XREF: DivDby12+6w
					; ThreeDtable+Br ...
temp_54:	.block 1		; DATA XREF: DivDby12w	DivDby12+8r ...
temp_55:	.block 1		; DATA XREF: ROM:CEE4w	ROM:loc_CEF3r ...
temp_56:	.block 1		; DATA XREF: ROM:CEE8w	ROM:CF2Fr ...
unk_57:		.block 1		; DATA XREF: ROM:CEFAw	ROM:CF01r ...
unk_58:		.block 1		; DATA XREF: IV6+49w IV6+4Br ...
		.block 1
unk_5A:		.block 1
ModuloNE:	.block 1		; DATA XREF: ROM:ED46w	ROM:intASR2_39r ...
					; contains modulo: NEcounts%3, represents 30 degree chunks after 10dBTDC cylinder NEcounts/3
THG:		.block 1		; DATA XREF: sub_D2B9+46r
					; __RESET:mainTOF_14r ...
					; THG lookup table output from exhaust gas temp	sensor ADC reading
ATM_press:	.block 1		; DATA XREF: ROM:CAB0r	__RESET+2DFr ...
					; adc pin 17 - PCM atmospheric pressure	sensor,	debiased and scaled
unk_5E:		.block 1		; DATA XREF: sub_C64D:loc_C826r
					; ROM:CA72r ...
					; could	be last	unk_100, or 0
count_5F:	.block 1		; DATA XREF: __RESET:main_24r
					; __RESET+FE8r	...
					; counts up to 255 since last start, about 15 counts per second
deltaNE:	.block 1		; DATA XREF: ReInitNEIGT+Ew ROM:ECB3r
		.block 1
deltaNE_1:	.block 1		; DATA XREF: ReInitNEIGT+10w ROM:ECB5r ...
deltaNE_1l:	.block 1		; DATA XREF: ROM:ED2Fr
threeDeltaNE:	.block 1		; DATA XREF: ReInitNEIGT+14w
					; __RESET:main_10r ...
threeDeltaNEl:	.block 1		; DATA XREF: ROM:ECE8r	calcIGT_time+5r
NEcounts:	.block 1		; DATA XREF: ROM:C961r	ROM:CE57r ...
NEcountsIV6:	.block 1		; DATA XREF: IV6+1Aw IV6+2Ew ...
					; buffered copy	of NEcounts for	IV6 purposes
KS_count:	.block 1		; DATA XREF: IV6+73r IV6+7Br ...
					; counts KS interrupts,	reset in IV6
unk_69:		.block 1		; DATA XREF: IV6+98r IV6+9Dw ...
VTA_net:	.block 2		; DATA XREF: calcInjPW+8r __RESET+2BBr ...
unk_6C:		.block 1		; DATA XREF: __RESET+B3w __RESET+44Dr	...
					; sort of a filtered, saturated	VTA_net
byte_6D:	.block 1		; DATA XREF: sub_C64D+48r
					; sub_C64D:loc_C702r ...
					; signed change	in load	from average
LOAD:		.block 2		; DATA XREF: __RESET:main_18w
					; __RESET+2FFr	...
					; Load,	uncompensated for ThA
unk_70:		.block 1		; DATA XREF: ROM:CFE2r	ROM:D01Ew ...
unk_71:		.block 1		; DATA XREF: ROM:CFE7r	ROM:loc_CFFAw ...
unk_72:		.block 1		; DATA XREF: ROM:loc_CFDDr ROM:CFFCr ...
ADC_count:	.block 1		; DATA XREF: IV6:loc_F3D0r intSIN0+26r ...
ADC_TXed:	.block 1		; DATA XREF: sub_D45F+2w IV6+480w ...
					; MSb signifies	next TX	value is 02
flags_75:	.block 1		; DATA XREF: IV6:IV6_TXadcr
					; IV6:loc_F3F6w ...
					; flags	relating to ADC	tx'ing
unk_76:		.block 1		; DATA XREF: IV6+4B5r IV6:loc_F433w ...
					; some flags which interact with flags_4A
flags_77:	.block 1		; DATA XREF: __RESET+26Ar __RESET+26Fw ...
meanKSint:	.block 2		; DATA XREF: __RESET:main_14r
					; __RESET+288r	...
					; deltaKS/KS_count, filtered
word_7A:	.block 2		; DATA XREF: TwoD_7Ar __RESET+315w ...
					; meanKSint divided by a air temp comp factor
unk_7C:		.block 1		; DATA XREF: sub_D257+3r sub_D257+Dr ...
					; counter
flags_7D:	.block 1		; DATA XREF: ROM:C940r	ROM:C944w ...
					; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1
unk_7E:		.block 1		; DATA XREF: ROM:CDC0r	__RESET+132Er ...
unk_7F:		.block 1		; DATA XREF: __RESET+1653w
					; __RESET+166Ar ...
; end of 'RAM'

; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

; Segment type:	Regular
		;.segment notsure
		.org 80h
word_80:	.block 2		; DATA XREF: __RESET:res_07r
					; __RESET+9FFr	...
word_82:	.block 2		; DATA XREF: sub_C505r
					; init_seg0x80+22w ...
word_84:	.block 2		; DATA XREF: __RESET+127r __RESET+19Dr ...
word_86:	.block 2		; DATA XREF: ROM:CA83r	ROM:loc_CCD9r ...
word_88:	.block 2		; DATA XREF: ROM:CCDFr	ROM:CDA2r
word_8A:	.block 2		; DATA XREF: ROM:CA37r	ROM:CCE5r ...
word_8C:	.block 2		; DATA XREF: ROM:CA39r	ROM:CCE7r ...
word_8E:	.block 2		; DATA XREF: ROM:CC58r	ROM:CCF1r ...
word_90:	.block 2		; DATA XREF: ROM:CA89r	ROM:CB0Fr ...
word_92:	.block 2		; DATA XREF: ROM:CA8Br	ROM:D08Er ...
word_94:	.block 2		; DATA XREF: sub_C64D+5Fr ROM:CB05r ...
word_96:	.block 2		; DATA XREF: sub_C64D+61r ROM:CCEBr ...
word_98:	.block 2		; DATA XREF: sub_C64D+222r sub_C8BBr ...
					; 128 for entire superrun
word_9A:	.block 2		; DATA XREF: __RESET+6E6r
					; __RESET:main_92r ...
word_9C:	.block 2		; DATA XREF: __RESET+6BBr __RESET+6DFr ...
word_9E:	.block 2		; DATA XREF: init_seg0x80+3Fw
; end of 'notsure'

; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

; Segment type:	Regular
		;.segment RAM
		.org 0A0h
unk_A0:		.block 1		; DATA XREF: init_seg0x80+41w
		.block 1
flags_A2:	.block 1		; DATA XREF: sub_C64D+3Cr ROM:C972r ...
<<<<<<< HEAD
					; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
=======
					; bit7:	VTA_net	high, bit4: VTA_net high
>>>>>>> origin/master
count_A3:	.block 1		; DATA XREF: __RESET:main_68r
					; __RESET+5D8w	...
					; incremented at F47D
count_A4:	.block 1		; DATA XREF: __RESET+F2Fr
					; __RESET:main_276w
					; incremented at F47D
count_A5:	.block 1		; DATA XREF: __RESET+F54r
					; __RESET:main_274w ...
					; incremented at F47D
count_A6:	.block 1		; DATA XREF: __RESET+43Ar
					; __RESET:main_42w
					; incremented at F47D
count_A7:	.block 1		; DATA XREF: __RESET+2C1r __RESET+567w
					; incremented at F47D
count_A8:	.block 1		; DATA XREF: intSIN0+110r intSIN0+125w ...
					; incremented at F47D
count_A9:	.block 1		; DATA XREF: sub_C003r
					; sub_C010:loc_C046r ...
					; incremented at F47D
count_AA:	.block 1		; DATA XREF: sub_C010r	sub_C010+5w ...
					; incremented at F47D
count_AB:	.block 1		; DATA XREF: __RESET+854w __RESET+8BFr ...
					; incremented at F47D
count_AC:	.block 1		; DATA XREF: sub_F1A9+ACw
					; sub_F1A9+107w ...
					; incremented at F47D
count_AD:	.block 1		; DATA XREF: ROM:CE9Er	ROM:F963w
					; cleared when below 8V	input, incremented at F47D
count_AE:	.block 1		; DATA XREF: ROM:CE91r	ROM:F968w
					; incremented at F47D
count_AF:	.block 1		; DATA XREF: ROM:CE99r	ROM:CFC9r ...
					; incremented at F47D
count_B0:	.block 1		; DATA XREF: CPR0_sub+5Ar intSIN0+12Bw
					; incremented at F47D
count_B1:	.block 1		; DATA XREF: IVc+44r IVc:ivc_09w ...
					; incremented at F47D
count_B2:	.block 1		; DATA XREF: intASR1+5r
					; intASR1:loc_F726r ...
					; incremented at F47D
count_B3:	.block 1		; DATA XREF: __RESET+241w __RESET+DE1r ...
					; incremented at F55E
count_B4:	.block 1		; DATA XREF: IV6+19Dr IV6:IV6_38w ...
					; incremented at F55E
count_B5:	.block 1		; incremented at F55E
count_B6:	.block 1		; incremented at F55E
count_B7:	.block 1		; DATA XREF: ROM:F925w	ROM:F92Ar ...
					; incremented at F55E
count_B8:	.block 1		; DATA XREF: __RESET:main_331w
<<<<<<< HEAD
					; __RESET:Timing_332r
=======
					; __RESET:main_332r
>>>>>>> origin/master
					; incremented at F55E
count_B9:	.block 1		; DATA XREF: __RESET+22Ar
					; __RESET:main_07r ...
					; incremented at F55E
count_BA:	.block 1		; DATA XREF: __RESET+31Cr __RESET+33Cr
					; decremented at F566
count_BB:	.block 1		; DATA XREF: __RESET+B3Er __RESET+B48r ...
					; decremented at F566
count_BC:	.block 1		; DATA XREF: __RESET+B05r __RESET+B0Fr ...
					; decremented at F566
count_BD:	.block 1		; DATA XREF: __RESET:main_322r
					; __RESET+12EBr
					; decremented at F566
count_BE:	.block 1		; DATA XREF: ROM:C957w	ROM:loc_C959r
					; increments at	E478
count_BF:	.block 1		; DATA XREF: __RESET:main_399r
					; __RESET:main_400w ...
					; increments at	E478
count_C0:	.block 1		; DATA XREF: __RESET:main_396w
					; __RESET:main_397r
					; flag for Gx increments at E478
count_C1:	.block 1		; DATA XREF: __RESET+162Ew
					; __RESET:main_398r
					; flag for Gx increments at E478
count_C2:	.block 1		; DATA XREF: ROM:CDC7w	ROM:loc_CDCBr ...
					; increments at	E478
count_C3:	.block 1		; DATA XREF: ROM:CDDAr	ROM:CDE7w
					; increments at	E478
count_C4:	.block 1		; DATA XREF: ROM:CD75r	ROM:CD7Aw
					; increments at	E478
count_C5:	.block 1		; DATA XREF: IV6+5D0r IV6:loc_F53Bw
					; increments at	E478
count_C6:	.block 1		; DATA XREF: __RESET:main_240w
					; __RESET:main_241r ...
					; increments at	E478
count_C7:	.block 1		; DATA XREF: ROM:loc_CC30w
					; ROM:loc_CC3Ar ...
					; increments at	E478
count_C8:	.block 1		; DATA XREF: __RESET+AA6w
					; __RESET:main_170w ...
					; decrements at	E488
count_C9:	.block 1		; DATA XREF: __RESET+107Fr
					; __RESET+10B9r
					; decrements at	E488
count_CA:	.block 1		; DATA XREF: ROM:C96Fr	__RESET+11BDr ...
					; incremented at E643
count_CB:	.block 1		; DATA XREF: ROM:C9D0r	__RESET+11F2r ...
					; incremented at E643
count_CC:	.block 1		; DATA XREF: IVc+4Ew IVc:ivc_14r
					; incremented at E643
count_CD:	.block 1		; DATA XREF: __RESET:main_111w
					; __RESET+131Cr ...
					; incremented at E7A9
count_CE:	.block 1		; DATA XREF: __RESET+1224w
					; __RESET+124Cr
					; incremented at E7A9
count_CF:	.block 1		; DATA XREF: __RESET+109Fr
					; __RESET+11FCr ...
					; incremented at E7A9
count_D0:	.block 1		; DATA XREF: ROM:loc_CC7Dw ROM:CC86r ...
					; incremented at E7A9
count_D1:	.block 1		; DATA XREF: ROM:CC7Fw	ROM:CCA3r ...
					; incremented at E7A9
unk_D2:		.block 1		; DATA XREF: sub_C634:loc_C64Aw
					; IV6+3Br
unk_D3:		.block 1		; DATA XREF: __RESET:main_118w
					; ROM:FA7Er
					; multiplied by	16 and used for	injectors
unk_D4:		.block 1		; DATA XREF: sub_D1EF+17r
					; __RESET:main_61w ...
					; timing related
unk_D5:		.block 1		; DATA XREF: __RESET+463r
					; __RESET:main_44w ...
unk_D6:		.block 1		; DATA XREF: ROM:loc_FA63w ROM:FA70w ...
unk_D7:		.block 1		; DATA XREF: IV6:IV6_33r IV6+17Bw ...
unk_D8:		.block 1		; DATA XREF: sub_C64D+E8r
					; sub_C64D:loc_C755w ...
unk_D9:		.block 1
unk_DA:		.block 1		; DATA XREF: sub_C4DF+6r
					; sub_C505:loc_C512w ...
unk_DB:		.block 1		; DATA XREF: __RESET:res_08w
					; __RESET+87Fr	...
					; magic	from address 0x80
unk_DC:		.block 1		; DATA XREF: __RESET+16Fw __RESET+A1Fw ...
unk_DD:		.block 1		; DATA XREF: __RESET+A47w __RESET+B76r ...
unk_DE:		.block 1		; DATA XREF: __RESET+AF3r
					; __RESET:main_213r ...
word_DF:	.block 2		; DATA XREF: __RESET+AF8w __RESET+CDFr ...
unk_E1:		.block 1		; DATA XREF: __RESET:main_155r
					; __RESET+A70r	...
unk_E2:		.block 1		; DATA XREF: __RESET+BA2w IV6+678r ...
unk_E3:		.block 1		; DATA XREF: __RESET+ADDw __RESET+C81r ...
unk_E4:		.block 1		; DATA XREF: __RESET+D32r __RESET+D71r ...
unk_E5:		.block 1		; DATA XREF: ROM:ED53r	ROM:intASR2_24w ...
unk_E6:		.block 1		; DATA XREF: ROM:EDA8r	ROM:EDADw ...
		.block 1
unk_E8:		.block 1		; DATA XREF: ROM:intASR2_32r ROM:EDD8w ...
unk_E9:		.block 1		; DATA XREF: IV6+B6r IV6:IV6_13w ...
badKScount:	.block 1		; DATA XREF: IV6+1B4r IV6+1B9w ...
					; Incremented by IV6, cleared by KS interrupt
unk_EB:		.block 1		; DATA XREF: IV6+1A2r IV6+1C1w ...
		.block 1
		.block 1
		.block 1
		.block 1
RPM:		.block 2		; DATA XREF: ROM:TwoD_RPMr ThreeD_RPMr ...
					; MSB is RPM/50, LSB is	fraction of 50
compLOAD:	.block 2		; DATA XREF: ROM:CAFBr	ROM:CCF7r ...
					; air temp and Baro compensated	Load (likely in	units of mass)
<<<<<<< HEAD
lastVTAnet:	.block 1		; DATA XREF: __RESET+1728w
					; last VTA_net
lastVTA1net:	.block 1		; DATA XREF: __RESET+172Dw
=======
byte_F4:	.block 1		; DATA XREF: __RESET+1728w
					; last VTA_net
byte_F5:	.block 1		; DATA XREF: __RESET+172Dw
>>>>>>> origin/master
					; last VTA1-Offset
Bvolts:		.block 1		; DATA XREF: __RESET+406r
					; __RESET:main_112r ...
					; ADC measurement of +B/4. scaling is thus 20*value/255=volts
rawTHW:		.block 1		; DATA XREF: TwoD_rawTHWr sub_C634+4r	...
					; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
f45_shadow:	.block 1		; DATA XREF: __RESET+1707w
					; shadows flags_45
unk_F9:		.block 1		; DATA XREF: __RESET+488r IV6+5EAr ...
rawTHA:		.block 1		; DATA XREF: sub_C61C+5r __RESET+2D0r	...
					; Contains the NOT of air temp reading from ADC, sensor	is tied	to ground on other side
ADC_pin18:	.block 1		; DATA XREF: ROM:FC08w
					; 0V NOT'ed, so 255
		.block 1
		.block 1
		.block 1
unk_FF:		.block 1
unk_100:	.block 1		; DATA XREF: __RESET+1733r
unk_101:	.block 1		; DATA XREF: __RESET+481r
unk_102:	.block 1		; DATA XREF: __RESET+46Fr IV6+D2r
unk_103:	.block 1		; DATA XREF: __RESET+47Ar __RESET+BADr ...
unk_104:	.block 1		; DATA XREF: __RESET+4E0r
					; timing related
		.block 1
unk_106:	.block 1		; DATA XREF: __RESET+1434r IV6+505w
		.block 1
unk_108:	.block 1		; DATA XREF: __RESET+F5Br
					; IV6:loc_F4D4r
unk_109:	.block 1		; DATA XREF: ROM:CE27r	__RESET+458r ...
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
byte_110:	.block 1		; DATA XREF: ReInitCounters+8w
					; __RESET:main_152w ...
					; 7 to 23, highest at lowest fuel flow
byte_111:	.block 1		; DATA XREF: IV6+153r IV6+168w
byte_112:	.block 1		; DATA XREF: ReInitCounters+2w
					; IV6+104w ...
					; necounts/motor phase related
byte_113:	.block 1		; DATA XREF: ReInitCounters:ReInitCNT_1w
					; IV6+119r ...
					; necounts/motor phase related
ADC_pin16:	.block 1		; DATA XREF: calcInjPW+18r
					; __RESET+393r	...
					; adc pin 16 (always 0)
ADC_pin15:	.block 1		; DATA XREF: __RESET+D08r
					; __RESET+1464r
					; adc pin 15 (always 0)
ADC_rq1D:	.block 1		; DATA XREF: __RESET+D0Er
					; __RESET+1624r
					; adc request 1D (probably pin 14, always 0)
ADC_rq1F:	.block 1		; DATA XREF: __RESET+10FBr
					; __RESET+12A1r
					; adc request 1F (probably pin 13, always 0)
lastASR1N:	.block 2		; DATA XREF: intASR1+2r intASR1+4Aw
deltaKS:	.block 1		; DATA XREF: IV6+70r IV6+8Cw ...
					; Cumulative sum of KS intervals, counted by KS_count, reset in	IV6
deltaKSl:	.block 1		; DATA XREF: IV6+78r IV6+8Fw
asr0n_shadow:	.block 1		; DATA XREF: sub_C003+7w sub_C010+8r ...
					; stores configuration information written to asr0n
count_11D:	.block 1		; DATA XREF: __RESET+120Er
					; __RESET:mainTOF_13w
					; tof increment	rate
unk_11E:	.block 1		; DATA XREF: IV6+622r IV6:loc_F5A0w
ISC_11F:	.block 1		; DATA XREF: __RESET+C4w __RESET+A61r	...
					; ISC related
ISC_120:	.block 1		; DATA XREF: IVc:ISC_altr IVc+9Fw ...
					; ISC output bits is lsN
unk_121:	.block 1		; DATA XREF: __RESET+ACAw __RESET+BEEr ...
VTA1_flags:	.block 1		; DATA XREF: ROM:FA17r	ROM:loc_FA4Br
					; VTA1 Flags
VTA1_min:	.block 1		; DATA XREF: __RESET+ABw
					; VTA1 minimum
VTA1_net:	.block 2		; DATA XREF: __RESET+172Ar ROM:FA14r
					; VTA1 - VTA_min
count_126:	.block 1		; DATA XREF: __RESET+55Fr __RESET+5D3w ...
					; from the plots it looks like it increments while the throttle	is closed
		.block 1
VTA2_flags:	.block 1		; DATA XREF: ROM:FA1Ar
					; VTA2 flags
VTA2_min:	.block 1		; DATA XREF: __RESET+AEw
					; VTA2 minimum
VTA2_net:	.block 1		; DATA XREF: sub_D2B9+43r __RESET+B7w	...
<<<<<<< HEAD
					; VTA2-VTA2_min, =255 when sub throttle	disabled/not exist
=======
					; VTA2-VTA2_min
>>>>>>> origin/master
unk_12B:	.block 1
count_12C:	.block 1		; DATA XREF: IV6+529r IV6:loc_F493w
		.block 1
unk_12E:	.block 1		; DATA XREF: ROM:CACBr	ROM:CB25r ...
		.block 1
unk_130:	.block 1		; DATA XREF: sub_C64D+DCr
					; ROM:loc_CB1Cr
unk_131:	.block 1		; DATA XREF: ROM:loc_CF96r __RESET+9Aw
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
unk_137:	.block 1		; DATA XREF: __RESET+38Bw
unk_138:	.block 1		; DATA XREF: IV6+605r IV6+60Bw
unk_139:	.block 1
		.block 1
		.block 1
		.block 1
		.block 1
unk_13E:	.block 1		; DATA XREF: __RESET+E84w
		.block 1
unk_140:	.block 1		; DATA XREF: ROM:CA97r	ROM:CDCDr ...
					; bits 5,0 oxl2	related
unk_141:	.block 1		; DATA XREF: ROM:CAE1r	ROM:CAE6w ...
unk_142:	.block 1		; DATA XREF: ROM:CA3Fr	ROM:loc_CA5Dr ...
count_143:	.block 1		; DATA XREF: ROM:CD12r	__RESET+FD5r ...
					; only counts while warm
		.block 1
unk_145:	.block 1		; DATA XREF: ROM:CFC0w	__RESET+C9w
flags_146:	.block 1		; DATA XREF: ROM:C930r	ROM:C93Aw ...
flags_147:	.block 1		; DATA XREF: ROM:CBD9r	ROM:CBDEw ...
		.block 1
unk_149:	.block 1
unk_14A:	.block 1		; DATA XREF: ROM:CAD5r	ROM:CB28r ...
		.block 1
unk_14C:	.block 1		; DATA XREF: sub_C64D+DFr ROM:CB1Fr
unk_14D:	.block 1		; DATA XREF: ROM:loc_CFA0r __RESET+9Dw
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
unk_153:	.block 1		; DATA XREF: __RESET+38Ew
unk_154:	.block 1		; DATA XREF: IV6:loc_F572r IV6+614w
unk_155:	.block 1
		.block 1
		.block 1
		.block 1
		.block 1
unk_15A:	.block 1		; DATA XREF: __RESET+E87w
		.block 1
unk_15C:	.block 1		; DATA XREF: ROM:CA9Ar	ROM:CDDCr ...
					; bits 5,0 oxr2	related
unk_15D:	.block 1		; DATA XREF: ROM:CAE9r	ROM:CAEEw ...
unk_15E:	.block 1		; DATA XREF: ROM:loc_CA4Er ROM:CA65r ...
count_15F:	.block 1		; DATA XREF: ROM:CD44r
					; __RESET:main_284r ...
					; only counts while warm? oxy sensor related?
		.block 1
unk_161:	.block 1		; DATA XREF: ROM:CFC5w	__RESET+CCw
flags_162:	.block 1		; DATA XREF: ROM:C933r	ROM:C93Dw ...
flags_163:	.block 1		; DATA XREF: ROM:CBE1r	ROM:CBE6w ...
InjectPW1:	.block 2		; DATA XREF: calcInjPW+2Aw __RESET+83w ...
					; pulsewidth for LEFT bank (odd	cyl), 4us/bit
InjectPW2:	.block 2		; DATA XREF: calcInjPW+2Dw __RESET+86w ...
					; pulsewidth for RIGHT bank (even cyl),	4us/bit
InjDeadtime:	.block 2		; DATA XREF: __RESET+8Cw __RESET+9CEr	...
					; injector deadtime, 4us/bit
word_16A:	.block 2		; DATA XREF: __RESET+92w __RESET+3DBw	...
word_16C:	.block 2		; DATA XREF: __RESET+95w
					; __RESET:main_34w ...
word_16E:	.block 2		; DATA XREF: __RESET:main_28r
					; __RESET+7F6w	...
					; inversely temp dependant, additional math elsewhere
word_170:	.block 2		; DATA XREF: sub_C64D+51r ROM:CABFr ...
					; nonzero and decreasing from cold start
word_172:	.block 2		; DATA XREF: ROM:CAC2r	__RESET+7D7w ...
<<<<<<< HEAD
					; nonzero and rapidly decreasing after start, larger peak from cold start
=======
					; inversely temp dependant, additional math elsewhere
>>>>>>> origin/master
unk_174:	.block 1		; DATA XREF: __RESET:main_109w
					; __RESET+936r	...
unk_175:	.block 1		; DATA XREF: sub_C64D+218r sub_C8BB+Fr ...
unk_176:	.block 1		; DATA XREF: __RESET+A6w __RESET+69Ar	...
unk_177:	.block 1		; DATA XREF: sub_C64D+E5w
count_178:	.block 1		; DATA XREF: sub_C64D+Dr __RESET+818w	...
					; tof increment	rate
unk_179:	.block 1		; DATA XREF: __RESET:main_304r
					; __RESET:main_312r ...
unk_17A:	.block 1		; DATA XREF: sub_C64D+1DEr ROM:CAA1r ...
		.block 1
unk_17C:	.block 1		; DATA XREF: __RESET:main_289r
					; __RESET:main_292w
unk_17D:	.block 1		; DATA XREF: __RESET+784r
unk_17E:	.block 1		; DATA XREF: __RESET+1000r
					; __RESET+1048w
		.block 1
unk_180:	.block 1		; DATA XREF: __RESET+6DCw __RESET+72Br
unk_181:	.block 1		; DATA XREF: __RESET+6E3w __RESET+74Br
unk_182:	.block 1		; DATA XREF: __RESET+6EAw __RESET+70Cr
flags_183:	.block 1		; DATA XREF: __RESET+4C1r
					; __RESET:main_55w ...
					; bit 0	set oer	1550 RPM, bit 1	set under 1700 RPM
		.block 1
unk_185:	.block 1		; DATA XREF: __RESET+1377r
					; __RESET:main_338w ...
byte_186:	.block 1		; DATA XREF: __RESET+500r ROM:ED8Fr ...
<<<<<<< HEAD
					; subtracted from timing in NEsub
unk_187:	.block 1		; DATA XREF: __RESET:main_47w
					; __RESET+503r	...
					; timing related
Timing_NE:	.block 1		; DATA XREF: __RESET+148Cw
					; __RESET+14C5r ...
					; represents the number	of NE ticks from TDC to	fire spark ( use formula 30*[(Timing_NE-1)+Timing_frac/256] )
Timing_frac:	.block 1		; represents fraction of TDC tick from TDC to fire spark
byte_18A:	.block 1		; DATA XREF: __RESET+514r __RESET+519r ...
					; subtracted from timing in NEsub
unk_18B:	.block 1		; DATA XREF: __RESET+1431r
					; __RESET:Timing_352w ...
=======
					; timing related
unk_187:	.block 1		; DATA XREF: __RESET:main_47w
					; __RESET+503r	...
					; timing related
unk_188:	.block 1		; DATA XREF: __RESET+148Cw
					; __RESET+14C5r ...
					; initial timing calculation?
unk_189:	.block 1
byte_18A:	.block 1		; DATA XREF: __RESET+514r __RESET+519r ...
					; timing related
unk_18B:	.block 1		; DATA XREF: __RESET+1431r
					; __RESET:main_352w ...
>>>>>>> origin/master
byte_18C:	.block 1		; DATA XREF: __RESET:main_333w
					; __RESET+14BFr
					; lookup from RPM by LOAD table
unk_18D:	.block 1		; DATA XREF: __RESET:main_59r
					; __RESET+142Ew ...
					; im thinking it's a net retard, summed from a number of positive vales then negated
unk_18E:	.block 1		; DATA XREF: __RESET:main_347w
					; __RESET+14DEr ...
unk_18F:	.block 1		; DATA XREF: ROM:EE2Fr
					; NEsub1:NEsub1_16w ...
					; final	timing related
unk_190:	.block 1		; DATA XREF: NEsub1_18+Br
					; NEsub1_18:NEsub1_20r	...
IGT_time:	.block 2		; DATA XREF: calcIGT_time+12w
					; Cmp0IGTdwellr
word_193:	.block 2		; DATA XREF: __RESET+591w __RESET+8F3w ...
final_timing:	.block 1		; DATA XREF: NEsub1+9Aw
					; final	timing (multiply by 60/256)
unk_196:	.block 1		; DATA XREF: sub_F1A9:loc_F1D8r
					; sub_F1A9:loc_F200w
unk_197:	.block 1		; DATA XREF: __RESET:main_57r
					; __RESET+510r	...
<<<<<<< HEAD
					; subtracted from timing in main loop
=======
					; timing related
>>>>>>> origin/master
unk_198:	.block 1		; DATA XREF: sub_F1A9+70w sub_F1A9+82w ...
unk_199:	.block 1		; DATA XREF: __RESET:main_35w
					; sub_F1A9+6Aw	...
					; output from 3d table c54c
unk_19A:	.block 1		; DATA XREF: sub_F1A9+123r
					; sub_F1A9+135r ...
unk_19B:	.block 1		; DATA XREF: sub_F1A9:loc_F216w
					; sub_F1A9+7Ew	...
count_19C:	.block 1		; DATA XREF: sub_F1A9r	sub_F1A9+6w ...
count_19D:	.block 1		; DATA XREF: sub_F1A9:loc_F1B2r
					; sub_F1A9+Fw ...
unk_19E:	.block 1		; DATA XREF: ROM:intASR2_30r ROM:EDBDw ...
unk_19F:	.block 1		; DATA XREF: IVc+3Dr IVc+51w ...
					; ISC related
count_1A0:	.block 1		; DATA XREF: __RESET+BCw __RESET+F42r	...
					; increments at	E480
count_1A1:	.block 1		; DATA XREF: __RESET+BFw
					; __RESET:main_271r ...
					; increments at	E480
count_1A2:	.block 1		; DATA XREF: __RESET+166Fr
					; __RESET:main_403w
					; increments at	E480
count_1A3:	.block 1		; DATA XREF: __RESET+165Cw
					; __RESET:main_405r
					; increments at	E480
lastASR2:	.block 2		; DATA XREF: ROM:EC7Cr	ROM:intASR2_7w	...
avgCompLoad:	.block 2		; DATA XREF: __RESET+341r __RESET+35Er ...
<<<<<<< HEAD
byte_1A8:	.block 1		; DATA XREF: sub_C4DF+14r __RESET+2FBw ...
					; air temp and baro compensation for load from AFM
flags_1A9:	.block 1		; DATA XREF: intSIN0+96r intSIN0+9Fw
					; buffers IC303	inputs for debouncing and storing into flags_45
flags_1AA:	.block 1		; DATA XREF: ROM:C987r	ROM:C9ABr ...
					; B6 - DI (FPECU), B3~0	are NOT	of oxy heater pin voltages R2, R1, L2, L1 (IC302)
flags_1AB:	.block 1		; DATA XREF: __RESET:main_402r	IVc+36r ...
					; buffers IC302	inputs for debouncing and storing into flags_1AA
=======
unk_1A8:	.block 1		; DATA XREF: sub_C4DF+14r __RESET+2FBw ...
					; looks	like air temp compensation for load
flags_1A9:	.block 1		; DATA XREF: intSIN0+96r intSIN0+9Fw
					; flags_45 related (IC303 inputs)
flags_1AA:	.block 1		; DATA XREF: ROM:C987r	ROM:C9ABr ...
					; IC302	input bits B3~0	are NOT	of oxy heater pin voltages
flags_1AB:	.block 1		; DATA XREF: __RESET:main_402r	IVc+36r ...
					; flags_1AA related
>>>>>>> origin/master
word_1AC:	.block 2		; DATA XREF: __RESET+266w intASR1+2Br
					; deltaKS limit	for checking sensor. generated from RPM	lookup table
KS_count2:	.block 1		; DATA XREF: __RESET+DF7r __RESET+E05w ...
unk_1AF:	.block 1		; DATA XREF: __RESET:main_246r
					; __RESET:main_252w
<<<<<<< HEAD
unk_1B0:	.block 1		; DATA XREF: __RESET:fuel_106w
=======
unk_1B0:	.block 1		; DATA XREF: __RESET:main_106w
>>>>>>> origin/master
					; IV6+586r
unk_1B1:	.block 1		; DATA XREF: IV6+57Dr IV6:loc_F4F0w
unk_1B2:	.block 1		; DATA XREF: IV6+589w IV6+58Fr
unk_1B3:	.block 1		; DATA XREF: __RESET+D1w
		.block 1
unk_1B5:	.block 1		; DATA XREF: ROM:CE14w	ROM:CE2Er ...
unk_1B6:	.block 1		; DATA XREF: ROM:CEA8w	ReInitNEIGT+21w ...
unk_1B7:	.block 1		; DATA XREF: ROM:CEABw	ReInitNEIGT+24w ...
count_1B8:	.block 1		; incremented at F49C
count_1B9:	.block 1		; incremented at F49C
count_1BA:	.block 1		; DATA XREF: ROM:CEB9r	intSIN0+11Aw
					; incremented at F49C
unk_1BB:	.block 1		; DATA XREF: ROM:loc_CE41r
					; ROM:loc_CE48w ...
count_1BC:	.block 1		; DATA XREF: ROM:CD0Aw	ROM:CD21r ...
unk_1BD:	.block 1		; DATA XREF: ROM:loc_CD7Er ROM:CD8Aw
count_1BE:	.block 1		; DATA XREF: ROM:CD53r	ROM:loc_CD70w ...
unk_1BF:	.block 1		; DATA XREF: ROM:CD8Dr	ROM:CD99w
count_1C0:	.block 1		; incremented at F580 (oxy L1?)
count_1C1:	.block 1		; incremented at F580 (oxy R1?)
count_1C2:	.block 1		; incremented at F580 (oxy L2?)
count_1C3:	.block 1		; incremented at F580 (oxy R2?)
unk_1C4:	.block 1		; DATA XREF: ROM:CE71r	ROM:loc_CE86w ...
<<<<<<< HEAD
flags_1C5:	.block 1
flags_1C6:	.block 1		; DATA XREF: ROM:CF5Br	ROM:loc_CF65w ...
					; written at end of main loop; B3 /NSW (/STA), b2 , b1 IDL1, b0	STA
byte_1C7:	.block 1		; last meanKSint MSB *2, saturated at ff
InjPW_LOres:	.block 1		; injector pulsewidth at 128us/bit
RPM_HIres:	.block 1		; RPM/25
=======
unk_1C5:	.block 1
unk_1C6:	.block 1		; DATA XREF: ROM:CF5Br	ROM:loc_CF65w ...
byte_1C7:	.block 1		; last meanKSint MSB *2, saturated at ff
unk_1C8:	.block 1
unk_1C9:	.block 1
>>>>>>> origin/master
unk_1CA:	.block 1
		.block 1
count_1CC:	.block 1
unk_1CD:	.block 1
unk_1CE:	.block 1		; DATA XREF: ROM:loc_CB0Cw ROM:CB46r ...
unk_1CF:	.block 1		; DATA XREF: ROM:loc_CB16w ROM:CB4Fr ...
count_1D0:	.block 1		; DATA XREF: ROM:CC32w
		.block 1
		.block 1
count_1D3:	.block 1		; tof increment	rate
count_1D4:	.block 1		; DATA XREF: ROM:CC35w
unk_1D5:	.block 1
		.block 1
unk_1D7:	.block 1		; DATA XREF: __RESET:mainTOF_17r
					; __RESET+12BAw ...
unk_1D8:	.block 1
unk_1D9:	.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
unk_1F4:	.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
unk_238:	.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
unk_273:	.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
unk_2DF:	.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
		.block 1
; end of 'RAM'

; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

; Segment type:	Regular
		;.segment badaddress
		.org 300h
word_300:	.block 2
word_302:	.block 2
word_304:	.block 2
word_306:	.block 2
word_308:	.block 2
; end of 'badaddress'



; File Name   :	C:\Documents and Settings\Sparkie\Desktop\Toyota PCM hacking\Toyota 1UZ PCM\cap d151803-9260.bin
; Format      :	Binary file
; Base Address:	0000h Range: C000h - 10000h Loaded length: 4000h
; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

; Segment type:	Pure code
		;.segment ROM
		.org 0C000h
		.db  5Fh ; _		; 5f is	NMI, kinda makes sense i suppose.
		.db  5Fh ; _
		.db  5Fh ; _

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_C003:				; CODE XREF: __RESET+17Dp
		ld	#0FEh, count_A9	; incremented at F47D
		ld	a, #34h
		or	a, #0C0h	; kinbda straightforward, =F4
		st	a, asr0n_shadow	; stores configuration information written to asr0n
		st	a, ASR0N	; ASR0 neg edge	counter	value MSB
		ret
; End of function sub_C003


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_C010:				; CODE XREF: IV6:loc_F4DEp
		cmp	#04h, count_AA	; incremented at F47D
		ble	loc_C025
		clr	count_AA	; incremented at F47D
		di
		ld	a, asr0n_shadow	; stores configuration information written to asr0n
		and	a, #0BFh
		st	a, asr0n_shadow	; stores configuration information written to asr0n
		ei
		st	a, ASR0N	; ASR0 neg edge	counter	value MSB
		bra	loc_C034
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_C025:				; CODE XREF: sub_C010+3j
		ld	#0FFh, TIMER3	; Timer	LSB (bit0~bit2)
		ld	a, TIMER3	; Timer	LSB (bit0~bit2)
		cmpb	a, #40h
		beq	loc_C046
		cmpb	a, #08h
		bne	loc_C034
		clr	count_AA	; incremented at F47D

loc_C034:				; CODE XREF: sub_C010+13j sub_C010+20j
		ld	a, asr0n_shadow	; stores configuration information written to asr0n
		or	a, #40h
		st	a, asr0n_shadow	; stores configuration information written to asr0n
		st	a, ASR0N	; ASR0 neg edge	counter	value MSB
		ld	d, #38F0h
		st	d, ASR3		; ASR3 edge counter value MSB
		ld	#0B7h, TIMER3	; Timer	LSB (bit0~bit2)

loc_C046:				; CODE XREF: sub_C010+1Cj
		cmp	#04h, count_A9	; incremented at F47D
		ble	locret_C069
		ld	a, asr0n_shadow	; stores configuration information written to asr0n
		and	a, #7Fh
		st	a, asr0n_shadow	; stores configuration information written to asr0n
		st	a, ASR0N	; ASR0 neg edge	counter	value MSB
		ld	a, asr0n_shadow	; stores configuration information written to asr0n
		or	a, #80h
		st	a, asr0n_shadow	; stores configuration information written to asr0n
		st	a, ASR0N	; ASR0 neg edge	counter	value MSB
		ld	d, #3900h
		st	d, ASR2		; ASR2 edge counter value MSB
		ld	#4Fh, TIMER3	; Timer	LSB (bit0~bit2)
		clr	count_A9	; incremented at F47D

locret_C069:				; CODE XREF: sub_C010+39j
		ret
; End of function sub_C010


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


		; public intSINx
intSINx:				; DATA XREF: ROM:FFDEo
		ld	b, RAMST	; Built-in RAM status
		ld	b, unk_1C
		clrb	bit2, IRQLL	; serial input bit
		ld	#0FFh, TIMER3	; Timer	LSB (bit0~bit2)
		ld	a, TIMER3	; Timer	LSB (bit0~bit2)
		cmpb	a, #30h
		bne	iv0part2
		clr	count_A9	; incremented at F47D

iv0part2:				; CODE XREF: intSINx+Dj
		ld	d, #3900h
		st	d, ASR2		; ASR2 is NE
		ld	#4Fh, TIMER3	; Timer	LSB (bit0~bit2)
		reti
; End of function intSINx


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; increment B bytes of ram by 1	starting from Y, saturates at FF

satcount:				; CODE XREF: satcount+9j
					; sub_C64D:loc_C891p ...
		di
		ld	a, [y]		; postincrement	y (ld a,y+0 | inc y)
		inc	a
		beq	satcount_2
		dec	y
		st	a, [y]

satcount_2:				; CODE XREF: satcount+3j
		ei
		dec	b
		bne	satcount	; increment B bytes of ram by 1	starting from Y, saturates at FF
		ret
; End of function satcount


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; decrements B bytes of	ram by 1 starting from Y, saturates at 00

satuncount:				; CODE XREF: satuncount+9j
					; __RESET+FD2p	...
		di
		ld	a, y + 00h
		beq	satuncount_2	; postincrement	Y
		dec	a

satuncount_2:				; CODE XREF: satuncount+3j
		st	a, [y]		; postincrement	Y
		ei
		dec	b
		bne	satuncount	; decrements B bytes of	ram by 1 starting from Y, saturates at 00
		ret
; End of function satuncount


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; returns upper	16 bits	in Y, lower 16 bits in D

MulDbyY:				; CODE XREF: sub_C61C+14p __RESET+27Ep ...
		push	y
		push	d		; stack	is now DhDlYhYl
		mov	s, x
		mul	a, x + 02h	; Dh*Yh
		mov	d, y
		ld	a, x + 00h
		mul	a, x + 03h	; Dh*Yl
		add	y, a
		st	b, x + 00h
		ld	a, x + 01h
		mul	a, x + 02h	; Dl*Yh
		add	y, a
		add	b, x + 00h	; looking for a	carry
		bcc	MulDbyY2
		inc	y

MulDbyY2:				; CODE XREF: MulDbyY+14j
		st	b, x + 00h
		ld	a, x + 01h
		mul	a, x + 03h	; Dl*Yl
		add	a, x + 00h	; looking for last carry
		bcc	MulDbyY3
		inc	y

MulDbyY3:				; CODE XREF: MulDbyY+1Fj
		pull	x
		pull	x		; tidy up stack
		ret
; End of function MulDbyY


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; divide D by X, does some shifting to return ?? bits

divDbyX:				; CODE XREF: __RESET+257p __RESET+29Cp ...
		st	x, temp_51
		beq	divDbyX_end	; if zero return
		shr	d
		mov	d, y
		clr	a		; clear	d
		clr	b
		mov	d, x		; clear	x
		ld	d, temp_51

divDbyX1:				; CODE XREF: divDbyX+Fj
		bmi	divDbyX2	; shift	left until msb is 1
		inc	x		; x counts number of shifts
		shl	d		; shifting initial X until MSB D is set
		bra	divDbyX1	; shift	left until msb is 1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

divDbyX2:				; CODE XREF: divDbyX:divDbyX1j
		st	x, temp_51	; 51 now stores	the number of times we shifted left
		inc	a		; because....?
		push	d		; push shifted input x onto stack
		mov	s, x
		dec	x
		dec	x		; compensate for later pushes
		ld	a, x + 02h	; load MSB of shifted input X to get cond codes
		mov	y, d		; and then clobber it with initial D input
		beq	divDbyX3	; pushing Int.Frac result
		div	d, x + 02h	; d is input d,	x+02 is	(MSB of	shifted	input x)+1
		push	b		; b is the division, a is the modulo
		clr	b
		div	d, x + 02h
		pull	a

divDbyX3:				; CODE XREF: divDbyX+1Bj
		push	d		; pushing Int.Frac result
		mov	y, d		; y still contains input arg d
		dec	x + 02h		; get rid of original +1
		div	d, x + 02h	; same operation as above to get int.frac in D
		push	b
		clr	b
		div	d, x + 02h
		pull	a		; AccD now contains new	int.frac
		neg	x + 03h		; negate shifted input X LSB where it hides in the stack
		beq	divDbyX4
		sub	d, x + 00h	; subtract old int.frac, yielding a small positive number
		push	b
		mul	a, x + 03h
		mov	d, y
		pull	a
		mul	a, x + 03h
		add	y, a
		mov	y, d
		add	d, x + 00h	; after	a short	interpolation we now have a precise div	by 16

divDbyX4:				; CODE XREF: divDbyX+31j
		pull	y
		pull	y		; tidy stack
		ld	x, temp_51	; x now	contains number	of shifts we did to get	divisor

divDbyX5:				; CODE XREF: divDbyX+4Bj divDbyX+51j
		cmp	x, #0007h
		bcc	divDbyX6
		inc	x
		shr	d
		bra	divDbyX5
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

divDbyX6:				; CODE XREF: divDbyX+47j
		beq	divDbyX_end
		dec	x
		shl	d
		bpz	divDbyX5

divDbyX_end:				; CODE XREF: divDbyX+2j
					; divDbyX:divDbyX6j
		ret
; End of function divDbyX


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; returns upper	16b in AccD

MulAbyY:				; CODE XREF: sub_C634:loc_C63Fp
					; __RESET+294p	...
		push	y
		mov	s, x
		xch	a, x + 01h
		mul	a, x + 01h	; d now	contains input acca*lsBy
		addc	a, #00h
		xch	a, x + 01h
		mul	a, x + 00h	; d now	contains input acca*msBy
		mov	d, y
		pull	d
		add	y, b
		mov	y, d
		ret
; End of function MulAbyY

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0DAh ; Ú
		.db 0F0h ; ğ

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SaturateData:				; CODE XREF: sub_C8D9:loc_C8E9p
					; sub_C907+1p ...
		pull	x
		cmp	a, x + 00h
		ble	satd2
		ld	a, x + 00h
		bra	satd3
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

satd2:					; CODE XREF: SaturateData+3j
		cmp	a, x + 01h
		bcc	satd4
		ld	a, x + 01h

satd3:					; CODE XREF: SaturateData+7j
		setc
		jmp	x + 02h
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

satd4:					; CODE XREF: SaturateData+Bj
		clrc
		jmp	x + 02h
; End of function SaturateData


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SaturateD16b:				; CODE XREF: sub_C64D+226p
					; sub_C895+18p	...
		pull	x
		cmp	d, x + 00h
		ble	sat16_1
		ld	d, x + 00h
		bra	sat16_2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sat16_1:				; CODE XREF: SaturateD16b+3j
		cmp	d, x + 02h
		bcc	sat16_3
		ld	d, x + 02h

sat16_2:				; CODE XREF: SaturateD16b+7j
		setc
		jmp	x + 04h
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sat16_3:				; CODE XREF: SaturateD16b+Bj
		clrc
		jmp	x + 04h
; End of function SaturateD16b


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; Lookup unk_7A, integer return	in Acca, fraction return in AccB

TwoD_7A:				; CODE XREF: __RESET+75Ap __RESET+7A1p ...
		ld	d, word_7A	; meanKSint divided by a air temp comp factor
; End of function TwoD_7A


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; lookup AccD/64, integer return in Acca, fraction return in AccB

TwoD_AccD:				; CODE XREF: __RESET+28Ep
		div	d, #064
		bcc	TwoD_AccD_1
		ld	b, #0FFh

TwoD_AccD_1:				; CODE XREF: TwoD_AccD+2j
		mov	b, a
		bra	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB
; End of function TwoD_AccD

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TwoD_RPM:				; CODE XREF: __RESET+2A9p __RESET+4A7p ...
		ld	a, RPM		; lookup RPM, integer return in	Acca, fraction return in AccB
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  8Ch ; Œ		; cpx... Nop's through the next load

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; lookup Raw Water Temp, integer return	in Acca, fraction return in AccB

TwoD_rawTHW:				; CODE XREF: sub_C4DF:loc_C4E2p
					; sub_C61Cp ...
		ld	a, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
; End of function TwoD_rawTHW


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; X value in AccA, integer return in Acca, fraction return in AccB

TwoDTable:				; CODE XREF: TwoD_AccD+7j sub_C4DF+1Ap ...
		cmp	a, y + 00h
		bgt	TwoD1		; bounce if a is greater than data

TwoDendSat:				; CODE XREF: TwoDTable+11j
		clr	a
		bra	TwoD4
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TwoDsearch:				; CODE XREF: TwoDTable+Bj
		inc	y
		inc	y

TwoD1:					; CODE XREF: TwoDTable+2j
		cmp	a, y + 02h
		bgt	TwoDsearch	; loop until data is greater than accA
		ld	b, y + 02h	; b now	has larger X value
		cmp	b, #0FFh	; signifies table end
		beq	TwoDendSat
		sub	a, y + 00h	; subtract from	desired	X the smaller avlue from table
		sub	b, y + 00h	; find the difference between points
		push	b		; stack	decrement
		mov	s, x		; x now	points to x axis difference between table points
		clr	b
		div	d, x + 00h	; b now	has ratio of desired point inside table	points
		inc	s		; stack	increment
		ld	a, y + 03h
		bcs	TwoD2
		cmp	a, y + 01h
		bcc	TwoD3		; bounce if table is increasing
		neg	b		; otherwise we negate the ratio	and tweak our pointers to get the same result
		ld	a, y + 01h

TwoD2:					; CODE XREF: TwoDTable+1Fj
		inc	y
		inc	y

TwoD3:					; CODE XREF: TwoDTable+23j
		sub	a, y + 01h

TwoD4:					; CODE XREF: TwoDTable+5j
		inc	y
		push	b		; stack	decrement
		mov	s, x
		mul	a, x + 00h
		inc	s		; stack	increment
		add	a, y + 00h	; add the offset from base ale calculated with the base	value. bam! table output.
		ret
; End of function TwoDTable


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; divides D by 12, returns 16b result in unks 53:54

DivDby12:				; CODE XREF: __RESET+3EBp
					; __RESET+136Cp ...
		st	b, temp_54
		mov	a, b
		clr	a
		div	d, #012
		st	b, temp_53
		ld	b, temp_54
		div	d, #012
		st	b, temp_54
		ret
; End of function DivDby12

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  96h ; –
		.db 0F0h ; ğ
		.db 0CCh ; Ì
		.db  30h ; 0
		.db  45h ; E
		.db  10h
		.db 0C0h ; À
		.db  30h ; 0
		.db  40h ; @
		.db  0Bh

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; called with C3FE in mind, other parameter in temp_53:temp_54,	output in D

ThreeD_RPM:				; CODE XREF: __RESET+1371p
		ld	d, RPM		; MSB is RPM/50, LSB is	fraction of 50
		cmp	a, #024		; 1200 RPM
		bcs	threeDtable_1
		add	a, #024
		bra	ThreeDtable	; reduced slope	above 1200 rpm
; End of function ThreeD_RPM


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; inputs in D and temp_53:temp_54, output in D

ThreeDtable2:				; CODE XREF: __RESET+877p
		shr	d
; End of function ThreeDtable2


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; inputs in D and temp_53:temp_54, output in D

ThreeDtable:				; CODE XREF: ThreeD_RPM+8j
					; __RESET+3F0p	...
		shr	d

threeDtable_1:				; CODE XREF: ThreeD_RPM+4j
		shr	d
		shr	d
		bsr	SubtAndBound
		st	d, temp_51	; rpm subtbounded
		mov	y, d
		mov	d, x		; x now	holds original y ptr +1
		inc	y
		inc	y		; y now	original y+3
		ld	d, temp_53	; load MSB:LSB
		bsr	SubtAndBound
		push	b
		ld	b, x + 01h	; should be input y pointer + 2	(D limit, row size-1)
		inc	b		; = row	length in bytes
		st	b, temp_53
		mul	a, temp_53
		add	y, b		; offset into table. y is +4 from root +b
		push	y
		ld	d, temp_51
		bsr	Interpolate	; some kind of interpolation dance
		st	a, temp_54	; low row value
		pull	y
		ld	b, temp_53
		add	y, b		; offset one more row
		ld	d, temp_51
		bsr	Interpolate	; some kind of interpolation dance
		xch	a, temp_54	; exchange high	row value for low row value
		st	a, temp_53	; store	low row	value
		ld	y, #0053h	; interpolating	along column values
		pull	b
		bra	Interp_1
; End of function ThreeDtable


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SubtAndBound:				; CODE XREF: ThreeDtable+3p
					; ThreeDtable+Dp
		sub	d, y + 00h
		bcc	subtbound_1
		clr	a
		clr	b

subtbound_1:				; CODE XREF: SubtAndBound+2j
		cmp	a, y + 02h
		bcs	subtbound_2	; select the smaller of	subtraction or y+02
		ld	a, y + 02h
		clr	b

subtbound_2:				; CODE XREF: SubtAndBound+8j
		inc	y
		ret
; End of function SubtAndBound


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; some kind of interpolation dance

Interpolate:				; CODE XREF: ThreeDtable+1Bp
					; ThreeDtable+25p
		add	a, #002
		add	y, a

Interp_1:				; CODE XREF: ThreeDtable+2Fj
		mov	b, a
		beq	interp_ret
		push	b
		mov	s, x
		ld	a, y + 01h
		sub	a, y + 00h
		bcc	interp_2
		neg	a		; this looks a lot like	an interpolation routine
		neg	b
		xch	b, x + 00h
		inc	y

interp_2:				; CODE XREF: Interpolate+Cj
		mul	a, x + 00h
		inc	s		; tidy stack

interp_ret:				; CODE XREF: Interpolate+4j
		add	a, y + 00h
		ret
; End of function Interpolate

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

divDby128:				; shift	D right	7 times
		shr	d

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; shift	D right	6 times

divDby64:				; CODE XREF: __RESET+FA5p ROM:FA41p
		shr	d
; End of function divDby64


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; shift	D right	5 times

divDby32:				; CODE XREF: sub_EC27+3p
		shr	d
		shr	d
		shr	d
		shr	d
		shr	d
		ret
; End of function divDby32

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		shra	a
		rorc	b
		shra	a
		rorc	b
		ret

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; shift	D right	6 times, then saturate B if A>0

DivDby64sat:				; CODE XREF: __RESET+BDDp
		shr	d
		shr	d
		shr	d
		shr	d
		shr	d
		shr	d
		cmpz	a
		beq	locret_C22C
		ld	b, #0FFh

locret_C22C:				; CODE XREF: DivDby64sat+7j
		ret
; End of function DivDby64sat


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; fill ram with	default	values

InitRAM:				; CODE XREF: InitRAM+Aj __RESET+72p
		ld	a, [y]
		beq	locret_C239	; an address of	zero is	code to	quit
		ld	x, #0000h
		add	x, a
		ld	a, [y]
		st	a, x + 00h
		bra	InitRAM		; fill ram with	default	values
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

locret_C239:				; CODE XREF: InitRAM+1j
		ret
; End of function InitRAM


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; or b with Flags_50

orFlags_50:				; CODE XREF: __RESET+F72p
					; __RESET+11CDp ...
		di
<<<<<<< HEAD
		or	b, flags_50	; could	be bits	for 6336 output	chip, B0 probably HTR L+R1, B1 probably	HTR L+R2
=======
		or	b, flags_50	; could	be bits	for 6336 output	chip
>>>>>>> origin/master
		bra	retFlags_50
; End of function orFlags_50


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; and b	with Flags_50

andFlags_50:				; CODE XREF: __RESET+F85p
					; __RESET+11C4p ...
		di
		and	b, flags_50	; could	be bits	for 6336 output	chip, B0 probably HTR L+R1, B1 probably	HTR L+R2

retFlags_50:				; CODE XREF: orFlags_50+3j
<<<<<<< HEAD
		st	b, flags_50	; could	be bits	for 6336 output	chip, B0 probably HTR L+R1, B1 probably	HTR L+R2
=======
		st	b, flags_50	; could	be bits	for 6336 output	chip
>>>>>>> origin/master
		ei
		ret
; End of function andFlags_50

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
unk_C246:	.db  03h		; D741 2d lookup for word_78, also DC0D	for 7A
		.db 0CBh ; Ë
		.db  06h
		.db 0D2h ; Ò
		.db  0Dh
		.db 0D5h ; Õ
		.db  16h
		.db 0D5h ; Õ
		.db  1Eh
		.db 0DCh ; Ü
		.db  45h ; E
		.db 0F1h ; ñ
		.db  55h ; U
		.db 0F1h ; ñ
		.db  7Bh ; {
		.db 0E2h ; â
		.db 0ACh ; ¬
		.db 0E0h ; à
		.db 0FCh ; ü
		.db 0E6h ; æ
		.db 0FFh
		.db  10h		; D713 2d lookup for RPM
		.db 0BCh ; ¼
		.db  18h
		.db  7Ah ; z
		.db  20h
		.db  59h ; Y
		.db  30h ; 0
		.db  3Ah ; :
		.db  38h ; 8
		.db  32h ; 2
		.db  50h ; P
		.db  1Fh
		.db  68h ; h
		.db  17h
		.db 0FFh
<<<<<<< HEAD
ScaleFactor:	.dw 0A580h		; DATA XREF: __RESET:fuel_124r
=======
ScaleFactor:	.dw 0A580h		; DATA XREF: __RESET:main_124r
>>>>>>> origin/master
					; value	to scale load to get pulsewidth
		.dw 0180h		; 3d table TPS vs RPM
		.db  05h
		.db  00h
		.db  00h
		.db  08h
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  0Dh
		.db  08h
		.db  06h
		.db  05h
		.db  05h
		.db  04h
		.db  1Bh
		.db  10h
		.db  0Ch
		.db  0Ah
		.db  09h
		.db  07h
		.db  26h ; &
		.db  1Ah
		.db  14h
		.db  10h
		.db  0Dh
		.db  0Bh
		.db  30h ; 0
		.db  24h ; $
		.db  1Bh
		.db  14h
		.db  10h
		.db  0Eh
		.db  48h ; H
		.db  41h ; A
		.db  38h ; 8
		.db  30h ; 0
		.db  2Bh ; +
		.db  26h ; &
		.db  4Eh ; N
		.db  50h ; P
		.db  4Dh ; M
		.db  46h ; F
		.db  43h ; C
		.db  40h ; @
		.db  4Fh ; O
		.db  54h ; T
		.db  54h ; T
		.db  54h ; T
		.db  54h ; T
		.db  50h ; P
		.db  50h ; P
		.db  57h ; W
		.db  5Bh ; [
		.db  62h ; b
		.db  69h ; i
		.db  67h ; g
		.db  0Ah		; DD32,	2d lookup for DB
		.db  12h
		.db  3Eh ; >
		.db  4Dh ; M
		.db  74h ; t
		.db 0D6h ; Ö
		.db 0FFh
		.db  00h
		.db  00h
		.db  5Dh ; ]		; DCD7,	2d lookup for rawTHW
		.db  96h ; –
		.db 0B3h ; ³
		.db  5Bh ; [
		.db 0E4h ; ä
		.db  26h ; &
		.db 0FFh
		.db  4Eh ; N		; D75C,	lookup for RPM
		.db  98h ; ˜
		.db  60h ; `
		.db 0A0h ;  
		.db  78h ; x
		.db  90h ; 
		.db 0FFh
		.db  4Ch ; L		; Bovlts table from E455
		.db  9Dh ; 
		.db  66h ; f
		.db  62h ; b
		.db  80h ; €
		.db  40h ; @
		.db  99h ; ™
		.db  32h ; 2
		.db 0B3h ; ³
		.db  22h ; "
		.db 0CCh ; Ì
		.db  1Bh
		.db 0FFh
		.db  0Bh		; C623,	lookup for rawTHA
		.db 0EAh ; ê
		.db  24h ; $
		.db 0B7h ; ·
		.db  50h ; P
		.db  8Ch ; Œ
		.db  86h ; †
		.db  66h ; f
		.db 0B3h ; ³
		.db  45h ; E
		.db 0D2h ; Ò
		.db  29h ; )
		.db 0E4h ; ä
		.db  0Fh
		.db 0FFh
byte_C2DB:	.db 018			; data used by F070 (18)
		.db 021			; 21
		.db 006			; 6
		.db 009			; 9
		.db  15h		; C619 2d lookup for rawTHW
		.db 0B9h ; ¹
		.db  24h ; $
		.db  67h ; g
		.db  50h ; P
		.db  46h ; F
		.db  9Eh ; 
		.db  3Fh ; ?
		.db 0E4h ; ä
		.db  2Ch ; ,
		.db 0FFh
unk_C2EA:	.db  86h ; †		; C5F4,	lookup for rawTHW
		.db  14h		; 5120
		.db 0D2h ; Ò
		.db  0Ah		; 2560
		.db 0FFh
		.db  15h		; E9C6,DC7C,2d lookup for rawTHW
		.db  73h ; s
		.db  38h ; 8
		.db  4Fh ; O
		.db  5Dh ; ]
		.db  43h ; C
		.db  86h ; †
		.db  21h ; !
		.db 0D2h ; Ò
		.db  00h
		.db 0FFh
		.db  1Eh		; DDB6,	2dlookup RPM
		.db 0FFh
		.db  46h ; F
		.db  9Ah ; š
		.db 0FFh
		.db  15h		; DC85,	2d lookup for rawTHW
		.db 0C0h ; À
		.db  38h ; 8
		.db  54h ; T
		.db  5Dh ; ]
		.db  4Ah ; J
		.db  86h ; †
		.db  26h ; &
		.db 0D2h ; Ò
		.db  0Dh
		.db 0FFh
		.db  5Dh ; ]		; DCA6,	2d lookup for rawTHW
		.db  52h ; R
		.db  79h ; y
		.db  43h ; C
		.db  9Eh ; 
		.db  2Eh ; .
		.db 0E4h ; ä
		.db  0Dh
		.db 0FFh
		.db  15h		; EA21,	rawTHW
		.db  2Ch ; ,
		.db  79h ; y
		.db  1Ch
		.db 0D2h ; Ò
		.db  0Dh
		.db 0E4h ; ä
		.db  0Dh
		.db 0FFh
		.db  0Bh		; DDAF,	2d lookup for rawTHW
		.db 0B0h ; °
		.db 0EAh ; ê
		.db  30h ; 0
		.db 0FFh
		.db  38h ; 8		; D95A,	2d lookup for RPM, establishes limits for compLOAD to set flags_A2 bit6
		.db 0F0h ; ğ
		.db  38h ; 8
		.db  6Ch ; l
		.db  68h ; h
		.db  24h ; $
		.db 0FFh
		.db  26h ; &		; E34F,	7A
		.db  8Ch ; Œ
		.db  4Dh ; M
		.db  61h ; a
		.db  86h ; †
		.db  40h ; @
		.db 0FFh
		.db  26h ; &		; E357,	7A
		.db  69h ; i
		.db  4Dh ; M
		.db  49h ; I
		.db  86h ; †
		.db  31h ; 1
		.db 0FFh
		.db  24h ; $		; D9E3,	2d lookup for rawTHW
		.db  2Eh ; .
		.db 0E4h ; ä
		.db  18h
		.db 0FFh
		.dw 0708h		; word data for	DD63, pulsewidth limitations
		.dw 0708h		; 7.200	ms
		.dw 0FA0h		; 16.000 ms
		.dw 1130h		; 17.6 ms
		.db  32h ; 2		; E4B0,	RPM
		.db  00h
		.db  32h ; 2
		.db  01h
		.db  3Ch ; <
		.db  03h
		.db  50h ; P
		.db  05h
		.db  78h ; x
		.db  14h
		.db 0FFh
		.db  01h		; Three	D table	RPM by compLoad, row offset high
		.db  00h		; row offset low
		.db  0Eh		; row maximum
		.db  02h		; column offset	high
		.db  00h		; column offset	low
		.db  0Ah		; column maximum
		.db  66h ; f
		.db  95h ; •
		.db 0ABh ; «
		.db 0D1h ; Ñ
		.db 0D1h ; Ñ
		.db 0EBh ; ë
		.db 0EBh ; ë
		.db 0EBh ; ë
		.db 0EBh ; ë
		.db 0EBh ; ë
		.db 0EBh ; ë
		.db 0EBh ; ë
		.db 0EBh ; ë
		.db 0D5h ; Õ
		.db 0C9h ; É
		.db  37h ; 7
		.db  73h ; s
		.db  8Dh ; 
		.db 0B3h ; ³
		.db 0AFh ; ¯
		.db 0E2h ; â
		.db 0E2h ; â
		.db 0CDh ; Í
		.db 0DAh ; Ú
		.db 0C9h ; É
		.db 0BCh ; ¼
		.db 0C9h ; É
		.db 0CDh ; Í
		.db 0D5h ; Õ
		.db 0D5h ; Õ
		.db  26h ; &
		.db  55h ; U
		.db  6Fh ; o
		.db  89h ; ‰
		.db  95h ; •
		.db 0AFh ; ¯
		.db 0B3h ; ³
		.db 0AFh ; ¯
		.db 0B7h ; ·
		.db 0B7h ; ·
		.db 0B3h ; ³
		.db 0B3h ; ³
		.db 0BCh ; ¼
		.db 0B3h ; ³
		.db 0BCh ; ¼
		.db  22h ; "
		.db  51h ; Q
		.db  66h ; f
		.db  89h ; ‰
		.db  8Dh ; 
		.db  9Ah ; š
		.db 0ABh ; «
		.db 0ABh ; «
		.db 0ABh ; «
		.db 0ABh ; «
		.db 0A6h ; ¦
		.db 0ABh ; «
		.db 0ABh ; «
		.db 0ABh ; «
		.db 0A6h ; ¦
		.db  1Ah
		.db  49h ; I
		.db  5Eh ; ^
		.db  7Ch ; |
		.db  84h ; „
		.db  95h ; •
		.db 0A2h ; ¢
		.db 0A2h ; ¢
		.db 0A6h ; ¦
		.db 0A2h ; ¢
		.db 0A2h ; ¢
		.db  9Eh ; 
		.db  9Ah ; š
		.db 0A6h ; ¦
		.db  9Eh ; 
		.db  11h
		.db  33h ; 3
		.db  5Ah ; Z
		.db  6Fh ; o
		.db  80h ; €
		.db  8Dh ; 
		.db  9Ah ; š
		.db  9Ah ; š
		.db  9Eh ; 
		.db  9Ah ; š
		.db  9Ah ; š
		.db  95h ; •
		.db  95h ; •
		.db  95h ; •
		.db  9Eh ; 
		.db  09h
		.db  1Ah
		.db  3Ch ; <
		.db  55h ; U
		.db  77h ; w
		.db  89h ; ‰
		.db  95h ; •
		.db  95h ; •
		.db  9Ah ; š
		.db  9Ah ; š
		.db  9Ah ; š
		.db  91h ; ‘
		.db  95h ; •
		.db  95h ; •
		.db  95h ; •
		.db  09h
		.db  1Ah
		.db  33h ; 3
		.db  49h ; I
		.db  66h ; f
		.db  77h ; w
		.db  7Ch ; |
		.db  7Ch ; |
		.db  9Ah ; š
		.db  91h ; ‘
		.db  91h ; ‘
		.db  8Dh ; 
		.db  8Dh ; 
		.db  95h ; •
		.db  95h ; •
		.db  00h
		.db  2Bh ; +
		.db  49h ; I
		.db  49h ; I
		.db  66h ; f
		.db  73h ; s
		.db  7Ch ; |
		.db  7Ch ; |
		.db  89h ; ‰
		.db  89h ; ‰
		.db  8Dh ; 
		.db  89h ; ‰
		.db  77h ; w
		.db  80h ; €
		.db  8Dh ; 
		.db  00h
		.db  2Bh ; +
		.db  49h ; I
		.db  5Ah ; Z
		.db  66h ; f
		.db  6Bh ; k
		.db  7Ch ; |
		.db  77h ; w
		.db  80h ; €
		.db  80h ; €
		.db  89h ; ‰
		.db  80h ; €
		.db  77h ; w
		.db  80h ; €
		.db  8Dh ; 
		.db  00h
		.db  2Bh ; +
		.db  49h ; I
		.db  5Ah ; Z
		.db  66h ; f
		.db  6Bh ; k
		.db  7Ch ; |
		.db  77h ; w
		.db  80h ; €
		.db  77h ; w
		.db  84h ; „
		.db  80h ; €
		.db  77h ; w
		.db  80h ; €
		.db  8Dh ; 
unk_C3F9:	.db  28h ; (		; E951,	F0, 2000RPM
		.db  2Bh ; +		; 43 counts
		.db  60h ; `		; 4800RPM
		.db  80h ; €		; 128 counts
		.db 0FFh
		.db  04h		; Three	D table	RPM by load, Row offset	high
		.db  00h		; row offset low
		.db  09h		; row maximum
		.db  02h		; column offset	high
		.db  00h		; column offset	low
		.db  08h		; column maximum
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  00h		; +10
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  49h ; I
		.db  33h ; 3
		.db  1Ah
		.db  15h
		.db  15h
		.db  09h		; +d20
		.db  04h
		.db  00h
		.db  22h ; "
		.db  22h ; "
		.db  6Bh ; k
		.db  4Dh ; M
		.db  1Ah
		.db  26h ; &
		.db  22h ; "
		.db  1Eh		; +d30
		.db  00h
		.db  00h
		.db  33h ; 3
		.db  40h ; @
		.db  49h ; I
		.db  37h ; 7
		.db  2Bh ; +
		.db  2Bh ; +
		.db  22h ; "
		.db  1Eh		; +d40
		.db  04h
		.db  00h
		.db  1Eh
		.db  2Fh ; /
		.db  00h
		.db  11h
		.db  11h
		.db  15h
		.db  11h
		.db  09h		; +d50
		.db  00h
		.db  00h
		.db  11h
		.db  00h
		.db  00h
		.db  00h
		.db  11h
		.db  09h
		.db  09h
		.db  09h		; +d60
		.db  00h
		.db  00h
		.db  09h
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  04h
		.db  00h
		.db  00h		; +d70
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  09h
		.db  0Dh
		.db  00h		; +d80
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  00h		; +d90
		.db  00h
		.db  24h ; $		; E85A,	F7
		.db 0C0h ; À
		.db  38h ; 8
		.db  95h ; •
		.db 0D2h ; Ò
		.db  80h ; €
		.db 0FFh
		.db  00h
		.db  00h
		.db  24h ; $		; E863,	F7
		.db 0C0h ; À
		.db  38h ; 8
		.db  95h ; •
		.db  86h ; †
		.db  5Ah ; Z
		.db 0A9h ; ©
		.db  5Ah ; Z
		.db 0D2h ; Ò
		.db  80h ; €
		.db 0FFh
		.db  00h
		.db  00h
		.db 0EEh ; î		; E8DB,	F7
		.db  00h
		.db 0F0h ; ğ
		.db  0Dh
		.db 0FFh
		.db  00h
		.db  44h ; D
		.db  6Fh ; o
		.db  89h ; ‰
		.db  9Ah ; š
		.db 0ABh ; «
		.db 0BCh ; ¼
		.db 0CDh ; Í
		.db  18h		; E8BA,	compLOAD
		.db  33h ; 3
		.db  78h ; x
		.db  00h
		.db 0FFh
		.db  86h ; †		; rawTHW
		.db  10h
		.db  86h ; †
		.db  0Ah
		.db 0DCh ; Ü
		.db  0Ah
		.db 0DCh ; Ü
		.db  05h
		.db 0FFh
		.db  24h ; $		; C4DA 2d table	for rawTHW
		.db  7Bh ; {
		.db  6Bh ; k
		.db  58h ; X
		.db 0B3h ; ³
		.db  4Eh ; N
		.db 0DCh ; Ü
		.db  3Ah ; :
		.db 0FFh
		.db  33h ; 3		; C4F6,	unk_1A8
		.db  08h
		.db  80h ; €
		.db  00h
		.db 0FFh
		.db  15h		; C4DF 2d table	for rawTHW
		.db  7Bh ; {
		.db  38h ; 8
		.db  58h ; X
		.db 0B3h ; ³
		.db  49h ; I
		.db 0DCh ; Ü
		.db  3Ah ; :
		.db 0FFh
		.db  86h ; †		; E0F6,	rawTHW
		.db 0A0h ;  
		.db 0B3h ; ³
		.db  90h ; 
		.db 0DCh ; Ü
		.db  64h ; d
		.db 0FFh
		.db  86h ; †		; E0FE,	rawTHW
		.db  78h ; x
		.db 0B3h ; ³
		.db  6Ch ; l
		.db 0DCh ; Ü
		.db  4Ch ; L
		.db 0FFh
		.db  3Ah ; :
		.db  60h ; `
		.db  60h ; `
		.db  60h ; `
		.db  10h
		.db  10h
		.db  10h
		.db  10h
		.db  01h		; 8b constants for E0C8
		.db  00h
		.db  16h
		.db  06h
		.db  14h		; E052,	2d lookup for RPM
		.db  3Eh ; >
		.db  3Ch ; <
		.db  5Ch ; \
		.db 0FFh
		.db  00h
		.db  00h
		.db  34h ; 4		; E097,	word_F0	ish
		.db  00h
		.db  34h ; 4
		.db  06h
		.db 0FFh
		.db  0Ch		; E072,	5E
		.db  00h
		.db  0Fh
		.db  06h
		.db 0FFh
		.db  0Ch		; E06D,	5E
		.db  00h
		.db  11h
		.db  0Ah
		.db 0FFh
		.db  06h
		.db  14h
		.db  0Fh
		.db  01h

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; return in A not exceeding 125

sub_C4DA:				; CODE XREF: __RESET+A19p __RESET+A91p ...
		ld	y, #0C48Fh
		bra	loc_C4E2
; End of function sub_C4DA


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; return in A not exceeding 125

sub_C4DF:				; CODE XREF: __RESET+C8Bp
		ld	y, #0C49Dh

loc_C4E2:				; CODE XREF: sub_C4DA+3j
		jsr	TwoD_rawTHW	; lookup Raw Water Temp, integer return	in Acca, fraction return in AccB
		ld	b, unk_DA
		shr	b
		shr	b
		shr	b
		cmp	b, #007
		ble	loc_C4F0
		ld	b, #07h

loc_C4F0:				; CODE XREF: sub_C4DF+Dj
		add	a, b
		st	a, temp_51
		ld	a, byte_1A8	; air temp and baro compensation for load from AFM
		ld	y, #0C498h
		jsr	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB
		add	a, temp_51
		cmp	a, #125
		ble	locret_C504
		ld	a, #125		; saturate

locret_C504:				; CODE XREF: sub_C4DF+21j
		ret
; End of function sub_C4DF


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_C505:				; CODE XREF: __RESET+171p
					; __RESET:main_157p
		ld	d, word_82
		xor	b, #0FFh	; not bits
		cmp	a, b
		bne	loc_C510
		cmp	a, #120
		ble	loc_C512

loc_C510:				; CODE XREF: sub_C505+5j
		ld	a, #020

loc_C512:				; CODE XREF: sub_C505+9j
		st	a, unk_DA
		ret
; End of function sub_C505

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  20h
		.db  20h
		.db  08h
		.db  08h
		.db  08h
		.db  14h
		.db  08h
		.db  18h
		.db  1Ch
		.db  14h
		.db  10h
		.db  14h
		.db  00h
		.db  14h
		.db  14h
		.db  14h
		.db  00h
		.db  00h
		.db  00h
		.db  10h
		.db  0Ch
		.db  00h
		.db  0Ch
		.db  14h
		.db  0Ch
		.db  00h
		.db  00h
		.db  10h
		.db  04h
		.db  0Ch
		.db  04h
		.db  0Ch
		.db  14h
		.db  0Ch
		.db  10h
		.db  10h
		.db  03h
		.db  06h
		.db  0Ch
		.db  09h
		.db  09h
		.db  03h
		.db  06h
		.db  0Ch
		.db  00h
		.db  00h
		.db  00h
		.db  00h
		.db  01h
		.db  02h
		.db  04h
		.db  08h
		.db  02h		; data for f2b3
		.db  04h
		.db  06h
unk_C54C:	.db  03h		; 3d table, compLOAD by	RPM
		.db  00h
		.db  0Ch
		.db  02h
		.db  00h
		.db  07h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db 0A2h ; ¢
		.db  6Fh ; o
		.db  6Fh ; o
		.db  66h ; f
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  44h ; D
		.db 0CDh ; Í
		.db 0BCh ; ¼
		.db  6Fh ; o
		.db  77h ; w
		.db  2Bh ; +
		.db  4Dh ; M
		.db  4Dh ; M
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db 0A2h ; ¢
		.db 0CDh ; Í
		.db 0CDh ; Í
		.db 0BCh ; ¼
		.db 0ABh ; «
		.db  55h ; U
		.db  5Eh ; ^
		.db  66h ; f
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db 0A2h ; ¢
		.db 0C4h ; Ä
		.db 0A2h ; ¢
		.db 0B3h ; ³
		.db  9Ah ; š
		.db  55h ; U
		.db  55h ; U
		.db  55h ; U
		.db  22h ; "
		.db  04h
		.db  04h
		.db  04h
		.db  04h
		.db  6Fh ; o
		.db  6Fh ; o
		.db  9Ah ; š
		.db 0BCh ; ¼
		.db  91h ; ‘
		.db  66h ; f
		.db  66h ; f
		.db  66h ; f
		.db  3Ch ; <
		.db  22h ; "
		.db  04h
		.db  04h
		.db  04h
		.db  4Dh ; M
		.db  80h ; €
		.db 0ABh ; «
		.db 0ABh ; «
		.db 0ABh ; «
		.db  6Fh ; o
		.db  66h ; f
		.db  66h ; f
		.db  5Eh ; ^
		.db  33h ; 3
		.db  33h ; 3
		.db  11h
		.db  1Ah
		.db  66h ; f
		.db  91h ; ‘
		.db 0A2h ; ¢
		.db 0ABh ; «
		.db  89h ; ‰
		.db  80h ; €
		.db  80h ; €
		.db  66h ; f
		.db  66h ; f
		.db  55h ; U
		.db  33h ; 3
		.db  33h ; 3
		.db  33h ; 3
		.db  0Ah		; EA32,F0
		.db  50h ; P
		.db  20h
		.db  1Ch
		.db  50h ; P
		.db  2Ch ; ,
		.db 0FFh
		.db  00h
		.db  00h
		.db  34h ; 4		; DC54,	2d lookup for 7A
		.db 0A0h ;  
		.db  3Dh ; =
		.db  80h ; €
		.db  45h ; E
		.db  60h ; `
		.db  54h ; T
		.db  28h ; (
		.db  5Eh ; ^
		.db  18h
		.db  77h ; w
		.db  10h
		.db  9Bh ; ›
		.db  00h
		.db 0FFh
		.db 0B3h ; ³		; DC5F,	2d lookup for F7
		.db  00h
		.db 0D2h ; Ò
		.db  30h ; 0
		.db 0DCh ; Ü
		.db  50h ; P
		.db 0E0h ; à
		.db  70h ; p
		.db 0E4h ; ä
		.db 0A0h ;  
		.db 0FFh
		.db  00h		; D8B9 compLOAD
		.db  75h ; u
		.db  50h ; P
		.db  32h ; 2
		.db 0FFh
		.db  00h		; D8C1,	compLOAD
		.db  53h ; S
		.db  30h ; 0
		.db  00h
		.db 0FFh

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


calcInjPW:				; CODE XREF: __RESET+177p __RESET+851p
		jsr	sub_C619
		st	y, temp_53	; result of multiplication
		ld	y, #0000h
<<<<<<< HEAD
		cmp	#020, VTA_net	; WOT check
=======
		cmp	#020, VTA_net
>>>>>>> origin/master
		ble	calcInjPW2	; bounce if VTA_net is lower or	equal to 20
		ld	y, #0C2EAh
		jsr	sub_C61C	; enrichment for cold air and cold water

calcInjPW2:				; CODE XREF: calcInjPW+Bj
		mov	y, d		; MSW from multiplication is now in D, so table+5% of whatever was calculated before
		add	d, temp_53
		st	d, temp_51
		ld	a, ADC_pin16	; adc pin 16 (always 0)
		and	a, #02h
		beq	calcInjPW3	; bounce if bit	1 of unk_114 isnt set
		ld	d, #00313
		add	d, temp_51
		st	d, temp_51

calcInjPW3:				; CODE XREF: calcInjPW+1Dj
		ld	d, temp_51
		shl	d
		shl	d
		st	d, InjectPW1	; =unk_51*4
		st	d, InjectPW2	; =unk_51*4
		ei
		ret
; End of function calcInjPW


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_C619:				; CODE XREF: calcInjPWp sub_C634p
		ld	y, #0C2DFh
; End of function sub_C619


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; enrichment for cold air and cold water

sub_C61C:				; CODE XREF: calcInjPW+10p
		jsr	TwoD_rawTHW	; lookup Raw Water Temp, integer return	in Acca, fraction return in AccB
		st	d, temp_51	; gets a base value
		ld	a, rawTHA	; Contains the NOT of air temp reading from ADC, sensor	is tied	to ground on other side
		ld	y, #0C2CCh
		jsr	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB
		mul	a, #08h
		add	d, #03280	; add 5.004%
		ld	y, temp_51
		jsr	MulDbyY		; returns upper	16 bits	in Y, lower 16 bits in D
		ret
; End of function sub_C61C


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_C634:				; CODE XREF: __RESET+17Ap
					; __RESET:main_115p
		bsr	sub_C619
		ld	a, #6Dh
		cmp	#0E4h, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		bcc	loc_C63F
		ld	a, #80h

loc_C63F:				; CODE XREF: sub_C634+7j
		jsr	MulAbyY		; returns upper	16b in AccD
		shr	d
		shr	d
		shr	d
		cmpz	a
		beq	loc_C64A
		ld	b, #0FFh

loc_C64A:				; CODE XREF: sub_C634+12j
		st	b, unk_D2
		ret
; End of function sub_C634


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; called with either 12D or 149	in Y

sub_C64D:				; CODE XREF: __RESET+5FAp __RESET+602p

; FUNCTION CHUNK AT C6EB SIZE 000001AA BYTES

		ld	b, y + 13h
		tbbc	bit7, flags_4C,	loc_C656 ; bounce if running
		and	b, #0F7h
		bra	loc_C6B7
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_C656:				; CODE XREF: sub_C64D+2j
		cmpb	b, #08h
		bne	loc_C687
		ld	a, count_178	; tof increment	rate
		cmp	a, #73h
		bne	loc_C666
		cmp	#0D2h, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		bcc	loc_C66E

loc_C666:				; CODE XREF: sub_C64D+12j
		tbbc	bit0, flags_49,	loc_C6B7 ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		tbbc	bit2, flags_49,	loc_C6B7 ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		or	b, #80h

loc_C66E:				; CODE XREF: sub_C64D+17j
		or	b, #08h
		st	b, y + 13h
		ld	x, #0304h
		tbbc	bit0, flags_40,	loc_C67B ; B3 :	forced timing to 5/10 deg BTDC
		ld	x, #0306h

loc_C67B:				; CODE XREF: sub_C64D+28j
		jsr	sub_C900
		clr	b
		st	a, y + 0Fh	; 13C or 158
		st	a, y + 10h
		shr	d
		shr	d
		st	d, y + 0Dh

loc_C687:				; CODE XREF: sub_C64D+Bj
		ld	b, y + 13h
		ld	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
		and	a, #50h		; bit6 or bit4
		bne	loc_C6B7
		ld	a, y + 01h
		cmp	a, #66h
		bgt	loc_C69D
		cmp	#148, byte_6D	; signed change	in load	from average
		bcc	loc_C6B7
		tbbs	bit2, flags_47,	loc_C6B7 ; bit4: high when hot (but how	hot?)

loc_C69D:				; CODE XREF: sub_C64D+46j
		push	a
		ld	a, word_170	; nonzero and decreasing from cold start
		cmp	a, #0Dh
		pull	a
		bgt	loc_C6B7
		ld	a, flags_44	; bit 1	is igf1	related, bit2 igf2 related
		cmpb	a, #3Fh
		bne	loc_C6B7
		ld	a, word_94
		or	a, word_96
		cmpb	a, #04h
		bne	loc_C6B7
		tbbc	bit3, flags_43,	loc_C6EB ; bit3: AFM bad bit4: rev limiter

loc_C6B7:				; CODE XREF: sub_C64D+7j
					; sub_C64D:loc_C666j ...
		and	b, #0EDh
		st	b, y + 13h
		ld	d, #8000h
		st	d, y + 01h
		st	a, y + 00h
		st	a, y + 03h
		clr	a
		st	a, y + 05h
		st	d, y + 0Bh
		st	d, y + 16h
		ld	a, y + 14h
		and	a, #0FBh
		st	a, y + 14h
		tbbc	bit2, flags_47,	sub_C6E0 ; bit4: high when hot (but how	hot?)
		clrb	bit2, flags_47
		jsr	sub_C6E0
		ld	y, #0149h
		ld	b, y + 13h
		bra	loc_C6B7
; End of function sub_C64D


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_C6E0:				; CODE XREF: sub_C64D+84j sub_C64D+89p ...
		clr	a
		clr	b
		st	d, y + 06h
		st	d, y + 08h
		ld	a, #03h
		st	a, y + 0Ah
		ret
; End of function sub_C6E0

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR sub_C64D

loc_C6EB:				; CODE XREF: sub_C64D+67j
		clrb	bit2, flags_47
		cmpb	b, #02h
		bne	loc_C702
		or	b, #06h
<<<<<<< HEAD
		tbbs	bit0, flags_40,	loc_C6FB ; B3 :	forced timing to 5/10 deg BTDC
=======
		tbbs	bit0, flags_40,	loc_C6FB
>>>>>>> origin/master
		tbbs	bit0, flags_49,	loc_C700 ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		bra	loc_C6FE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_C6FB:				; CODE XREF: sub_C64D+A6j
		tbbs	bit2, flags_49,	loc_C700 ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors

loc_C6FE:				; CODE XREF: sub_C64D+ACj
		and	b, #0FBh

loc_C700:				; CODE XREF: sub_C64D+A9j
					; sub_C64D:loc_C6FBj
		st	b, y + 13h

loc_C702:				; CODE XREF: sub_C64D+A2j
		cmp	#7Eh, byte_6D	; signed change	in load	from average
		bcc	loc_C709
		bsr	sub_C6E0

loc_C709:				; CODE XREF: sub_C64D+B8j
		di
		ld	d, y + 13h
		cmpb	a, #10h
		bne	loc_C712
		ei
		ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_C712:				; CODE XREF: sub_C64D+C1j
		and	a, #0EFh
		or	a, #80h
		st	a, y + 13h
		ei
		ld	d, y + 00h
		st	b, y + 00h
		add	a, b
		rorc	a
		addc	a, #00h
		st	a, y + 03h
		ld	a, y + 14h
		or	a, #04h
		st	a, y + 14h
		ld	a, unk_130
		add	a, unk_14C
		rorc	a
		addc	a, #00h
		st	a, unk_177
		ld	a, unk_D8
		cmpb	a, #0C0h
		beq	loc_C757
		st	a, temp_51
		tbbs	bit0, flags_40,	loc_C74B ; B3 :	forced timing to 5/10 deg BTDC
		and	a, #03h
		cmp	a, #03h
		bcc	loc_C757
		ld	a, temp_51
		inc	a
		bra	loc_C755
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_C74B:				; CODE XREF: sub_C64D+F0j
		and	a, #18h
		cmp	a, #18h
		bcc	loc_C757
		ld	a, temp_51
		add	a, #08h

loc_C755:				; CODE XREF: sub_C64D+FCj
		st	a, unk_D8

loc_C757:				; CODE XREF: sub_C64D+ECj sub_C64D+F7j ...
		ld	b, y + 0Ch
		st	b, temp_52
		ld	a, y + 13h
		cmpb	a, #04h
		beq	loc_C768
		ld	a, y + 0Bh
		st	a, y + 0Ch
		clr	a
		st	a, y + 0Bh

loc_C768:				; CODE XREF: sub_C64D+112j
		ld	x, #0133h
		tbbc	bit0, flags_40,	loc_C771 ; B3 :	forced timing to 5/10 deg BTDC
		ld	x, #014Fh

loc_C771:				; CODE XREF: sub_C64D+11Ej
		cmp	#9Eh, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		bcs	loc_C7B2
		cmp	#0E4h, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		bgt	loc_C7B2
		clr	b

loc_C77C:				; CODE XREF: sub_C64D+13Fj
		push	x
		add	x, b
		ld	a, x + 00h
		pull	x
		cmp	a, #57h
		bcs	loc_C7B2
		cmp	a, #0A9h
		bgt	loc_C7B2
		inc	b
		cmp	b, #03h
		ble	loc_C77C
		sub	a, x + 01h
		bcc	loc_C793
		neg	a

loc_C793:				; CODE XREF: sub_C64D+143j
		cmp	a, #04h
		bgt	loc_C7B2
		ld	a, x + 02h
		sub	a, x + 00h
		bcc	loc_C79E
		neg	a

loc_C79E:				; CODE XREF: sub_C64D+14Ej
		cmp	a, #04h
		bgt	loc_C7B2
		ld	b, y + 0Ah
		cmp	b, #03h
		bcc	loc_C7B2
		cmp	#25h, temp_52
		bcs	loc_C7B2
		cmp	#7Ah, temp_52
		ble	loc_C7B4

loc_C7B2:				; CODE XREF: sub_C64D+127j
					; sub_C64D+12Cj ...
		bra	loc_C7D3
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_C7B4:				; CODE XREF: sub_C64D+163j
		jsr	sub_C8D9	; plays	with word_300, 302
		bne	loc_C7D3
		ld	b, y + 01h
		sub	b, x + 01h
		bcc	loc_C7CA
		cmp	b, #0F1h
		bcc	loc_C7D0
		sub	a, #05h
		bcc	loc_C7D0
		clr	a
		bra	loc_C7D0
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_C7CA:				; CODE XREF: sub_C64D+170j
		cmp	b, #05h
		ble	loc_C7D0
		add	a, #05h

loc_C7D0:				; CODE XREF: sub_C64D+174j
					; sub_C64D+178j ...
		jsr	sub_C8D6

loc_C7D3:				; CODE XREF: sub_C64D:loc_C7B2j
					; sub_C64D+16Aj
		ld	a, y + 0Ah
		bmi	loc_C7DA
		inc	a
		st	a, y + 0Ah

loc_C7DA:				; CODE XREF: sub_C64D+188j
		ld	b, y + 01h
		xch	b, x + 00h
		xch	b, x + 01h
		xch	b, x + 02h
		xch	b, x + 03h
		ld	d, #051Fh
		tbbs	bit0, flags_41,	loc_C826 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
		ld	x, y + 0Dh
		ld	b, y + 13h
		cmpb	b, #04h
		beq	loc_C7F8
		ld	d, #3333h
		sub	d, y + 0Dh
		mov	d, x

loc_C7F8:				; CODE XREF: sub_C64D+1A3j
		ld	b, y + 14h
		cmpb	b, #02h
		bne	loc_C823
		ld	x, #0304h
		tbbc	bit0, flags_40,	loc_C807 ; B3 :	forced timing to 5/10 deg BTDC
		ld	x, #0306h

loc_C807:				; CODE XREF: sub_C64D+1B4j
		jsr	sub_C900
		clr	b
		shr	d
		shr	d
		st	d, temp_51
		ld	a, y + 13h
		cmpb	a, #04h
		beq	loc_C81C
		ld	d, #3333h
		sub	d, temp_51
		bra	loc_C81E
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_C81C:				; CODE XREF: sub_C64D+1C6j
		ld	d, temp_51

loc_C81E:				; CODE XREF: sub_C64D+1CDj
		tbbs	bit4, flags_47,	loc_C84E ; bit4: high when hot (but how	hot?)
		shr	d
		mov	d, x

loc_C823:				; CODE XREF: sub_C64D+1AFj
		mov	x, d
		bra	loc_C84E
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_C826:				; CODE XREF: sub_C64D+19Aj
		cmp	#0Fh, unk_5E	; could	be last	unk_100, or 0
		bgt	loc_C84E
		ld	x, unk_17A
		bmi	loc_C84E
		cmp	x, #55D5h
		bcc	loc_C84E
		push	b
		ld	b, y + 13h
		cmpb	b, #04h
		pull	b
		beq	loc_C843
		ld	x, y + 11h
		bne	loc_C84C
		bra	loc_C84E
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_C843:				; CODE XREF: sub_C64D+1EEj
		ld	x, y + 11h
		bne	loc_C84A
		ld	x, #0262h

loc_C84A:				; CODE XREF: sub_C64D+1F8j
		st	x, y + 11h

loc_C84C:				; CODE XREF: sub_C64D+1F2j
		clr	a
		clr	b

loc_C84E:				; CODE XREF: sub_C64D:loc_C81Ej
					; sub_C64D+1D7j ...
		push	d
		bsr	sub_C895
		pull	d
		shr	d
		push	b
		ld	b, y + 13h
		cmpb	b, #04h
		pull	b
		bne	loc_C861
		neg	a
		neg	b
		subc	a, #00h
		bra	loc_C861

loc_C861:				; CODE XREF: sub_C64D+20Cj
		add	d, y + 01h
		st	a, temp_51
		ld	b, unk_175
		clr	a
		add	b, #80h
		add	b, temp_51
		addc	a, #00h
		add	b, word_98	; 128 for entire superrun
		addc	a, #00h
		jsr	SaturateD16b
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.dw 01FFh
		.dw 0100h
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		add	b, y + 04h
		rorc	b
		st	b, y + 04h
		ld	a, y + 16h
		st	a, y + 17h
		clr	a
		st	a, y + 16h
		ld	b, #01h
		ld	y, #01D0h
		tbbc	bit0, flags_40,	loc_C891 ; B3 :	forced timing to 5/10 deg BTDC
		ld	y, #01D4h

loc_C891:				; CODE XREF: sub_C64D+23Ej
		jsr	satcount	; increment B bytes of ram by 1	starting from Y, saturates at FF
		ret
; END OF FUNCTION CHUNK	FOR sub_C64D

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_C895:				; CODE XREF: sub_C64D+202p
					; __RESET+F1Cp
		shra	a
		rorc	b
		push	b
		ld	b, y + 13h
		cmpb	b, #04h
		pull	b
		beq	loc_C8A3
		neg	a
		neg	b
		subc	a, #00h

loc_C8A3:				; CODE XREF: sub_C895+8j
		st	d, temp_51
		ld	d, y + 01h
		shr	d
		add	d, #4000h
		add	d, temp_51
		jsr	SaturateD16b
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.dw 0B333h
		.dw 4CCDh
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		sub	d, #4000h
		shl	d
		st	d, y + 01h
		ret
; End of function sub_C895


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; feels	like it	acounts	for oxygen sensor correction

sub_C8BB:				; CODE XREF: ROM:CB2Dp	ROM:CB34p ...
		add	a, word_98	; 128 for entire superrun
		rorc	a
		rorc	b
		shr	d
		jsr	SaturateD16b
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.dw 599Ah
		.dw 2666h
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		st	d, temp_51
		clr	b
		ld	a, unk_175
		shra	a
		rorc	b
		shra	a
		rorc	b
		add	d, temp_51
		add	a, #40h
		ret
; End of function sub_C8BB


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_C8D6:				; CODE XREF: sub_C64D:loc_C7D0p
		push	x
		bra	loc_C8E9
; End of function sub_C8D6


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; plays	with word_300, 302

sub_C8D9:				; CODE XREF: sub_C64D:loc_C7B4p
					; __RESET:main_29p
		push	x
		ld	d, word_300
		tbbc	bit0, flags_40,	loc_C8E3 ; B3 :	forced timing to 5/10 deg BTDC
		ld	d, word_302

loc_C8E3:				; CODE XREF: sub_C8D9+4j
		xor	b, #0FFh
		cmp	a, b
		beq	loc_C8E9
		clr	a

loc_C8E9:				; CODE XREF: sub_C8D6+1j sub_C8D9+Dj
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  66h ; f
		.db  00h
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		mov	a, b
		xor	b, #0FFh
		ld	x, #0300h
		tbbc	bit0, flags_40,	loc_C8FA ; B3 :	forced timing to 5/10 deg BTDC
		ld	x, #0302h

loc_C8FA:				; CODE XREF: sub_C8D9+1Bj
		st	d, x + 00h
		cmp	d, x + 00h
		pull	x
		ret
; End of function sub_C8D9


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_C900:				; CODE XREF: sub_C64D:loc_C67Bp
					; sub_C64D:loc_C807p
		ld	d, x + 00h
		xor	b, #0FFh
		cmp	a, b
		bne	loc_C910
; End of function sub_C900


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_C907:				; CODE XREF: __RESET:main_306p
		push	x
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0A4h ; ¤
		.db  29h ; )
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		pull	x
		bcc	loc_C912

loc_C910:				; CODE XREF: sub_C900+5j
		ld	a, #66h

loc_C912:				; CODE XREF: sub_C907+7j
		mov	a, b
		xor	b, #0FFh
		st	d, x + 00h
		ret
; End of function sub_C907

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SUB_C918:				; CODE XREF: __RESET+FF7p
		tbbs	bit7, flags_45,	loc_C952 ; bounce if TE1 shorted to gnd
		tbbc	bit3, flags_4B,	loc_C946
		clrb	bit3, flags_4B
		tbbs	bit6, flags_4D,	loc_C926
		tbbc	bit7, flags_4D,	loc_C946

loc_C926:				; CODE XREF: ROM:C920j
		clrb	bit7, flags_4D
		ld	d, flags_4E	; bit1 is igf1 related,	bit2 igf2 related
		and	a, #0EFh	; clear	bit 4 of unk_4e
		and	b, #60h
		st	d, flags_4E	; bit1 is igf1 related,	bit2 igf2 related
		ld	a, flags_146
		ld	b, flags_162
		and	a, #00h
		and	b, #00h
		st	a, flags_146	; clear	flags_146
		st	b, flags_162	; clear	flags_162
<<<<<<< HEAD
		ld	a, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1
=======
		ld	a, flags_7D
>>>>>>> origin/master
		and	a, #1Fh
		st	a, flags_7D	; clear	bits 7..5

loc_C946:				; CODE XREF: ROM:C91Bj	ROM:C923j
		ld	a, flags_4F
		and	a, #7Fh
		st	a, flags_4F
		ld	a, flags_4D
		and	a, #81h
		st	a, flags_4D

loc_C952:				; CODE XREF: ROM:SUB_C918j
		tbbs	bit0, flags_45,	loc_C959 ; bounce if starting
		clrb	bit4, flags_4C
		clr	count_BE	; increments at	E478

loc_C959:				; CODE XREF: ROM:loc_C952j
		cmp	#1Fh, count_BE	; increments at	E478
		bcs	loc_C96A
		tbbc	bit4, flags_4B,	loc_C96A
		ld	a, NEcounts
		beq	loc_C968
		tbbs	bit4, flags_4C,	loc_C96A ; bit 7 set when not running (300 to 400 RPM gap)

loc_C968:				; CODE XREF: ROM:C963j
		setb	bit0, flags_4E

loc_C96A:				; CODE XREF: ROM:C95Cj	ROM:C95Ej ...
<<<<<<< HEAD
		ld	b, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1
=======
		ld	b, flags_7D
>>>>>>> origin/master
		tbbc	bit6, flags_49,	loc_C981 ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		ld	#0FFh, count_CA	; incremented at E643
		ld	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
		and	a, #0FAh	; clear	flags_A2 bits 0+2
		st	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
		clr	a
		st	a, count_1C0	; incremented at F580 (oxy L1?)
		st	a, count_1C1	; incremented at F580 (oxy R1?)
		bra	loc_C9C9
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_C981:				; CODE XREF: ROM:C96Cj
		ld	a, flags_50	; could	be bits	for 6336 output	chip, B0 probably HTR L+R1, B1 probably	HTR L+R2
		cmpb	a, #01h
		bne	loc_C99B
<<<<<<< HEAD
		ld	a, flags_1AA	; check	htr L1
		cmpb	a, #01h		; heater L1 high when not connected or on
=======
		ld	a, flags_1AA	; IC302	input bits B3~0	are NOT	of oxy heater pin voltages
		cmpb	a, #01h
>>>>>>> origin/master
		bne	loc_C992
		and	b, #0FEh
		bra	loc_C99B
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_C992:				; CODE XREF: ROM:C98Cj
		ld	a, count_1C0	; incremented at F580 (oxy L1?)
		cmp	a, #3Dh
		ble	loc_C9A5
		or	b, #01h

loc_C99B:				; CODE XREF: ROM:C985j	ROM:C990j
		ld	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
		or	a, #01h		; set bit1 of flags_A2
		st	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
		clr	a
		st	a, count_1C0	; incremented at F580 (oxy L1?)

loc_C9A5:				; CODE XREF: ROM:C997j
		ld	a, flags_50	; could	be bits	for 6336 output	chip, B0 probably HTR L+R1, B1 probably	HTR L+R2
		cmpb	a, #01h
		bne	loc_C9BF
<<<<<<< HEAD
		ld	a, flags_1AA	; check	htr R1
		cmpb	a, #04h		; heater R1 high when not connected or on
=======
		ld	a, flags_1AA	; IC302	input bits B3~0	are NOT	of oxy heater pin voltages
		cmpb	a, #04h
>>>>>>> origin/master
		bne	loc_C9B6
		and	b, #0FBh
		bra	loc_C9BF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_C9B6:				; CODE XREF: ROM:C9B0j
		ld	a, count_1C1	; incremented at F580 (oxy R1?)
		cmp	a, #3Dh
		ble	loc_C9C9
		or	b, #04h

loc_C9BF:				; CODE XREF: ROM:C9A9j	ROM:C9B4j
		ld	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
		or	a, #04h		; set bit2 flags_A2
		st	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
		clr	a
		st	a, count_1C1	; incremented at F580 (oxy R1?)

loc_C9C9:				; CODE XREF: ROM:C97Fj	ROM:C9BBj
<<<<<<< HEAD
		st	b, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1
		ld	b, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1
=======
		st	b, flags_7D
		ld	b, flags_7D
>>>>>>> origin/master
		tbbc	bit6, flags_49,	loc_C9E2 ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		ld	#0FFh, count_CB	; incremented at E643
		ld	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
		and	a, #0F5h	; clear	bits 3+1 of flags_A2
		st	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
		clr	a
		st	a, count_1C2	; incremented at F580 (oxy L2?)
		st	a, count_1C3	; incremented at F580 (oxy R2?)
		bra	loc_CA2A
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_C9E2:				; CODE XREF: ROM:C9CDj
		ld	a, flags_50	; could	be bits	for 6336 output	chip, B0 probably HTR L+R1, B1 probably	HTR L+R2
		cmpb	a, #02h
		bne	loc_C9FC
<<<<<<< HEAD
		ld	a, flags_1AA	; check	htr L2
		cmpb	a, #02h		; heater L2 high when not connected or on
=======
		ld	a, flags_1AA	; IC302	input bits B3~0	are NOT	of oxy heater pin voltages
		cmpb	a, #02h
>>>>>>> origin/master
		bne	loc_C9F3
		and	b, #0FDh
		bra	loc_C9FC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_C9F3:				; CODE XREF: ROM:C9EDj
		ld	a, count_1C2	; incremented at F580 (oxy L2?)
		cmp	a, #3Dh
		ble	loc_CA06
		or	b, #02h

loc_C9FC:				; CODE XREF: ROM:C9E6j	ROM:C9F1j
		ld	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
		or	a, #02h		; set bit1 of flags_A2
		st	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
		clr	a
		st	a, count_1C2	; incremented at F580 (oxy L2?)

loc_CA06:				; CODE XREF: ROM:C9F8j
		ld	a, flags_50	; could	be bits	for 6336 output	chip, B0 probably HTR L+R1, B1 probably	HTR L+R2
		cmpb	a, #02h
		bne	loc_CA20
<<<<<<< HEAD
		ld	a, flags_1AA	; check	htr R2
		cmpb	a, #08h		; heater R2 high when not connected or on
=======
		ld	a, flags_1AA	; IC302	input bits B3~0	are NOT	of oxy heater pin voltages
		cmpb	a, #08h
>>>>>>> origin/master
		bne	loc_CA17
		and	b, #0F7h
		bra	loc_CA20
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CA17:				; CODE XREF: ROM:CA11j
		ld	a, count_1C3	; incremented at F580 (oxy R2?)
		cmp	a, #3Dh
		ble	loc_CA2A
		or	b, #08h

loc_CA20:				; CODE XREF: ROM:CA0Aj	ROM:CA15j
		ld	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
		or	a, #08h		; set bit3 of flags_A2
		st	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
		clr	a
		st	a, count_1C3	; incremented at F580 (oxy R2?)

loc_CA2A:				; CODE XREF: ROM:C9E0j	ROM:CA1Cj
		st	b, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1
		ld	a, count_1D3	; tof increment	rate
		cmp	a, #4Ch
		ble	loc_CA6D
		clr	b
		st	b, count_1D3	; tof increment	rate
		ld	a, word_8A
		or	a, word_8C
		and	a, #7Ch
		bne	loc_CA5D
		ld	a, unk_142
		cmpb	a, #40h
		beq	loc_CA4E
		ld	a, flags_146
		or	a, #50h
		st	a, flags_146

loc_CA4E:				; CODE XREF: ROM:CA44j
		ld	a, unk_15E
		cmpb	a, #40h
		beq	loc_CA5D
		ld	a, flags_162
		or	a, #50h
		st	a, flags_162

loc_CA5D:				; CODE XREF: ROM:CA3Dj	ROM:CA53j
		ld	a, unk_142
		and	a, #0BFh
		st	a, unk_142
		ld	a, unk_15E
		and	a, #0BFh
		st	a, unk_15E

loc_CA6D:				; CODE XREF: ROM:CA31j
		clrb	bit5, flags_4B
		tbbc	bit6, flags_4B,	loc_CAC9
		cmp	#82h, unk_5E	; could	be last	unk_100, or 0
		bcc	loc_CAC9
		ld	a, flags_4E	; bit1 is igf1 related,	bit2 igf2 related
		and	a, #06h
		bne	loc_CAC9
		ld	a, flags_4F

loc_CA7F:
		and	a, #07h
		bne	loc_CAC9
		ld	a, word_86
		and	a, #08h
		bne	loc_CAC9
		ld	a, word_90
		or	a, word_92
		and	a, #01h
		bne	loc_CAC9
		ld	a, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1
		and	a, #1Fh
		bne	loc_CAC9
		ld	a, unk_140	; bits 5,0 oxl2	related
		and	a, unk_15C	; bits 5,0 oxr2	related
		and	a, #02h
		beq	loc_CAC9
		ld	d, unk_17A
		cmp	d, #55D5h
		bcs	loc_CAC9
		ld	b, unk_1D8
		cmp	b, #3Bh
		ble	loc_CAC9
		cmp	#5Ah, ATM_press	; adc pin 17 - PCM atmospheric pressure	sensor,	debiased and scaled
		bcs	loc_CAC9
		cmp	#0D2h, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		bcs	loc_CAC9
		cmp	#0ECh, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		bgt	loc_CAC9
		ld	a, word_170	; nonzero and decreasing from cold start
		or	a, word_172	; nonzero and rapidly decreasing after start, larger peak from cold start
		bne	loc_CAC9
		setb	bit5, flags_4B

loc_CAC9:				; CODE XREF: ROM:CA6Fj	ROM:CA75j ...
		clrb	bit0, flags_40
		ld	a, unk_12E
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0E5h ; å
		.db  1Ah
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		bcs	loc_CADF
		ld	a, unk_14A
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0E5h ; å
		.db  1Ah
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		bcc	loc_CAF1

loc_CADF:				; CODE XREF: ROM:CAD3j
		setb	bit0, flags_40
		ld	a, unk_141
		or	a, #04h
		st	a, unk_141
		ld	a, unk_15D
		or	a, #04h
		st	a, unk_15D

loc_CAF1:				; CODE XREF: ROM:CADDj
		ld	a, unk_141
		and	a, unk_15D
		and	a, #04h
		beq	loc_CB03
		cmp	#18h, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
		bcs	loc_CB03
		tbbs	bit5, flags_4B,	loc_CB1C

loc_CB03:				; CODE XREF: ROM:CAF9j	ROM:CAFEj
		ld	a, #0FFh
		ld	b, word_94
		cmpb	b, #28h
		bne	loc_CB0C
		clr	a

loc_CB0C:				; CODE XREF: ROM:CB09j
		st	a, unk_1CE
		ld	b, word_90
		cmpb	b, #78h
		bne	loc_CB16
		clr	a

loc_CB16:				; CODE XREF: ROM:CB13j
		st	a, unk_1CF
		jmp	loc_CC1F
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CB1C:				; CODE XREF: ROM:CB00j
		ld	a, unk_130
		ld	b, unk_14C
		tbbc	bit0, flags_40,	loc_CB2B ; B3 :	forced timing to 5/10 deg BTDC
		ld	a, unk_12E
		ld	b, unk_14A

loc_CB2B:				; CODE XREF: ROM:CB22j
		push	b
		clr	b
		jsr	sub_C8BB	; feels	like it	acounts	for oxygen sensor correction
		pull	b
		push	a
		mov	b, a
		clr	b
		jsr	sub_C8BB	; feels	like it	acounts	for oxygen sensor correction
		pull	b
		st	a, temp_52
		st	b, temp_51
		sub	a, b
		bcc	loc_CB40
		neg	a

loc_CB40:				; CODE XREF: ROM:CB3Dj
		clrb	bit0, flags_40
		cmp	a, #0Dh
		bcc	loc_CB5A
		ld	a, unk_1CE
		beq	loc_CB4C
		dec	a

loc_CB4C:				; CODE XREF: ROM:CB49j
		st	a, unk_1CE
		ld	b, unk_1CF
		beq	loc_CB55
		dec	b

loc_CB55:				; CODE XREF: ROM:CB52j
		st	b, unk_1CF
		bra	loc_CB75
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CB5A:				; CODE XREF: ROM:CB44j
		ld	a, unk_1CE
		inc	a
		beq	loc_CB63
		st	a, unk_1CE

loc_CB63:				; CODE XREF: ROM:CB5Ej
		ld	b, unk_1CF
		ld	a, unk_142
		and	a, #80h
		beq	loc_CB75
		setb	bit0, flags_40
		inc	b
		beq	loc_CB75
		st	b, unk_1CF

loc_CB75:				; CODE XREF: ROM:CB58j	ROM:CB6Bj ...
		ld	a, unk_1CE
		bne	loc_CB9B
		ld	x, #0D253h
		ld	y, #012Dh
		jsr	sub_D222
		ld	x, #0D253h
		ld	y, #0149h
		jsr	sub_D222
		ld	a, unk_142
		and	a, #7Fh
		st	a, unk_142
		clr	a
		st	a, unk_1CF
		jmp	loc_CC1F
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CB9B:				; CODE XREF: ROM:CB78j
		ld	a, temp_51
		sub	a, #80h
		bcc	loc_CBA2
		neg	a

loc_CBA2:				; CODE XREF: ROM:CB9Fj
		ld	b, temp_52
		sub	b, #80h
		bcc	loc_CBA9
		neg	b

loc_CBA9:				; CODE XREF: ROM:CBA6j
		clr	temp_53
		cmp	a, b
		bcc	loc_CBB4
		inc	temp_53
		ld	a, temp_52
		st	a, temp_51

loc_CBB4:				; CODE XREF: ROM:CBACj
		ld	a, unk_1CE
		cmp	a, #99h
		bne	loc_CBEB
		tbbs	bit3, flags_4B,	loc_CBD7
		ld	a, unk_142
		and	a, #80h
		bne	loc_CBEB
		ld	a, flags_146
		or	a, #28h
		st	a, flags_146
		ld	a, flags_162
		or	a, #28h
		st	a, flags_162
		bra	loc_CC1F
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CBD7:				; CODE XREF: ROM:CBBBj
		setb	bit6, flags_4D
		ld	a, flags_147
		or	a, #28h
		st	a, flags_147
		ld	a, flags_163
		or	a, #28h
		st	a, flags_163
		bra	loc_CBF5
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CBEB:				; CODE XREF: ROM:CBB9j	ROM:CBC3j
		ld	a, unk_1CF
		cmp	a, #99h
		bne	loc_CC1F
		tbbc	bit0, flags_40,	loc_CC1F ; B3 :	forced timing to 5/10 deg BTDC

loc_CBF5:				; CODE XREF: ROM:CBE9j
		ld	a, temp_51
		ld	b, flags_146
		cmp	#00h, temp_53
		beq	loc_CC02
		ld	b, flags_162

loc_CC02:				; CODE XREF: ROM:CBFDj
		cmp	a, #8Dh
		bcc	loc_CC10
		cmp	a, #73h
		bgt	loc_CC0E
		or	b, #20h
		bra	loc_CC12
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CC0E:				; CODE XREF: ROM:CC08j
		or	b, #20h

loc_CC10:				; CODE XREF: ROM:CC04j
		or	b, #08h

loc_CC12:				; CODE XREF: ROM:CC0Cj
		cmp	#00h, temp_53
		bne	loc_CC1C
		st	b, flags_146
		bra	loc_CC1F
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CC1C:				; CODE XREF: ROM:CC15j
		st	b, flags_162

loc_CC1F:				; CODE XREF: ROM:CB19j	ROM:CB98j ...
		clr	a
		tbbc	bit5, flags_4B,	loc_CC30
		tbbc	bit0, flags_41,	loc_CC30 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
		cmp	#02h, unk_5E	; could	be last	unk_100, or 0
		bcc	loc_CC30
		cmp	#019, RPM	; 950RPM
		bcs	loc_CC3A

loc_CC30:				; CODE XREF: ROM:CC20j	ROM:CC23j ...
		st	a, count_C7	; increments at	E478
		st	a, count_1D0
		st	a, count_1D4
		bra	loc_CC53
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CC3A:				; CODE XREF: ROM:CC2Ej
		cmp	#3Eh, count_C7	; increments at	E478
		bcs	loc_CC53
		clr	count_C7	; increments at	E478
		ld	x, #01D0h
		ld	y, #012Dh
		jsr	sub_D159
		ld	x, #01D4h
		ld	y, #0149h
		jsr	sub_D159

loc_CC53:				; CODE XREF: ROM:CC38j	ROM:CC3Dj
		cmp	#82h, unk_5E	; could	be last	unk_100, or 0
		bcc	loc_CC7D
		ld	a, word_8E
		and	a, #10h
		bne	loc_CC7D
		cmp	#030, RPM	; 1500RPM
		bcs	loc_CC7D
		ld	d, word_170	; nonzero and decreasing from cold start
		cmp	d, #0CCDh
		bcc	loc_CC7D
		ld	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
		and	a, #50h		; test flags_A2	bit4 bit6
		bne	loc_CC7D
		ld	a, flags_44	; bit 1	is igf1	related, bit2 igf2 related
		and	a, #3Fh
		bne	loc_CC7D
		tbbs	bit3, flags_43,	loc_CC7D ; bit3: AFM bad bit4: rev limiter
		tbbc	bit3, flags_4E,	loc_CC83 ; bit1	is igf1	related, bit2 igf2 related

loc_CC7D:				; CODE XREF: ROM:CC56j	ROM:CC5Cj ...
		clr	count_D0	; incremented at E7A9
		clr	count_D1	; incremented at E7A9
		bra	loc_CCBD
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CC83:				; CODE XREF: ROM:CC7Aj
		tbbs	bit0, flags_49,	loc_CCA0 ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		cmp	#2Dh, count_D0	; incremented at E7A9
		bcs	loc_CCA0
		ld	a, flags_146
		or	a, #04h
		st	a, flags_146
		tbbc	bit3, flags_4B,	loc_CCA0
		setb	bit6, flags_4D
		ld	a, flags_147
		or	a, #04h
		st	a, flags_147

loc_CCA0:				; CODE XREF: ROM:loc_CC83j ROM:CC89j ...
		tbbs	bit2, flags_49,	loc_CCBD ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		cmp	#045, count_D1	; incremented at E7A9
		bcs	loc_CCBD
		ld	a, flags_162
		or	a, #04h
		st	a, flags_162
		tbbc	bit3, flags_4B,	loc_CCBD
		setb	bit6, flags_4D
		ld	a, flags_163
		or	a, #04h
		st	a, flags_163

loc_CCBD:				; CODE XREF: ROM:CC81j	ROM:loc_CCA0j ...
		tbbc	bit0, flags_49,	loc_CCCB ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		ld	x, #0D252h
		ld	y, #012Dh
		jsr	sub_D222
		clr	count_D0	; incremented at E7A9

loc_CCCB:				; CODE XREF: ROM:loc_CCBDj
		tbbc	bit2, flags_49,	loc_CCD9 ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		ld	x, #0D252h
		ld	y, #0149h
		jsr	sub_D222
		clr	count_D1	; incremented at E7A9

loc_CCD9:				; CODE XREF: ROM:loc_CCCBj
		ld	a, word_86
		and	a, #08h
		bne	loc_CD09
		ld	a, word_88
		and	a, #01h
		bne	loc_CD09
		ld	a, word_8A
		or	a, word_8C
		or	a, word_94
		or	a, word_96
		and	a, #7Ch
		bne	loc_CD09
		ld	a, word_8E
		and	a, #10h
		bne	loc_CD09
		cmp	#036, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
		bcs	loc_CD09	; bounce if low	load
		tbbc	bit2, flags_4B,	loc_CD09
		cmp	#030, RPM	; 1500RPM
		bcs	loc_CD09	; bounce if low	rpm
		cmp	#64h, unk_5E	; could	be last	unk_100, or 0
		bcs	loc_CD0F

loc_CD09:				; CODE XREF: ROM:CCDDj	ROM:CCE3j ...
		clr	a
		st	a, count_1BC	; clear
		bra	loc_CD6F	; clear	and store
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CD0F:				; CODE XREF: ROM:CD07j
		tbbc	bit1, flags_49,	loc_CD3D ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		ld	d, count_143	; if carry is set OXL1 voltage was between .35 and .7
		cmp	b, #003
		ble	loc_CD3D
		cmp	b, #154
		bcc	loc_CD3D
		cmp	a, #154
		bcc	loc_CD3D
		ld	a, count_1BC
		cmp	a, #030
		bcs	loc_CD3E
		ld	a, flags_146
		or	a, #01h
		st	a, flags_146
		tbbc	bit3, flags_4B,	loc_CD3D
		setb	bit6, flags_4D
		ld	a, flags_147
		or	a, #01h
		st	a, flags_147

loc_CD3D:				; CODE XREF: ROM:loc_CD0Fj ROM:CD17j ...
		clr	a

loc_CD3E:				; CODE XREF: ROM:CD26j
		st	a, count_1BC
		tbbc	bit3, flags_49,	loc_CD6F ; clear and store
		ld	d, count_15F	; if carry is set OXR1 voltage was between .35 and .7
		cmp	b, #003
		ble	loc_CD6F	; clear	and store
		cmp	b, #154
		bcc	loc_CD6F	; clear	and store
		cmp	a, #154
		bcc	loc_CD6F	; clear	and store
		ld	a, count_1BE
		cmp	a, #030
		bcs	loc_CD70	; store
		ld	a, flags_162
		or	a, #01h
		st	a, flags_162
		tbbc	bit3, flags_4B,	loc_CD6F ; clear and store
		setb	bit6, flags_4D
		ld	a, flags_163
		or	a, #01h
		st	a, flags_163

loc_CD6F:				; CODE XREF: ROM:CD0Dj	ROM:CD41j ...
		clr	a		; clear	and store

loc_CD70:				; CODE XREF: ROM:CD58j
		st	a, count_1BE	; store
		clrb	bit0, flags_40
		cmp	#153, count_C4	; increments at	E478
		bcs	loc_CD7E
		clr	count_C4	; increments at	E478
		setb	bit0, flags_40

loc_CD7E:				; CODE XREF: ROM:CD78j
		ld	b, unk_1BD
		ld	x, #0D1EBh	; bitmasks 0..3
		ld	y, #012Dh
		jsr	sub_D1BC
		st	b, unk_1BD
		ld	b, unk_1BF
		ld	x, #0D1EDh
		ld	y, #0149h
		jsr	sub_D1BC
		st	b, unk_1BF
		ld	b, word_86
		and	b, #08h
		bne	loc_CDC5
		ld	b, word_88
		and	b, #01h
		bne	loc_CDC5
		ld	b, word_8A
		or	b, word_8C
		and	b, #7Dh
		bne	loc_CDC5
		ld	b, word_8E
		and	b, #1Fh
		bne	loc_CDC5
		ld	b, flags_147
		or	b, flags_163
		and	b, #7Dh
		bne	loc_CDC5
		cmp	#78h, unk_7E
		bcc	loc_CDCB

loc_CDC5:				; CODE XREF: ROM:CDA0j	ROM:CDA6j ...
		clr	a
		clr	b
		st	d, count_C2	; increments at	E478
		bra	loc_CDE9
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CDCB:				; CODE XREF: ROM:CDC3j
		ld	a, count_C2	; increments at	E478
		ld	b, unk_140	; bits 5,0 oxl2	related
		ld	y, #012Dh
		clrb	bit0, flags_40
		jsr	sub_D1EF
		st	a, count_C2	; increments at	E478
		ld	a, count_C3	; increments at	E478
		ld	b, unk_15C	; bits 5,0 oxr2	related
		ld	y, #0149h
		setb	bit0, flags_40
		jsr	sub_D1EF
		st	a, count_C3	; increments at	E478

loc_CDE9:				; CODE XREF: ROM:CDC9j
		ld	a, unk_140	; bits 5,0 oxl2	related
		and	a, #01h
		beq	loc_CDF9
		ld	x, #0D251h
		ld	y, #012Dh
		jsr	sub_D222

loc_CDF9:				; CODE XREF: ROM:CDEEj
		ld	a, unk_15C	; bits 5,0 oxr2	related
		and	a, #01h
		beq	loc_CE09
		ld	x, #0D251h
		ld	y, #0149h
		jsr	sub_D222

loc_CE09:				; CODE XREF: ROM:CDFEj
		ld	b, unk_5E	; could	be last	unk_100, or 0
		beq	loc_CE1F	; 2800RPM
		ld	a, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1
		and	a, #0EFh
		st	a, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1

loc_CE13:				; CODE XREF: ROM:CE22j	ROM:CE24j ...
		clr	a
		st	a, unk_1B5
		cmp	b, #05h
		bcs	loc_CE41
		clrb	bit3, flags_4D
		bra	loc_CE41
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CE1F:				; CODE XREF: ROM:CE0Bj
		cmp	#056, RPM	; 2800RPM
		bcs	loc_CE13
<<<<<<< HEAD
		tbbs	bit5, flags_45,	loc_CE13 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbs	bit5, flags_45,	loc_CE13 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		ld	a, unk_109
		and	a, #02h
		bne	loc_CE13
		ld	a, unk_1B5
		inc	a
		beq	loc_CE37
		st	a, unk_1B5

loc_CE37:				; CODE XREF: ROM:CE32j
		cmp	a, #7Ah
		bcs	loc_CE41
		ld	a, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1
		or	a, #10h
		st	a, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1

loc_CE41:				; CODE XREF: ROM:CE19j	ROM:CE1Dj ...
		ld	a, unk_1BB
		inc	a
		bne	loc_CE48
		dec	a

loc_CE48:				; CODE XREF: ROM:CE45j
		st	a, unk_1BB
		tbbc	bit3, flags_4B,	loc_CE6C
		tbbc	bit6, flags_45,	loc_CE6C ; bounce if TE2 open
		tbbs	bit0, flags_45,	loc_CE6C ; bounce if starting
<<<<<<< HEAD
		tbbs	bit7, flags_4C,	loc_CE6C ; bounce if not running
=======
		tbbs	bit7, flags_4C,	loc_CE6C ; bit 7 demands a sampling of the oxygen sensors
>>>>>>> origin/master
		cmp	#00h, NEcounts
		beq	loc_CE6C
		cmp	a, #2Eh
		bcs	loc_CE63
		tbbc	bit0, flags_41,	loc_CE69 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend

loc_CE63:				; CODE XREF: ROM:CE5Ej
<<<<<<< HEAD
		tbbs	bit1, flags_45,	loc_CE69 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
		tbbs	bit5, flags_45,	loc_CE6C ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbs	bit1, flags_45,	loc_CE69 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		tbbs	bit5, flags_45,	loc_CE6C ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master

loc_CE69:				; CODE XREF: ROM:CE60j	ROM:loc_CE63j
		setb	bit5, flags_4D
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  8Ch ; Œ		; cmp x
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CE6C:				; CODE XREF: ROM:CE4Bj	ROM:CE4Ej ...
		clrb	bit5, flags_4D
		tbbs	bit0, flags_45,	loc_CE89 ; bounce if starting
		ld	a, unk_1C4
		ld	b, unk_140	; bits 5,0 oxl2	related
		cmpb	b, #01h
		beq	loc_CE7D
		and	a, #0FEh

loc_CE7D:				; CODE XREF: ROM:CE79j
		ld	b, unk_15C	; bits 5,0 oxr2	related
		cmpb	b, #01h
		beq	loc_CE86
		and	a, #0FDh

loc_CE86:				; CODE XREF: ROM:CE82j
		st	a, unk_1C4

loc_CE89:				; CODE XREF: ROM:CE6Ej
		ld	a, flags_4D
		push	a
		ld	d, flags_4E	; bit1 is igf1 related,	bit2 igf2 related
		tbbc	bit5, RAMST, loc_CEA7 ;	Built-in RAM status
		cmp	#122, count_AE	; incremented at F47D
		ble	loc_CEA7
		tbbc	bit7, RAMST, loc_CEA7 ;	Built-in RAM status
		cmp	#049, count_AF	; incremented at F47D
		ble	loc_CEA7
		cmp	#122, count_AD	; cleared when below 8V	input, incremented at F47D
		bgt	loc_CEB8
		and	a, #0Fh
		bra	loc_CEC3
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CEA7:				; CODE XREF: ROM:CE8Ej	ROM:CE94j ...
		clr	a
		st	a, unk_1B6
		st	a, unk_1B7
		clrb	bit1, flags_4C
		clrb	bit1, flags_44
		clrb	bit2, flags_44
		clrb	bit0, flags_4C
		bra	loc_CEC3
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CEB8:				; CODE XREF: ROM:CEA1j
		push	a
		ld	a, count_1BA	; incremented at F49C
		cmp	a, #7Ah
		pull	a
		bgt	loc_CEDA
		and	a, #0Fh

loc_CEC3:				; CODE XREF: ROM:CEA5j	ROM:CEB6j
		push	a
		clr	a
		clr	b
		st	a, flags_146
		st	a, flags_162
		st	a, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1
		pull	a
		st	d, flags_4E	; bit1 is igf1 related,	bit2 igf2 related
		mov	s, x
		xch	a, x + 00h
		and	a, #18h
		st	a, flags_4D
		xch	a, x + 00h

loc_CEDA:				; CODE XREF: ROM:CEBFj
		st	d, temp_52
		ld	a, flags_146
		ld	b, flags_162
		st	a, temp_54
		st	b, temp_55
		ld	a, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1
		st	a, temp_56
		pull	a
		st	a, temp_51
		cmpb	a, #40h
		beq	loc_CEF3
		setb	bit7, flags_4D

loc_CEF3:				; CODE XREF: ROM:CEEFj
		ld	b, temp_55
		and	b, flags_163
		and	b, #0FFh
		st	b, unk_57
		ld	x, #008Ch
		bsr	sub_CF4C
		ld	b, unk_57
		ld	x, #0092h
		bsr	sub_CF4C
		ld	b, temp_54
		and	b, flags_147
		and	b, #0FFh
		st	b, unk_57
		ld	x, #008Ah
		bsr	sub_CF4C
		ld	b, unk_57
		ld	x, #0090h
		bsr	sub_CF4C
		ld	b, temp_52
		and	b, #0AFh
		ld	x, #0086h
		bsr	sub_CF4C
		ld	b, temp_53
		and	b, #0FFh
		ld	x, #0088h
		bsr	sub_CF4C
		ld	b, temp_56
		and	b, #1Fh
		ld	x, #008Eh
		bsr	sub_CF4C
		ld	b, temp_54
		and	b, #0FFh
		ld	x, #0094h
		bsr	sub_CF4C
		ld	b, temp_55
		and	b, #0FFh
		ld	x, #0096h
		bsr	sub_CF4C
		bra	loc_CF57

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_CF4C:				; CODE XREF: ROM:CEFFp	ROM:CF06p ...
		or	b, x + 00h
; End of function sub_CF4C


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_CF4E:				; CODE XREF: sub_D222+1Fp sub_D222+2Ap ...
		ld	a, x + 00h
		sub	a, b
		add	a, x + 01h
		xch	a, b
		st	d, x + 00h
		ret
; End of function sub_CF4E

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CF57:				; CODE XREF: ROM:CF4Aj
		clr	a
		jsr	sub_D0B3
		ld	b, flags_1C6	; written at end of main loop; B3 /NSW (/STA), b2 , b1 IDL1, b0	STA
		and	b, #7Fh
		cmpz	a
		beq	loc_CF65
		or	b, #80h

loc_CF65:				; CODE XREF: ROM:CF61j
		st	b, flags_1C6	; written at end of main loop; B3 /NSW (/STA), b2 , b1 IDL1, b0	STA
		ld	x, #0D2ABh
		ld	y, #0D2ABh
<<<<<<< HEAD
		tbbc	bit6, flags_45,	loc_CF96 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
		tbbc	bit0, flags_41,	loc_CF88 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
		ld	b, flags_1C6	; written at end of main loop; B3 /NSW (/STA), b2 , b1 IDL1, b0	STA
=======
		tbbc	bit6, flags_45,	loc_CF96 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		tbbc	bit0, flags_41,	loc_CF88 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
		ld	b, unk_1C6
>>>>>>> origin/master
		bmi	loc_CFBE
		ld	b, unk_1C4
		and	b, #03h
		bne	loc_CFBE
		ld	x, #0D2AFh
		ld	y, #0D2AFh
		bra	loc_CFBE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CF88:				; CODE XREF: ROM:CF71j
		tbbc	bit0, flags_49,	loc_CF8E ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		ld	x, #0D2AFh

loc_CF8E:				; CODE XREF: ROM:loc_CF88j
		tbbc	bit2, flags_49,	loc_CFAA ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		ld	y, #0D2AFh
		bra	loc_CFAA
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CF96:				; CODE XREF: ROM:CF6Ej
		ld	a, unk_131

loc_CF99:				; CODE XREF: ROM:CF9Ej
		cmp	a, x + 00h
		ble	loc_CFA0
		inc	x
		bra	loc_CF99
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CFA0:				; CODE XREF: ROM:CF9Bj
		ld	a, unk_14D

loc_CFA3:				; CODE XREF: ROM:CFA8j
		cmp	a, y + 00h
		ble	loc_CFAA
		inc	y
		bra	loc_CFA3
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CFAA:				; CODE XREF: ROM:loc_CF8Ej ROM:CF94j ...
		ld	a, unk_140	; bits 5,0 oxl2	related
		and	a, #02h
		bne	loc_CFB4
		ld	x, #0D2ABh

loc_CFB4:				; CODE XREF: ROM:CFAFj
		ld	a, unk_15C	; bits 5,0 oxr2	related
		and	a, #02h
		bne	loc_CFBE
		ld	y, #0D2ABh

loc_CFBE:				; CODE XREF: ROM:CF77j	ROM:CF7Ej ...
		ld	a, x + 05h
		st	a, unk_145
		ld	a, y + 05h
		st	a, unk_161
		clr	b
		cmp	#31h, count_AF	; incremented at F47D
		bcc	loc_CFD1
		jmp	loc_D0A0
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CFD1:				; CODE XREF: ROM:CFCCj
		tbbs	bit5, RAMST, loc_CFD7 ;	Built-in RAM status
		jmp	loc_D09B
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CFD7:				; CODE XREF: ROM:loc_CFD1j
<<<<<<< HEAD
		tbbs	bit6, flags_45,	loc_CFDD ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbs	bit6, flags_45,	loc_CFDD ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		tbbc	bit0, flags_4B,	loc_D046

loc_CFDD:				; CODE XREF: ROM:loc_CFD7j
		ld	a, unk_72
		inc	a
		beq	loc_D007
		ld	b, unk_70
		inc	b
		bne	loc_D015
		ld	a, unk_71
		beq	loc_D007
		dec	a
		beq	loc_CFFA
		ld	b, #78h
		cmpb	a, #0Fh
		bne	loc_D042
		mul	a, #10h
		ld	b, #69h
		bra	loc_D042
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_CFFA:				; CODE XREF: ROM:CFECj
		st	a, unk_71
		ld	a, unk_72
		jsr	sub_D0B3
		beq	loc_D010
		ld	b, #5Ah
		bra	loc_D034
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D007:				; CODE XREF: ROM:CFE0j	ROM:CFE9j
		jsr	sub_D0B3
		bne	loc_D010
		ld	b, #7Ch
		bra	loc_D032
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D010:				; CODE XREF: ROM:D001j	ROM:D00Aj
		clr	a
		ld	b, #3Bh
		bra	loc_D034
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D015:				; CODE XREF: ROM:CFE5j
		bvs	loc_D01A
		jmp	loc_D0A7
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D01A:				; CODE XREF: ROM:loc_D015j
		ld	a, unk_71
		bne	loc_D040
		st	a, unk_70
<<<<<<< HEAD
		tbbc	bit6, flags_45,	loc_D046 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbc	bit6, flags_45,	loc_D046 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		setb	bit0, flags_4B
		ld	a, unk_72
		bmi	loc_D030
		bne	loc_D038
		jsr	sub_D0B3
		bne	loc_D038

loc_D030:				; CODE XREF: ROM:D027j
		ld	b, #0FCh

loc_D032:				; CODE XREF: ROM:D00Ej
		ld	a, #80h

loc_D034:				; CODE XREF: ROM:D005j	ROM:D013j
		st	a, unk_72
		bra	loc_D0A7
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D038:				; CODE XREF: ROM:D029j	ROM:D02Ej
		st	a, unk_72
		ld	y, #0D0DAh
		add	y, a
		ld	a, y + 02h

loc_D040:				; CODE XREF: ROM:D01Cj
		ld	b, #0F8h

loc_D042:				; CODE XREF: ROM:CFF2j	ROM:CFF8j
		st	a, unk_71
		bra	loc_D0A7
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D046:				; CODE XREF: ROM:CFDAj	ROM:D020j
		tbbc	bit3, flags_4B,	loc_D066
		tbbc	bit7, flags_4C,	loc_D066 ; bounce if running
		ld	b, unk_70
		cmp	b, #7Eh
		bcc	loc_D054
		ld	b, #7Fh

loc_D054:				; CODE XREF: ROM:D050j
		cmp	b, #0FEh
		bgea	loc_D05A
		ld	b, #0FFh

loc_D05A:				; CODE XREF: ROM:D056j
		inc	b
		beq	loc_D062
		bvc	loc_D064
		ld	b, #0FEh
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  8Ch ; Œ		; cmp x
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D062:				; CODE XREF: ROM:D05Bj
		ld	b, #7Eh

loc_D064:				; CODE XREF: ROM:D05Dj
		bra	loc_D0A0
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D066:				; CODE XREF: ROM:loc_D046j ROM:D049j
		tbbc	bit3, flags_4B,	loc_D06E
		ld	b, #0FEh
		tbbs	bit7, flags_4D,	loc_D0A0

loc_D06E:				; CODE XREF: ROM:loc_D066j
		ld	b, #0B4h
		ld	a, temp_51
		and	a, #01h
		bne	loc_D0A0
		ld	a, temp_52
		and	a, #0EFh
		bne	loc_D0A0
		ld	a, temp_53
		and	a, #6Fh
		bne	loc_D0A0
		ld	a, temp_56
		and	a, #0Fh
		bne	loc_D0A0
		ld	a, word_90
		and	a, #0FFh
		bne	loc_D0A0
		ld	a, word_92
		and	a, #7Fh
		bne	loc_D0A0
		ld	b, unk_70
		inc	b
		bpz	loc_D09B
		bvc	loc_D0A0

loc_D09B:				; CODE XREF: ROM:CFD4j	ROM:D097j
		clr	b
		tbbc	bit7, flags_4C,	loc_D0A0 ; bounce if running
		dec	b

loc_D0A0:				; CODE XREF: ROM:CFCEj	ROM:loc_D064j ...
		clrb	bit0, flags_4B
		ld	#0FFh, unk_72
		clr	unk_71

loc_D0A7:				; CODE XREF: ROM:D017j	ROM:D036j ...
		st	b, unk_70
		bpz	loc_D0AE	; select SOUT1
		clrb	bit2, SSD	; select SOUT0
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  8Ch ; Œ		; cmpx,	effectly three byte NOP	when falling through
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D0AE:				; CODE XREF: ROM:D0A9j
		setb	bit2, SSD	; select SOUT1
		jmp	locret_D158

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_D0B3:				; CODE XREF: ROM:CF58p	ROM:CFFEp ...
		ld	y, #0D0DAh
		add	a, #03h
		add	y, a
		cmp	a, #7Bh
		bgt	loc_D0DA
		ld	x, #0000h
		ld	b, y + 00h
		add	x, b
		ld	b, y + 01h
		cmpb	b, x + 00h
		beq	sub_D0B3

loc_D0C9:				; CODE XREF: sub_D0B3+25j
		cmp	a, #7Bh
		bcc	loc_D0DB
		ld	b, y + 02h
		cmp	b, y + 05h
		bne	loc_D0DB
		add	a, #03h
		inc	y
		inc	y
		inc	y
		bra	loc_D0C9
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D0DA:				; CODE XREF: sub_D0B3+8j
		clr	a

loc_D0DB:				; CODE XREF: sub_D0B3+18j sub_D0B3+1Ej
		cmpz	a
		ret
; End of function sub_D0B3

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  86h ; †		; data d03a
		.db  01h
		.db  21h ; !
		.db  88h ; ˆ
		.db  20h
		.db  31h ; 1
		.db  88h ; ˆ
		.db  40h ; @
		.db  31h ; 1
		.db  88h ; ˆ
		.db  80h ; €
		.db  31h ; 1
		.db  86h ; †
		.db  02h
		.db  41h ; A
		.db  86h ; †
		.db  04h
		.db  51h ; Q
		.db  4Dh ; M
		.db  01h
		.db  61h ; a
		.db  8Ah ; Š
		.db  01h
		.db  12h
		.db  8Eh ; 
		.db  01h
		.db  12h
		.db  88h ; ˆ
		.db  01h
		.db  22h ; "
		.db  88h ; ˆ
		.db  02h
		.db  42h ; B
		.db  8Ah ; Š
		.db  04h
		.db  52h ; R
		.db  8Ah ; Š
		.db  08h
		.db  52h ; R
		.db  8Ah ; Š
		.db  10h
		.db  52h ; R
		.db  8Ch ; Œ
		.db  04h
		.db  52h ; R
		.db  8Ch ; Œ
		.db  08h
		.db  52h ; R
		.db  8Ch ; Œ
		.db  10h
		.db  52h ; R
		.db  8Ah ; Š
		.db  20h
		.db  62h ; b
		.db  8Ah ; Š
		.db  40h ; @
		.db  62h ; b
		.db  8Ch ; Œ
		.db  20h
		.db  62h ; b
		.db  8Ch ; Œ
		.db  40h ; @
		.db  62h ; b
		.db  8Ah ; Š
		.db  02h
		.db  72h ; r
		.db  8Eh ; 
		.db  02h
		.db  72h ; r
		.db  8Ch ; Œ
		.db  01h
		.db  82h ; ‚
		.db  8Eh ; 
		.db  04h
		.db  82h ; ‚
		.db  8Ch ; Œ
		.db  02h
		.db  92h ; ’
		.db  8Eh ; 
		.db  08h
		.db  92h ; ’
		.db  86h ; †
		.db  08h
		.db  13h
		.db  88h ; ˆ
		.db  04h
		.db  53h ; S
		.db  88h ; ˆ
		.db  08h
		.db  14h
		.db  8Eh ; 
		.db  10h
		.db  24h ; $
		.db  4Dh ; M
		.db  08h
		.db  24h ; $
		.db  4Dh ; M
		.db  10h
		.db  34h ; 4
		.db  88h ; ˆ
		.db  10h
		.db  74h ; t
		.db  4Dh ; M
		.db  20h
		.db  15h
		.db  86h ; †
		.db  20h
		.db  25h ; %
		.db  4Eh ; N
		.db  40h ; @
		.db  35h ; 5
		.db  86h ; †
		.db  80h ; €
		.db  55h ; U
		.db  8Ah ; Š
		.db  80h ; €
		.db  17h
		.db  8Eh ; 
		.db  20h
		.db  17h
		.db  8Ch ; Œ
		.db  80h ; €
		.db  87h ; ‡
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

locret_D158:				; CODE XREF: ROM:D0B0j
		ret

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_D159:				; CODE XREF: ROM:CC47p	ROM:CC50p
		ld	d, x + 00h
		cmp	a, #040
		bcs	loc_D192
		cmp	b, #0FFh
		beq	loc_D164
		inc	b

loc_D164:				; CODE XREF: sub_D159+8j
		cmp	b, #02h
		bcs	loc_D190
		tbbc	bit3, flags_4B,	loc_D17B
		setb	bit6, flags_4D
		ld	a, y + 19h
		or	a, #50h
		st	a, y + 19h
		ld	a, y + 1Ah
		or	a, #50h
		st	a, y + 1Ah
		bra	loc_D189
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D17B:				; CODE XREF: sub_D159+Fj
		ld	a, y + 1Ah
		cmpb	a, #50h
		bne	loc_D189
		ld	a, y + 19h
		or	a, #50h
		st	a, y + 19h
		bra	loc_D18F
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D189:				; CODE XREF: sub_D159+20j sub_D159+26j
		ld	a, y + 15h
		or	a, #40h
		st	a, y + 15h

loc_D18F:				; CODE XREF: sub_D159+2Ej
		clr	b

loc_D190:				; CODE XREF: sub_D159+Dj
		bra	loc_D1B6
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D192:				; CODE XREF: sub_D159+4j
		cmp	a, #06h
		bgt	loc_D1B6
		ld	a, y + 01h
		cmp	a, #19h
		beq	loc_D1B6
		cmp	a, #0E6h
		beq	loc_D1B6
		ld	a, x + 02h
		inc	a
		cmp	a, #14h
		bcs	loc_D1B1
		push	x
		ld	x, #0D254h
		jsr	sub_D222
		pull	x
		clr	a
		clr	b

loc_D1B1:				; CODE XREF: sub_D159+4Cj
		st	a, x + 02h
		clr	a
		bra	loc_D1B9
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D1B6:				; CODE XREF: sub_D159:loc_D190j
					; sub_D159+3Bj	...
		clr	a
		st	a, x + 02h

loc_D1B9:				; CODE XREF: sub_D159+5Bj
		st	d, x + 00h
		ret
; End of function sub_D159


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_D1BC:				; CODE XREF: ROM:CD87p	ROM:CD96p
		ld	a, y + 13h
		and	a, #02h
		beq	loc_D1E9
<<<<<<< HEAD
		tbbs	bit0, flags_40,	loc_D1DF ; B3 :	forced timing to 5/10 deg BTDC
=======
		tbbs	bit0, flags_40,	loc_D1DF
>>>>>>> origin/master
		ld	a, flags_49	; bits 1-3-4-5 are oxl1-oxr1-oxl2-oxr2 - Oxygen	sensors
		cmpb	a, x + 01h	; check	high bit
		bne	locret_D1D1
		cmpb	a, x + 00h	; check	low bit
		bne	loc_D1D2
		or	b, #01h		; set b	lsb

locret_D1D1:				; CODE XREF: sub_D1BC+Dj
		ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D1D2:				; CODE XREF: sub_D1BC+11j
		cmpb	b, #01h
		beq	locret_D1DE
		and	b, #0FEh	; clear	b lsb
		add	b, #08h
		bcc	locret_D1DE
		or	b, #0F8h

locret_D1DE:				; CODE XREF: sub_D1BC+18j sub_D1BC+1Ej
		ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D1DF:				; CODE XREF: sub_D1BC+6j
		cmp	b, #20h
		bcs	loc_D1E9
		ld	x, #0D250h	; negative masks for bits 0..3
		jsr	sub_D222

loc_D1E9:				; CODE XREF: sub_D1BC+4j sub_D1BC+25j
		clr	b
		ret
; End of function sub_D1BC

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  01h
		.db  02h
		.db  04h
		.db  08h

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_D1EF:				; CODE XREF: ROM:CDD5p	ROM:CDE4p
		cmpb	b, #80h
		beq	loc_D220
		cmp	#64h, unk_5E	; could	be last	unk_100, or 0
		bcc	loc_D220
		cmp	#030, RPM	; 1500 RPM
		bcs	loc_D220
		cmp	#228, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		bcs	loc_D220
		cmpb	b, #01h
		bne	loc_D220
		cmp	#019, unk_D4	; timing related
		bcs	loc_D220
		cmp	a, #20h
		bcs	locret_D221
		ld	b, y + 19h
		or	b, #02h
		st	b, y + 19h
		tbbc	bit3, flags_4B,	loc_D220
		setb	bit6, flags_4D
		ld	b, y + 1Ah
		or	b, #02h
		st	b, y + 1Ah

loc_D220:				; CODE XREF: sub_D1EF+2j sub_D1EF+7j ...
		clr	a

locret_D221:				; CODE XREF: sub_D1EF+1Ej
		ret
; End of function sub_D1EF


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_D222:				; CODE XREF: ROM:CB80p	ROM:CB89p ...
		ld	a, y + 19h
		and	a, x + 00h
		st	a, y + 19h	; offset 25
		ld	a, y + 1Ah	; offset 26
		and	a, x + 00h
		st	a, y + 1Ah
		ld	a, x + 00h
		st	a, temp_56
		ld	x, #0090h
		cmp	y, #012Dh
		beq	loc_D23D
		ld	x, #0092h

loc_D23D:				; CODE XREF: sub_D222+16j
		ld	b, x + 00h
		and	b, temp_56
		jsr	sub_CF4E
		inc	x
		inc	x
		inc	x
		inc	x
		ld	b, x + 00h
		and	b, temp_56
		jsr	sub_CF4E
		ret
; End of function sub_D222

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0FEh ; ş
		.db 0FDh ; ı		; data used by above sub
		.db 0FBh ; û
		.db 0D7h ; ×
		.db 0AFh ; ¯
		.db  7Fh ; 
		.db  7Fh ; 

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_D257:				; CODE XREF: __RESET+1738p
<<<<<<< HEAD
		tbbs	bit7, flags_45,	loc_D25F ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbs	bit7, flags_45,	loc_D25F ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		ld	#222, unk_7C	; this seems to	be the favoured	execution
		bra	loc_D289	; clear	1ca and	return
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D25F:				; CODE XREF: sub_D257j
		ld	x, unk_1CA
		bne	locret_D268
		ld	b, unk_7C	; counter
		bpz	loc_D269

locret_D268:				; CODE XREF: sub_D257+Bj
		ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D269:				; CODE XREF: sub_D257+Fj
		ld	y, #0D28Fh
		add	y, b
		add	b, #02h
		st	b, unk_7C	; counter
		cmp	b, #02h
		bgt	loc_D27B
		ld	d, y + 00h
		or	a, #30h
		bra	loc_D283
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D27B:				; CODE XREF: sub_D257+1Cj
		ld	y, y + 00h
		beq	loc_D286
		ld	b, y + 00h
		ld	a, #03h

loc_D283:				; CODE XREF: sub_D257+22j
		shl	d
		bra	loc_D28B	; write	out 1ca	and return
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D286:				; CODE XREF: sub_D257+26j
		ld	#240, unk_7C	; counter

loc_D289:				; CODE XREF: sub_D257+6j
		clr	a		; clear	1ca and	return
		clr	b

loc_D28B:				; CODE XREF: sub_D257+2Dj
		st	d, unk_1CA	; write	out 1ca	and return
		ret
; End of function sub_D257

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  08h		; data d269
		.db  61h ; a
		.db  01h
		.db 0C8h ; È
		.db  01h
		.db  95h ; •
		.db  00h
		.db 0DBh ; Û
		.db  01h
		.db 0C9h ; É
		.db  01h
		.db 0C7h ; Ç
		.db  00h
		.db 0F7h ; ÷
		.db  00h
		.db  6Ah ; j
		.db  00h
		.db  5Eh ; ^
		.db  01h
		.db  31h ; 1
		.db  01h
		.db  4Dh ; M
		.db  01h
		.db 0C5h ; Å
		.db  01h
		.db 0C6h ; Æ
		.db  00h
		.db  00h
		.db  4Dh ; M		; data
		.db  71h ; q
		.db  8Fh ; 
		.db 0B3h ; ³
		.db 0FFh		; more data
		.db  10h
		.db  0Ch
		.db  08h
		.db  04h
		.db  00h
		.db  40h ; @
		.db  80h ; €
		.db 0BFh ; ¿
		.db  7Fh ; 

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_D2B9:				; CODE XREF: __RESET+F97p
		clr	a
		clr	b
		clrb	bit2, DOUT	; trailing edge
		div	d, #00h		; probably a good time waster
		div	d, #00h
		setb	bit2, DOUT	; leading edge
		st	d, IMASK	; Interrupt Request Mask MSB
		jsr	sub_D3F3

loc_D2C8:				; CODE XREF: sub_D2B9+B5j
					; sub_D2B9+119j
		clr	DOM		; DOUT Control Register
		ld	a, #0Eh
		st	a, DOUT		; DOUT Data Register
		clrb	bit3, IRQLL
		ld	#08h, IMASKL	; enable only SIN0
		ld	y, #0F765h

loc_D2D6:				; CODE XREF: sub_D2B9+2Bj
		ld	a, y + 00h
		jsr	sub_D45F	; blast	out a byte, read SIDR and SSD for 300 iterations
		cmp	y, #0F774h
		bcc	loc_D2E6	; end adc burst
		inc	y
		jsr	sub_D3F3
		bra	loc_D2D6
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D2E6:				; CODE XREF: sub_D2B9+25j
<<<<<<< HEAD
		ld	a, flags_1AA	; signal from fuel pump	ecu (DI)
=======
		ld	a, flags_1AA	; IC302	input bits B3~0	are NOT	of oxy heater pin voltages
>>>>>>> origin/master
		cmpb	a, #40h
		beq	loc_D2F1	; fuel pressure	down
		clrb	bit2, PORTD_ASRIN ; fuel pressure up
		bra	loc_D2F3
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D2F1:				; CODE XREF: sub_D2B9+32j
		setb	bit2, PORTD_ASRIN ; fuel pressure down

loc_D2F3:				; CODE XREF: sub_D2B9+36j
<<<<<<< HEAD
		tbbc	bit7, flags_45,	loc_D2F9 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbc	bit7, flags_45,	loc_D2F9 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		jmp	loc_D371
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D2F9:				; CODE XREF: sub_D2B9:loc_D2F3j
<<<<<<< HEAD
		tbbs	bit2, flags_45,	loc_D347 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
		ld	a, VTA2_net	; VTA2-VTA2_min, =255 when sub throttle	disabled/not exist
=======
		tbbs	bit2, flags_45,	loc_D347 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		ld	a, VTA2_net	; VTA2-VTA2_min
>>>>>>> origin/master
		cmp	#80h, THG	; THG lookup table output from exhaust gas temp	sensor ADC reading
		bcc	ISC1
		ld	a, flags_49	; bits 1-3-4-5 are oxl1-oxr1-oxl2-oxr2 - Oxygen	sensors
		and	a, #3Ah		; mask out everything but the oxy sensors
		cmp	a, #0Ah
		beq	loc_D33D
		cmp	a, #30h
		bne	loc_D36B
		ld	a, #55h
		ld	#55h, temp_52

loc_D315:				; CODE XREF: sub_D2B9+89j
		st	a, flags_50	; could	be bits	for 6336 output	chip, B0 probably HTR L+R1, B1 probably	HTR L+R2
		jsr	write6336
		ld	a, PORTA	; Port A Data Register
		and	a, #0Ch
		shl	a
		shl	a
		st	a, temp_51
<<<<<<< HEAD
		ld	b, flags_1AA	; B6 - DI (FPECU), B3~0	are NOT	of oxy heater pin voltages R2, R1, L2, L1 (IC302)
=======
		ld	b, flags_1AA	; IC302	input bits B3~0	are NOT	of oxy heater pin voltages
>>>>>>> origin/master
		and	b, #0Fh
		or	b, temp_51
		st	b, temp_51
		ld	a, PORTC	; Port C Data Register
		and	a, #11000000b
		or	a, temp_51
		cmp	a, temp_52
		beq	loc_D339	; SOUT0
		setb	bit2, SSD	; SOUT1
		bra	loc_D36B
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D339:				; CODE XREF: sub_D2B9+7Aj
		clrb	bit2, SSD	; SOUT0
		bra	loc_D36B
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D33D:				; CODE XREF: sub_D2B9+51j
		ld	a, #0AAh
		ld	#0AAh, temp_52
		bra	loc_D315
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D344:				; CODE XREF: sub_D2B9+90j sub_D2B9+93j ...
		jmp	loc_D3B5
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D347:				; CODE XREF: sub_D2B9:loc_D2F9j
		ld	b, #0FFh
		tbbc	bit0, PORTC, loc_D344 ;	Port C Data Register
		tbbs	bit7, PORTB, loc_D344 ;	Port B Data Register
		tbbc	bit6, PORTB, loc_D344 ;	Port B Data Register
		setb	bit2, SSD	; SOUT1
		ld	b, #0AAh
		ld	a, #32h
		jmp	loc_D3C1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ISC1:					; CODE XREF: sub_D2B9+49j
		ld	b, PORTB	; Port B Data Register
		and	b, #0F0h
		cmp	a, #14h
		bcc	ISC2		; drive	other pair
		or	b, #05h		; drive	one pair
		bra	ISC3
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ISC2:					; CODE XREF: sub_D2B9+A8j
		or	b, #0Ah		; drive	other pair

ISC3:					; CODE XREF: sub_D2B9+ACj
		st	b, PORTB	; Port B Data Register

loc_D36B:				; CODE XREF: sub_D2B9+55j sub_D2B9+7Ej ...
		jsr	sub_D3F3
		jmp	loc_D2C8
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D371:				; CODE XREF: sub_D2B9+3Dj
		setb	bit5, RAMST
		clr	a

loc_D374:				; CODE XREF: sub_D2B9+D7j
		mov	a, b
		ld	y, #0040h

loc_D378:				; CODE XREF: sub_D2B9+C4j
		st	a, [y]
		inc	a
		cmp	y, #0340h
		bcs	loc_D378
		ld	y, #0040h

loc_D382:				; CODE XREF: sub_D2B9+D1j
		ld	a, [y]
		cmp	a, b
		bne	loc_D3B4
		inc	b
		cmp	y, #0340h
		bcs	loc_D382
		bsr	sub_D3D5	; clears bit0 of porta,	re-inits if bit4 of PBCS is clear
		inc	b
		mov	b, a
		bne	loc_D374
		ld	x, #0C000h
		clr	a
		clr	b

calcChecksum:				; CODE XREF: sub_D2B9+EDj
		ld	y, #0100h

calcChecksum2:				; CODE XREF: sub_D2B9+E6j
		add	d, x + 00h
		inc	x
		inc	x
		dec	y
		bne	calcChecksum2
		bsr	sub_D3D5	; clears bit0 of porta,	re-inits if bit4 of PBCS is clear
		cmp	x, #0000h
		bne	calcChecksum
		cmp	d, #0AA55h
		bne	loc_D3B4	; checksum fail	follows	this branch
		shl	b
		setb	bit2, SSD	; SOUT1
		ld	a, #19h
		bra	loc_D3C1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D3B4:				; CODE XREF: sub_D2B9+CBj sub_D2B9+F2j
		clr	b

loc_D3B5:				; CODE XREF: sub_D2B9:loc_D344j
					; sub_D2B9+115j
		tbs	bit2, SSD	; Serial Status	Data Register
		beq	loc_D3BB
		clrb	bit2, SSD	; SOUT0

loc_D3BB:				; CODE XREF: sub_D2B9+FEj
		ld	a, #7Dh
		cmpz	b
		beq	loc_D3C1
		shr	a

loc_D3C1:				; CODE XREF: sub_D2B9+9Fj sub_D2B9+F9j ...
		ld	x, #0F7B5h

loc_D3C4:				; CODE XREF: sub_D2B9+10Cj
		inc	x
		bne	loc_D3C4
		bsr	sub_D3D5	; clears bit0 of porta,	re-inits if bit4 of PBCS is clear
		dec	a
		bne	loc_D3C1
		cmp	b, #0AAh
		bne	loc_D3B5
		clrb	bit2, SSD
		jmp	loc_D2C8
; End of function sub_D2B9


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; clears bit0 of porta,	re-inits if bit4 of PBCS is clear

sub_D3D5:				; CODE XREF: sub_D2B9+D3p sub_D2B9+E8p ...
		jsr	portAclrB0	; watchdog pin
		tbbc	bit4, PBCS, ClearRAM ; bit4 is /IDL1
		ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ClearRAM:				; CODE XREF: sub_D3D5+3j
		ld	y, #0040h
		clr	a
		clr	b

ClearRAM_1:				; CODE XREF: sub_D3D5+10j
		st	d, [y]
		cmp	y, #01D9h
		ble	ClearRAM_1
		ld	s, #02DFh	; Re-init stack.. this is a bad	place
		clrb	bit3, IRQLL
		jmp	res_03		; jump into init before	main loop
; End of function sub_D3D5

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0CAh ; Ê
		.db  83h ; ƒ
		.db  40h ; @
		.db  02h

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_D3F3:				; CODE XREF: sub_D2B9+Cp sub_D2B9+28p	...
		ld	a, #0FFh

loc_D3F5:				; CODE XREF: sub_D3F3+Bj
		ld	x, #0F7B6h

loc_D3F8:				; CODE XREF: sub_D3F3+6j
		inc	x
		bne	loc_D3F8	; loop 2121 times
		bsr	sub_D3D5	; clears bit0 of porta,	re-inits if bit4 of PBCS is clear
		inc	a
		bne	loc_D3F5	; loop again perhaps
		ret
; End of function sub_D3F3

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; watchdog pin

portAclrB0:				; CODE XREF: sub_D3D5p	__RESET:res_04p
		tbs	bit0, PORTA	; Port A Data Register
		beq	portAclrB0_ret
		clrb	bit0, PORTA

portAclrB0_ret:				; CODE XREF: portAclrB0+2j
		ret
; End of function portAclrB0


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ReInitNEIGT:				; CODE XREF: __RESET+185p
					; __RESET:main_09p
		clrb	bit4, PORTAL
		clrb	bit5, PORTAL
		clrb	bit0, DOUT	; IGT off
		clrb	bit0, DOM
		jsr	ReInitCounters
		ld	d, #2000h
		st	d, deltaNE
		st	d, deltaNE_1
		ld	a, #60h
		st	d, threeDeltaNE	; re-init
		clr	a
		st	d, NEcounts	; re-init
		clrb	bit0, flags_4A
		clrb	bit1, flags_44
		clrb	bit2, flags_44
		clrb	bit1, flags_4C
		st	a, unk_1B6	; re-init
		st	a, unk_1B7	; re-init
		st	d, RPM		; re-init to 0000
		clrb	bit4, flags_42
		ret
; End of function ReInitNEIGT


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ReInitCounters:				; CODE XREF: ReInitNEIGT+8p
		ld	a, #0FFh
		st	a, byte_112	; necounts/motor phase related
		ld	a, #018
		mov	a, b
		st	d, byte_110	; 7 to 23, highest at lowest fuel flow
		add	a, #013
		cmp	a, #024
		ble	ReInitCNT_1
		sub	a, #024

ReInitCNT_1:				; CODE XREF: ReInitCounters+Fj
		st	a, byte_113	; necounts/motor phase related
		ret
; End of function ReInitCounters


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; blast	out a byte, read SIDR and SSD for 300 iterations

sub_D45F:				; CODE XREF: sub_D2B9+1Fp __RESET+10Bp
		clrb	bit3, SSD
		st	a, ADC_TXed	; MSb signifies	next TX	value is 02
		setb	bit1, SSD	; set ninth bit	high
		and	a, #1Fh
		st	a, SIDR_SODR	; Serial Input/Output Data Register
		ld	x, #0000h

loc_D46C:				; CODE XREF: sub_D45F+1Dj
		inc	x
		cmp	x, #0003h
		bne	loc_D479
		ld	#30h, SMRC_SIR	; Serial Master	Register Control
		ld	a, SSD		; Serial Status	Data Register
		ld	a, SIDR_SODR	; Serial Input/Output Data Register

loc_D479:				; CODE XREF: sub_D45F+11j
		cmp	x, #00300
		bcs	loc_D46C
		ret
; End of function sub_D45F


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


write6336:				; CODE XREF: sub_D2B9+5Ep __RESET+75p	...
		clrb	bit5, PORTB
		ld	a, flags_50	; could	be bits	for 6336 output	chip, B0 probably HTR L+R1, B1 probably	HTR L+R2
		xor	a, #00h
		st	a, SIDR_SODR2	; write	data is	tx'd on pin 47, read data is from pin 48
		ld	a, #005

loc_D489:				; CODE XREF: write6336+11j
		ld	b, unk_1D	; bit3 seems to	be a uart global clock output enable
		and	b, #04h		; probably "txempty" bit
		bne	loc_D494	; set pin 22 - latch data from rx hold buffer into output buffer of 6336
		dec	a
		bne	loc_D489
		bra	locret_D498
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D494:				; CODE XREF: write6336+Ej
		setb	bit5, PORTB	; set pin 22 - latch data from rx hold buffer into output buffer of 6336
		clrb	bit5, PORTB	; clear	pin 22

locret_D498:				; CODE XREF: write6336+13j
		ret
; End of function write6336


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_D499:				; CODE XREF: __RESET+174p
					; __RESET+104Bp
		ld	a, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		cmp	a, #217
		bcc	loc_D4A1	; bounce if higher
		clrb	bit4, flags_47

loc_D4A1:				; CODE XREF: sub_D499+4j
		cmp	a, #223
		ble	loc_D4A7	; bounce if lower
		setb	bit4, flags_47	; warmness bit

loc_D4A7:				; CODE XREF: sub_D499+Aj
		ld	a, unk_5E	; could	be last	unk_100, or 0
		cmp	a, #045
		bgt	loc_D4AF	; bounce if greater than 45
		clrb	bit7, flags_41

loc_D4AF:				; CODE XREF: sub_D499+12j
		cmp	a, #055
		bcs	locret_D4B5
		setb	bit7, flags_41

locret_D4B5:				; CODE XREF: sub_D499+18j
		ret
; End of function sub_D499


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


		; public __RESET
__RESET:				; DATA XREF: __NMI+3o ROM:FFFEo

; FUNCTION CHUNK AT D6D6 SIZE 000003FE BYTES
; FUNCTION CHUNK AT DAEC SIZE 00000094 BYTES
; FUNCTION CHUNK AT DB89 SIZE 0000109E BYTES

		ld	#07h, OMODE	; Mode control Register
		di
		ld	#0C2h, PORTA	; Port A Data Register
		ld	#0C3h, DDRA	; Port A i/o config
		ld	#10h, PORTB	; Port B Data Register
		ld	#3Fh, DDRB	; Port B i/o config
		clr	PBCS		; Port B Control Register
		ld	#1Eh, ASR0P	; ASR0 pos edge	counter	value MSB
		ld	#08h, unk_1D	; bit3 seems to	be a uart global clock output enable
		ld	#30h, ASR0NL	; ASR0 neg edge	counter	value LSB
		ld	#34h, ASR0N	; ASR0 neg edge	counter	value MSB
		ld	d, #3900h
		st	d, ASR2		; ASR2 edge counter value MSB
		ld	d, #38F0h
		st	d, ASR3		; ASR3 edge counter value MSB
		ld	#00h, ASR1N	; ASR1 neg edge	counter	value MSB
		ld	#00h, ASR1NL	; ASR1 neg edge	counter	value LSB
		ld	#0Fh, ASR0PL	; ASR0 pos edge	counter	value LSB
		ld	#0Bh, PORTD_ASRIN ; Port D Data	Register / ASR Input Data
		ld	#33h, TAIT	; Timer	ASR Control
		ld	#0FDh, ASR1P	; ASR1 pos edge	counter	value MSB
		ld	#00h, DOUT	; turn off all
		ld	#00h, DOM	; DOUT Control Register
		ld	#30h, SMRC_SIR	; Serial Master	Register Control
		ld	#04h, SSD	; select SOUT1
		clrb	bit1, PORTD_ASRIN
		ld	a, SSD		; Serial Status	Data Register
		ld	a, SIDR_SODR	; Serial Input/Output Data Register
		clr	a
		clr	b
		st	d, IRQL		; clear	all flags
		st	d, IMASK	; clear	all mask bits
		ld	s, #02DFh	; byte 735, super mega ram!
		clr	a
		clr	b
		ld	y, #0040h

res_01:					; CODE XREF: __RESET+5Ej
		st	d, [y]
		cmp	y, #0080h	; erase	ram 0x40 to 0x80 inclusive
		bcs	res_01
		ld	y, #00A0h

res_02:					; CODE XREF: __RESET+67j
		st	d, [y]
		cmp	y, #01D9h	; erase	ram 0xA0 to 0x1D9 inclusive
		bcs	res_02
		tbs	bit6, RAMST	; Built-in RAM status
		bne	res_03
		setb	bit5, flags_41

res_03:					; CODE XREF: sub_D3D5+17j __RESET+6Bj
		ld	y, #0D58Dh
		jsr	InitRAM		; fill ram with	default	values
		jsr	write6336
		setb	bit7, flags_4C	; init
		setb	bit6, flags_49	; init
		setb	bit3, flags_47	; init
		setb	bit7, flags_44	; init
		ld	d, #02825
		st	d, InjectPW1	; reset	initialization of PW
		st	d, InjectPW2	; reset	Initialization of PW
		ld	d, #00393
		st	d, InjDeadtime	; init to 393
		ld	d, #4000h
		st	d, word_16A
		st	d, word_16C
		ld	a, #80h
		st	a, unk_131
		st	a, unk_14D
		st	d, unk_12E
		st	d, unk_14A
		st	a, unk_176
		ld	a, #2Ch
		st	a, VTA1_min	; VTA1 minimum
		st	a, VTA2_min	; VTA2 minimum
		ld	b, #33h
		st	b, unk_6C	; sort of a filtered, saturated	VTA_net
		ld	a, #0A0h
<<<<<<< HEAD
		st	a, VTA2_net	; VTA2-VTA2_min, =255 when sub throttle	disabled/not exist
=======
		st	a, VTA2_net	; VTA2-VTA2_min
>>>>>>> origin/master
		ld	a, #0FFh
		st	a, count_1A0	; increments at	E480
		st	a, count_1A1	; increments at	E480
		ld	a, #08h
		st	a, ISC_11F	; ISC related
		ld	a, #10h
		st	a, unk_145
		st	a, unk_161
		ld	a, #0Ah
		st	a, unk_1B3
		jmp	res_04
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0B9h ; ¹		; data for D525	- ram init routine (addr:data, 00 address to quit
		.db  86h ; †
		.db  5Fh ; _		; unk_5f
		.db 0FFh
		.db 0A8h ; ¨		; count_A8
		.db 0FFh
		.db  6Dh ; m		; signed change	in load	from avg
		.db  80h ; €
		.db  7Ah ; z		; meanKSint divided by air temp	comp factor
		.db  20h
		.db  78h ; x		; meanKSint
		.db  40h ; @
		.db  5Dh ; ]		; ATM_press
		.db 0B4h ; ´
		.db 0F6h ; ö		; Bvolts
		.db  66h ; f
		.db 0FAh ; ú		; rawTHA
		.db  86h ; †
		.db 0F2h ; ò		; compLoad
		.db  8Ch ; Œ
		.db  6Eh ; n		; LOAD
		.db  8Ch ; Œ
		.db  75h ; u		; flags	related	to ADC tx'n
		.db  01h
		.db  77h ; w		; unk_77
		.db  01h
		.db  7Ch ; |		; unk_7c counter
		.db 0DEh ; Ş
		.db 0B6h ; ¶		; b6 counter
		.db 0FFh
		.db 0E4h ; ä		; unk_e4
		.db  28h ; (
		.db 0A1h ; ¡		; unk_A1
		.db 0FFh
		.db  50h ; P		; flags	50
		.db  00h
		.db 0CCh ; Ì		; count	cc
		.db 0FFh
		.db  00h		; quitquitquit
		.db  00h
		.db  00h
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

res_04:					; CODE XREF: __RESET+D4j
		jsr	portAclrB0	; watchdog pin
		ld	#08h, IMASKL	; Interrupt Request Mask LSB
		ei
		clr	b

res_05:					; CODE XREF: __RESET+111j
		ld	a, byte_F767
		jsr	sub_D45F	; blast	out a byte, read SIDR and SSD for 300 iterations
		inc	b
		cmp	b, #02h
		bcs	res_05
<<<<<<< HEAD
		tbbs	bit6, flags_45,	res_06 ; IC303 input chip: B7 /TE2, B6 /TE1, B5	/NSW, B4 IGSW,	B3, B2 IDL2, B1	, B0 STA
		tbbc	bit7, flags_45,	res_06 ; IC303 input chip: B7 /TE2, B6 /TE1, B5	/NSW, B4 IGSW,	B3, B2 IDL2, B1	, B0 STA
=======
		tbbs	bit6, flags_45,	res_06 ; IC303 input chip: B7 /TE2, B /TE1, B5 /NSW, B4	IGSW,  B3, B2 IDL2, B1 , B0 STA
		tbbc	bit7, flags_45,	res_06 ; IC303 input chip: B7 /TE2, B /TE1, B5 /NSW, B4	IGSW,  B3, B2 IDL2, B1 , B0 STA
>>>>>>> origin/master
		setb	bit3, flags_4B
		setb	bit4, flags_4D
		setb	bit3, flags_4D

res_06:					; CODE XREF: __RESET+113j __RESET+116j
		ld	a, #03h
		st	a, unk_1C4
		tbbc	bit7, RAMST, res_07 ; Built-in RAM status
		cmp	#5Ah, word_84
		bne	res_07
		jsr	sub_D667
		bcs	res_07
		ld	a, word_94
		and	a, #0FFh
		st	a, flags_147
		ld	a, word_96
		and	a, #0FFh
		st	a, flags_163
		ld	a, word_94
		or	a, word_96
		and	a, #28h
		beq	res_07
		ld	b, #80h
		st	b, unk_142
		ld	b, #0FFh
		st	b, unk_1CE
		ld	a, word_90
		or	a, word_92
		and	a, #28h
		beq	res_07
		ld	b, #0FFh
		st	b, unk_1CF

res_07:					; CODE XREF: __RESET+124j __RESET+12Aj ...
		ld	d, word_80
		xor	b, #0FFh
		cmp	a, b
		beq	res_08
		ld	a, #7Dh
		setb	bit3, flags_48
		setb	bit4, flags_48

res_08:					; CODE XREF: __RESET+163j
<<<<<<< HEAD
		st	a, unk_DB	; magic	from address 0x80
=======
		st	a, unk_DB
>>>>>>> origin/master
		add	a, #20h
		st	a, unk_DC
		jsr	sub_C505
		jsr	sub_D499
		jsr	calcInjPW	; do an	initial	calculation
		jsr	sub_C634
		jsr	sub_C003
		setb	bit2, DOUT
		nop			; user pre run function	space
		nop
		nop
		jsr	ReInitNEIGT
		clrb	bit6, IRQLL

MainLoop:				; CODE XREF: __RESET:EndMainLoopj
		ld	d, #116Eh
		st	d, IMASK	; Interrupt Request Mask MSB
		setb	bit2, flags_4A
		tbbc	bit0, flags_45,	main_01	; bounce if not	starting
		clrb	bit4, flags_4D

main_01:				; CODE XREF: __RESET+191j
		tbbc	bit5, RAMST, main_04 ; Built-in	RAM status
		tbs	bit7, RAMST	; Built-in RAM status
		beq	main_02
		cmp	#5Ah, word_84
		bne	main_02
		jsr	sub_D667
		bcc	main_03

main_02:				; CODE XREF: __RESET+19Bj __RESET+1A0j
		jsr	init_seg0x80	; plays	with lots of the undefined regions of memory

main_03:				; CODE XREF: __RESET+1A5j
		tbbc	bit5, RAMST, main_04 ; Built-in	RAM status
		setb	bit1, flags_4B

main_04:				; CODE XREF: __RESET:main_01j
					; __RESET:main_03j
		bra	main_05
; End of function __RESET


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_D667:				; CODE XREF: __RESET+12Cp __RESET+1A2p
		ld	y, #0082h

loc_D66A:				; CODE XREF: sub_D667+Bj
		cmp	y, #00A2h
		bcc	loc_D676
		ld	d, [y]
		add	a, b
		inc	a
		beq	loc_D66A
		bra	loc_D683
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D676:				; CODE XREF: sub_D667+6j
		ld	y, #0300h

loc_D679:				; CODE XREF: sub_D667+1Aj
		cmp	y, #030Ah
		bcc	loc_D686
		ld	d, [y]
		add	a, b
		inc	a
		beq	loc_D679

loc_D683:				; CODE XREF: sub_D667+Dj
		setc
		bra	locret_D687
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_D686:				; CODE XREF: sub_D667+15j
		clrc

locret_D687:				; CODE XREF: sub_D667+1Dj
		ret
; End of function sub_D667


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; plays	with lots of the undefined regions of memory

init_seg0x80:				; CODE XREF: __RESET:main_02p
		ld	a, flags_4D
		and	a, #18h
		st	a, flags_4D	; clear	all but	bits 4 and 3
		clr	a
		clr	b
		st	d, flags_4E	; clear	flags_4e and flags_4f
		st	a, flags_146
		st	a, flags_162
		st	a, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1
		dec	b
		ld	y, #0086h
		st	d, [y]		; write	out 00FF to 0x86
		st	d, [y]		; 0x88
		st	d, [y]		; 0x8A
		st	d, [y]		; 0x8C
		st	d, [y]		; 0x8E
		st	d, [y]		; 0x90
		st	d, [y]		; 0x92
		st	d, [y]		; 0x94
		st	d, [y]		; 0x96
		ld	d, #14EBh
		st	d, word_82
		ld	d, #807Fh
		ld	y, #0098h
		st	d, [y]
		st	d, [y]
		st	d, [y]
		ld	d, #6699h
		st	d, word_304
		st	d, word_306
		ld	d, #00FFh
		st	d, word_300
		st	d, word_302
		st	d, word_9E
		st	d, unk_A0
		st	d, word_308
		ld	d, #5AA5h
		st	d, word_84
		clrb	bit1, flags_4B
		ret
; End of function init_seg0x80

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR __RESET

main_05:				; CODE XREF: __RESET:main_04j
<<<<<<< HEAD
		tbbc	bit0, flags_45,	main_06	; IC303	input chip: B7 /TE2, B6	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
=======
		tbbc	bit0, flags_45,	main_06	; IC303	input chip: B7 /TE2, B /TE1, B5	/NSW, B4 IGSW,	B3, B2 IDL2, B1	, B0 STA
>>>>>>> origin/master
		clrb	bit2, flags_4C

main_06:				; CODE XREF: __RESET:main_05j
		cmp	#020, RPM	; MSB is RPM/50, LSB is	fraction of 50
		bcs	main_07
		cmp	#07h, count_B9	; incremented at F55E
		bcs	main_07
<<<<<<< HEAD
		tbbc	bit2, flags_4C,	main_07	; bit 7	set when not running (300 to 400 RPM gap)
=======
		tbbc	bit2, flags_4C,	main_07	; bit 7	demands	a sampling of the oxygen sensors
>>>>>>> origin/master
		setb	bit5, flags_4F

main_07:				; CODE XREF: __RESET+228j __RESET+22Dj ...
		cmp	#92h, count_B9	; incremented at F55E
		bcs	main_10
<<<<<<< HEAD
		tbbc	bit0, flags_4C,	main_08	; bit 7	set when not running (300 to 400 RPM gap)
=======
		tbbc	bit0, flags_4C,	main_08	; bit 7	demands	a sampling of the oxygen sensors
>>>>>>> origin/master
		setb	bit3, flags_4E

main_08:				; CODE XREF: __RESET+239j
		tbbs	bit3, flags_4E,	main_09	; bit1 is igf1 related,	bit2 igf2 related
		clr	count_B3	; incremented at F55E

main_09:				; CODE XREF: __RESET:main_08j
		jsr	ReInitNEIGT
		bra	main_13
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_10:				; CODE XREF: __RESET+237j
		ld	x, threeDeltaNE
		cmp	x, #00469	; 7996 RPM
		bgt	main_11
		ld	d, #0A000h
<<<<<<< HEAD
		bra	main_12		; the only meaningful time this	value is writ
=======
		bra	main_12		; the only meaningful time this	alue is	writ
>>>>>>> origin/master
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_11:				; CODE XREF: __RESET+24Dj
		ld	d, #37500
		jsr	divDbyX		; divide D by X, does some shifting to return ?? bits
		shl	d

main_12:				; CODE XREF: __RESET+252j
<<<<<<< HEAD
		st	d, RPM		; the only meaningful time this	value is writ
=======
		st	d, RPM		; the only meaningful time this	alue is	writ
>>>>>>> origin/master
		ld	y, #0C25Bh
		jsr	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB
		shr	d
		shr	d
		shr	d
		st	d, word_1AC	; deltaKS limit	for checking sensor. generated from RPM	lookup table

main_13:				; CODE XREF: __RESET+246j
		di
		ld	a, flags_77	; set bit 6
		mov	a, b
		or	a, #40h
		st	a, flags_77	; set bit 6
		ei
		cmpb	b, #40h
		beq	main_14
<<<<<<< HEAD
		jmp	main_36		; bounce if not	running
=======
		jmp	main_36
>>>>>>> origin/master
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_14:				; CODE XREF: __RESET+274j
		ld	d, meanKSint	; deltaKS/KS_count, filtered
		shr	d
		ld	y, RPM		; MSB is RPM/50, LSB is	fraction of 50
		jsr	MulDbyY		; returns upper	16 bits	in Y, lower 16 bits in D
		cmp	y, #00075	; Y:D now holds	meanKSint*RPM/2. this value decreases with increasing load
		ble	main_15		; bounce if Y is less or equal to 75, which skips taking the scaled reciprocal of word_51
		st	y, temp_51	; this is the desirable	program	path
		ld	d, meanKSint	; deltaKS/KS_count, filtered
		shr	d
		ld	y, #0C246h	; this could be	a compensation for AFM nonlinearities
		jsr	TwoD_AccD	; lookup AccD/64, integer return in Acca, fraction return in AccB
		ld	y, #08523	; load scaling,	could be used for AFM bypass tweaks
		jsr	MulAbyY		; returns upper	16b in AccD
		add	d, #08523	; plus 1 offset
		ld	x, temp_51	; load MSW
		jsr	divDbyX		; takes	a scaled reciprocal to compensate for RPM*meanKSint decreasing with increasing load
		bra	main_16		; temp_51 now holds load.
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_15:				; CODE XREF: __RESET+284j
		ld	d, #0A000h	; absolute load	limit, limited above by	cmp y,75

main_16:				; CODE XREF: __RESET+29Fj
		st	d, temp_51	; temp_51 now holds load.
		ld	y, #0C2B8h	; load limiting	table
		jsr	TwoD_RPM	; lookup RPM, integer return in	Acca, fraction return in AccB
		cmp	d, temp_51
		ble	main_17		; choose smallest.
		ld	d, temp_51

main_17:				; CODE XREF: __RESET+2AEj
		mov	d, y		; assures minimum load for throttle above threshold + count_A7
		tbbs	bit0, flags_41,	main_18	; only time this is writ
		cmp	#030, RPM	; 1500RPM
		bcc	main_18		; only time this is writ
		ld	a, VTA_net
		cmp	a, #082
		bcs	main_18		; bounce if VTA_net is less than 82
		cmp	#025, count_A7	; incremented at F47D
		bcs	main_18		; only time this is writ
		cmp	y, #7800h	; default value, smaller than table output
		bgt	main_18		; only time this is writ
		ld	y, #7800h	; assert minimum value

main_18:				; CODE XREF: __RESET+2B3j __RESET+2B9j ...
		st	y, LOAD		; only time this is writ
		ld	a, rawTHA	; Contains the NOT of air temp reading from ADC, sensor	is tied	to ground on other side
		ld	y, #0C2CCh
		jsr	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB
		mov	a, b
		clr	a
		add	d, #00410
		mov	d, y		; Y holds conerted and offset air temp
		clr	a
		ld	b, ATM_press	; adc pin 17 - PCM atmospheric pressure	sensor,	debiased and scaled
		add	d, #00200
		jsr	MulDbyY		; returns upper	16 bits	in Y, lower 16 bits in D
		st	y, temp_51	; temp_51 contains air temp scaled by atmoshperic pressure
		shr	temp_52
		rorc	a
		rorc	b
		shr	temp_52
		rorc	a
		rorc	b
		shr	temp_52
		rorc	a
		rorc	b
		ld	x, #00190
		jsr	divDbyX		; divide D by X, does some shifting to return ?? bits
		st	a, byte_1A8	; air temp and baro compensation for load from AFM
		push	d
		ld	y, LOAD		; Load,	uncompensated for ThA
		jsr	MulDbyY		; returns upper	16 bits	in Y, lower 16 bits in D
		mov	y, d
		shl	d
		st	d, compLOAD	; only writ here
		pull	d
		shr	d
		shr	d
		shr	d
		shr	d
		shr	d
		shr	d
		mov	d, x
		ld	d, meanKSint	; deltaKS/KS_count, filtered
		jsr	divDbyX		; divide D by X, does some shifting to return ?? bits
		st	d, word_7A	; meanKSint divided by a air temp comp factor
		cmp	d, #00468
		bcs	main_19
		ld	#7Ah, count_BA	; decremented at F566

main_19:				; CODE XREF: __RESET+31Aj
		di
		ld	a, flags_77	; set bit 0, make decision based on bit	0
		mov	a, b
		or	a, #01h
		st	a, flags_77	; set bit 0
		ei
		cmpb	b, #01h
		beq	main_20
<<<<<<< HEAD
		jmp	main_36		; bounce if not	running
=======
		jmp	main_36
>>>>>>> origin/master
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_20:				; CODE XREF: __RESET+32Aj
		ld	d, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
<<<<<<< HEAD
		tbbs	bit7, flags_4C,	main_23	; bounce if not	running
=======
		tbbs	bit7, flags_4C,	main_23	; bit 7	demands	a sampling of the oxygen sensors
>>>>>>> origin/master
		push	a
		ld	a, flags_44	; bit 1	is igf1	related, bit2 igf2 related
		cmpb	a, #3Fh
		pull	a
		bne	main_23
		cmp	#00h, count_BA	; decremented at F566
		beq	main_23
		sub	d, avgCompLoad
		bcc	main_21
		bmi	main_22
		ld	d, #8000h
		bra	main_22
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_21:				; CODE XREF: __RESET+344j
		bpz	main_22
		ld	d, #7FFFh

main_22:				; CODE XREF: __RESET+346j __RESET+34Bj ...
		shra	a
		rorc	b
		shra	a
		rorc	b
		shra	a
		rorc	b
		shra	a
		rorc	b
		shra	a
		rorc	b
		shra	a
		rorc	b
		add	d, avgCompLoad

main_23:				; CODE XREF: __RESET+331j __RESET+33Aj ...
		st	d, avgCompLoad
		ld	d, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
		sub	d, avgCompLoad
		bcc	main_25
		add	a, #80h
		bcs	main_24
		clr	a

main_24:				; CODE XREF: __RESET+36Dj
<<<<<<< HEAD
		cmp	#079, count_5F	; counts up to 255 since last start, about 15 counts per second
=======
		cmp	#4Fh, count_5F	; counts up to 255 since last start, about 15 counts per second
>>>>>>> origin/master
		bcc	main_26
		ld	a, #80h
		bra	main_26
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_25:				; CODE XREF: __RESET+369j
		add	a, #80h
		bcc	main_26
		ld	a, #0FFh

main_26:				; CODE XREF: __RESET+373j __RESET+377j ...
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0E8h ; è
		.db  30h ; 0
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		st	a, byte_6D	; signed change	in load	from average
		cmp	a, #84h
		bcs	main_27
		clr	a
		st	a, unk_137
		st	a, unk_153

main_27:				; CODE XREF: __RESET+388j
		ld	a, #80h
		ld	b, ADC_pin16	; adc pin 16 (always 0)
		and	b, #0Ch
<<<<<<< HEAD
		beq	main_28		; will always be true
=======
		beq	main_28
>>>>>>> origin/master
		ld	a, #9Ah
		and	b, #08h
		beq	main_28
		ld	a, #73h

main_28:				; CODE XREF: __RESET+398j __RESET+39Ej
		mul	a, word_16E	; inversely temp dependant, additional math elsewhere
		shl	d
		st	a, temp_51
		push	a
		clrb	bit0, flags_40

main_29:				; CODE XREF: __RESET+3E1j
<<<<<<< HEAD
		jsr	sub_C8D9	; plays	with word_300, 302
=======
		jsr	sub_C8D9
>>>>>>> origin/master
		cmp	#227, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		rorc	a
		mul	a, temp_51
		shl	d
		bcc	main_30
		ld	a, #0FFh

main_30:				; CODE XREF: __RESET+3B5j
		push	a
		clr	b
		shr	d
		st	d, temp_51
		pull	a
		mul	a, byte_6D	; signed change	in load	from average
		sub	d, temp_51
		bcc	main_31
		shl	d
		add	a, #20h
		bcs	main_32
		clr	a
		clr	b
		bra	main_32
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_31:				; CODE XREF: __RESET+3C3j
		shl	d
		add	a, #20h

main_32:				; CODE XREF: __RESET+3C8j __RESET+3CCj
		shl	d
		bcc	main_33
		ld	d, #0FFFFh

main_33:				; CODE XREF: __RESET+3D2j
<<<<<<< HEAD
		tbs	bit0, flags_40	; B3 : forced timing to	5/10 deg BTDC
=======
		tbs	bit0, flags_40
>>>>>>> origin/master
		bne	main_34
		st	d, word_16A
		pull	a
		st	a, temp_51
		bra	main_29
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_34:				; CODE XREF: __RESET+3D9j
		st	d, word_16C
		ld	y, #0C54Ch
		ld	d, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
		jsr	DivDby12	; divides D by 12, returns 16b result in unks 53:54
		ld	d, RPM		; MSB is RPM/50, LSB is	fraction of 50
		jsr	ThreeDtable	; inputs in D and temp_53:temp_54, output in D
<<<<<<< HEAD
		tbbc	bit3, flags_45,	main_35	; store	table output
		add	a, #043

main_35:				; CODE XREF: __RESET+3F3j
		st	a, unk_199	; store	table output

main_36:				; CODE XREF: __RESET+276j __RESET+32Cj
		tbbs	bit7, flags_4C,	main_40	; bounce if not	running
=======
		tbbc	bit3, flags_45,	main_35	; IC303	input chip: B7 /TE2, B /TE1, B5	/NSW, B4 IGSW,	B3, B2 IDL2, B1	, B0 STA
		add	a, #043

main_35:				; CODE XREF: __RESET+3F3j
		st	a, unk_199	; output from 3d table c54c

main_36:				; CODE XREF: __RESET+276j __RESET+32Cj
		tbbs	bit7, flags_4C,	main_40	; bit 7	demands	a sampling of the oxygen sensors
>>>>>>> origin/master
		tbbs	bit0, flags_45,	main_40	; bounce if starting
		ld	a, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
		ld	y, #0C5DDh	; high voltage table
		cmp	#160, Bvolts	; 12.5V
		bcc	main_37
		ld	y, #0C5E2h	; low voltage table

main_37:				; CODE XREF: __RESET+409j
		jsr	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB
		st	d, temp_51	; load table output
		ld	d, InjectPW1	; pulsewidth for LEFT bank (odd	cyl), 4us/bit
		ld	y, RPM		; MSB is RPM/50, LSB is	fraction of 50
		jsr	MulDbyY		; looking at total fuel	rate here
		cmp	y, #02918
		bcs	main_38
		ld	d, #0FFFFh
		bra	main_39
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_38:				; CODE XREF: __RESET+41Ej
		ld	d, #05615
		jsr	MulDbyY		; returns upper	16 bits	in Y, lower 16 bits in D
		push	a
		mov	y, d
		mov	b, a
		pull	b		; gets the middle 16 bits

main_39:				; CODE XREF: __RESET+423j
		cmp	d, temp_51
		bcs	main_41

main_40:				; CODE XREF: __RESET:main_36j
					; __RESET+3FEj
		clrb	bit7, flags_4B
		bra	main_42
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_41:				; CODE XREF: __RESET+431j
		tbbs	bit7, flags_4B,	main_43
		cmp	#0C3h, count_A6	; incremented at F47D
		bcs	main_43
		setb	bit7, flags_4B

main_42:				; CODE XREF: __RESET+435j
		clr	count_A6	; incremented at F47D

main_43:				; CODE XREF: __RESET:main_41j
					; __RESET+43Dj
		clr	a
<<<<<<< HEAD
		tbbs	bit5, flags_45,	main_44	; IC303	input chip: B7 /TE2, B6	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
=======
		tbbs	bit5, flags_45,	main_44	; IC303	input chip: B7 /TE2, B /TE1, B5	/NSW, B4 IGSW,	B3, B2 IDL2, B1	, B0 STA
>>>>>>> origin/master
		ld	b, flags_44	; bit 1	is igf1	related, bit2 igf2 related
		and	b, #3Fh
		bne	main_44
		ld	b, unk_6C	; sort of a filtered, saturated	VTA_net
<<<<<<< HEAD
		cmp	b, #058
=======
		cmp	b, #3Ah
>>>>>>> origin/master
		bcc	main_44
		cmp	#072, RPM	; 3600 RPM
		bcc	main_45
		ld	a, unk_109
		cmpb	a, #08h
		beq	main_45
		cmp	b, #2Dh
		bgt	main_45
		ld	a, unk_D5
		bne	main_45
		ld	a, #1Ah

main_44:				; CODE XREF: __RESET+444j __RESET+44Bj ...
		st	a, unk_D5

main_45:				; CODE XREF: __RESET+456j __RESET+45Dj ...
		clr	a
		tbbs	bit0, flags_4D,	main_47
		ld	a, unk_102
		and	a, #07h
		ld	x, #0C479h
		add	x, a
		ld	a, x + 00h
		ld	b, unk_103
		cmp	b, #0C0h
		bcs	main_46
		ld	b, unk_101
		cmp	b, #03h
		bcs	main_46
		cmp	#0FAh, unk_F9
		bcs	main_47

main_46:				; CODE XREF: __RESET+47Fj __RESET+486j
		clr	a

main_47:				; CODE XREF: __RESET+46Cj __RESET+48Bj
		st	a, unk_187	; timing related
<<<<<<< HEAD
		ld	b, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
=======
		ld	b, flags_A2	; bit7:	VTA_net	high, bit4: VTA_net high
>>>>>>> origin/master
		ld	a, VTA_net
		cmp	a, #123
		bcs	main_48		; bounce if VTA_net is less than 123
		or	b, #10h		; set bit 4

main_48:				; CODE XREF: __RESET+497j
		cmp	a, #119
		bcc	main_49
		and	b, #0EFh	; clear	bit 4

main_49:				; CODE XREF: __RESET+49Dj
		and	b, #0BFh
		push	b
		ld	y, #0C321h
		jsr	TwoD_RPM	; lookup RPM, integer return in	Acca, fraction return in AccB
		pull	b
		cmp	a, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
		bcc	main_50
		or	b, #40h		; flags_A2 bit6	set when load exceeds a	certain	value

main_50:				; CODE XREF: __RESET+4ADj
		cmp	#037, VTA_net
		bcc	main_51		; branch if some throttle
		and	b, #7Fh		; clear	flags_A2 bit7

main_51:				; CODE XREF: __RESET+4B4j
		cmp	#041, VTA_net
		bcs	main_52
		or	b, #80h		; set flags_A2 bit7

main_52:				; CODE XREF: __RESET+4BBj
<<<<<<< HEAD
		st	b, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
=======
		st	b, flags_A2	; bit7:	VTA_net	high, bit4: VTA_net high
>>>>>>> origin/master
		ld	b, flags_183	; bit 0	set oer	1550 RPM, bit 1	set under 1700 RPM
		cmp	#028, RPM	; 1400 RPM
		bcc	main_53		; 1550 RPM
		and	b, #0FCh	; clear	bits 0,1

main_53:				; CODE XREF: __RESET+4C7j
		cmp	#031, RPM	; 1550 RPM
		bcc	main_54		; set bit 0
		and	b, #0FDh	; clear	bit 1
		bra	main_55
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_54:				; CODE XREF: __RESET+4CEj
		or	b, #01h		; set bit 0
		cmp	#034, RPM	; 1700 RPM
		bcs	main_55
		or	b, #02h		; set bit 1

main_55:				; CODE XREF: __RESET+4D2j __RESET+4D9j
		st	b, flags_183	; bit 0	set oer	1550 RPM, bit 1	set under 1700 RPM
		ld	a, unk_104	; timing related
<<<<<<< HEAD
		ld	x, word_170	; nonzero and decreasing from cold start
		cmp	x, #11ECh
		bcc	main_56
		ld	b, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
=======
		ld	x, word_170	; inversely temp dependant, additional math elsewhere
		cmp	x, #11ECh
		bcc	main_56
		ld	b, flags_A2	; bit7:	VTA_net	high, bit4: VTA_net high
>>>>>>> origin/master
		cmpb	b, #10h
		beq	main_56
		cmp	a, #0Fh
		bcc	main_56
		ld	a, #0Fh		; saturate a

main_56:				; CODE XREF: __RESET+4E9j __RESET+4EFj ...
		st	a, temp_51
		beq	main_61
		cmp	#210, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		bcs	main_61		; skip all this	extra math if COLD
<<<<<<< HEAD
		ld	a, byte_186	; subtracted from timing in NEsub
=======
		ld	a, byte_186	; timing related
>>>>>>> origin/master
		cmp	a, unk_187	; timing related
		bcc	main_57		; select largest
		ld	a, unk_187	; timing related

main_57:				; CODE XREF: __RESET+506j
<<<<<<< HEAD
		cmp	a, unk_197	; subtracted from timing in main loop
		bcc	main_58		; select largest
		ld	a, unk_197	; subtracted from timing in main loop

main_58:				; CODE XREF: __RESET+50Ej
		shr	a
		cmp	a, byte_18A	; subtracted from timing in NEsub
		bcc	main_59		; select largest
		ld	a, byte_18A	; subtracted from timing in NEsub
=======
		cmp	a, unk_197	; timing related
		bcc	main_58		; select largest
		ld	a, unk_197	; timing related

main_58:				; CODE XREF: __RESET+50Ej
		shr	a
		cmp	a, byte_18A	; timing related
		bcc	main_59		; select largest
		ld	a, byte_18A	; timing related
>>>>>>> origin/master

main_59:				; CODE XREF: __RESET+517j
		ld	b, unk_18D	; im thinking it's a net retard, summed from a number of positive vales then negated
		sub	b, #128		; 15 degrees
		bcc	main_60		; 54%
		neg	b
		add	a, b		; drop result in a

main_60:				; CODE XREF: __RESET+521j
		mul	a, #138		; 54%
		addc	a, #00h
		add	a, temp_51	; saturated unk_104 (maximum 0x0f)

main_61:				; CODE XREF: __RESET+4F9j __RESET+4FEj
		st	a, unk_D4	; timing related
		ld	y, #0C336h
		jsr	TwoD_rawTHW	; lookup Raw Water Temp, integer return	in Acca, fraction return in AccB
		clrb	bit0, flags_40
<<<<<<< HEAD
		tbbc	bit1, flags_45,	main_62	; IC303	input chip: B7 /TE2, B6	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		tbbs	bit5, flags_45,	main_62	; IC303	input chip: B7 /TE2, B6	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
=======
		tbbc	bit1, flags_45,	main_62	; IC303	input chip: B7 /TE2, B /TE1, B5	/NSW, B4 IGSW,	B3, B2 IDL2, B1	, B0 STA
		tbbs	bit5, flags_45,	main_62	; IC303	input chip: B7 /TE2, B /TE1, B5	/NSW, B4 IGSW,	B3, B2 IDL2, B1	, B0 STA
>>>>>>> origin/master
		tbbs	bit7, flags_41,	main_63	; B0 IDL1, b5 indidcates something about ram stats during last suspend

main_62:				; CODE XREF: __RESET+535j __RESET+538j
		setb	bit0, flags_40
		cmp	a, #1Ch
		bcc	main_63
		ld	a, #028

main_63:				; CODE XREF: __RESET+53Bj __RESET+542j
<<<<<<< HEAD
		tbbc	bit6, flags_4A,	main_64	; bits 6,5,4 are inherited from	109. 6 seems to	always be low when no sub throttle exists
=======
		tbbc	bit6, flags_4A,	main_64
>>>>>>> origin/master
		add	a, #020		; add 1000 RPM

main_64:				; CODE XREF: __RESET:main_63j
		st	a, temp_51
		ld	b, #0Ch
<<<<<<< HEAD
		tbbc	bit0, flags_40,	main_65	; B3 : forced timing to	5/10 deg BTDC
=======
		tbbc	bit0, flags_40,	main_65
>>>>>>> origin/master
		ld	b, #08h
		tbbs	bit6, flags_47,	main_65	; bit4:	high when hot (but how hot?)
		tbbs	bit7, flags_47,	main_65	; bit4:	high when hot (but how hot?)
		ld	b, #04h

main_65:				; CODE XREF: __RESET+54Fj __RESET+554j ...
		add	a, b
		st	a, temp_52
		ld	a, count_126	; from the plots it looks like it increments while the throttle	is closed
		ld	b, RPM		; MSB is RPM/50, LSB is	fraction of 50
		tbbc	bit0, flags_41,	main_70	; B0 IDL1, b5 indidcates something about ram stats during last suspend
		clr	count_A7	; incremented at F47D
		cmp	a, #7Ah
		bcs	main_66
		setb	bit7, flags_44

main_66:				; CODE XREF: __RESET+56Bj
		tbbc	bit4, flags_44,	main_67	; bit 1	is igf1	related, bit2 igf2 related
		cmp	b, temp_51
		bcc	main_69		; prevent gasso	among other things
		clrb	bit6, flags_47
		tbbs	bit3, flags_43,	main_76	; bit3:	AFM bad	bit4: rev limiter
		tbbc	bit4, flags_47,	main_76	; bit4:	high when hot (but how hot?)
		tbbc	bit1, flags_42,	main_76
		tbbs	bit0, flags_42,	main_76
		cmp	#05h, unk_5E	; could	be last	unk_100, or 0
		bcs	main_76
		di
		setb	bit6, flags_42
		clrb	bit5, flags_42
		ld	d, #00FEh
		st	d, word_193
		ei
		bra	main_76
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_67:				; CODE XREF: __RESET:main_66j
		cmp	b, temp_52
		bcc	main_68
		setb	bit7, flags_47
		bra	main_76
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_68:				; CODE XREF: __RESET+599j
		cmp	#122, count_A3	; incremented at F47D
		bcs	main_77

main_69:				; CODE XREF: __RESET+574j
		setb	bit4, flags_44	; prevent gasso	among other things
		bra	main_77
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_70:				; CODE XREF: __RESET+564j
		tbbc	bit4, flags_44,	main_71	; bit 1	is igf1	related, bit2 igf2 related
		setb	bit6, flags_47
		bra	main_72
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_71:				; CODE XREF: __RESET:main_70j
		cmp	b, temp_51
		bcc	main_72
		clrb	bit6, flags_47

main_72:				; CODE XREF: __RESET+5ADj __RESET+5B1j
		clrb	bit7, flags_47
		tbbc	bit7, flags_44,	main_73	; bit 1	is igf1	related, bit2 igf2 related
		cmp	a, #7Ah
		bcs	main_73
<<<<<<< HEAD
		tbbs	bit7, flags_4C,	main_73	; bounce if not	running
=======
		tbbs	bit7, flags_4C,	main_73	; bit 7	demands	a sampling of the oxygen sensors
>>>>>>> origin/master
		cmp	#040, RPM	; 2000 RPM
		bcc	main_73		; bounce is greater than 2000 RPM
		ld	a, flags_44	; bit 1	is igf1	related, bit2 igf2 related
		cmpb	a, #00001110b
		bne	main_73
		ld	d, #00250	; 1ms burst
		jsr	DoAllInj

main_73:				; CODE XREF: __RESET+5B7j __RESET+5BCj ...
		clr	a
		st	a, count_126	; cleared here
		clrb	bit7, flags_44
		clr	count_A3	; incremented at F47D
		clrb	bit4, flags_44
		cmp	#036, RPM	; 1800RPM
		bcs	main_74
		setb	bit4, flags_42

main_74:				; CODE XREF: __RESET+5DFj
		ld	d, #0FF49h
		cmp	#19h, unk_5E	; could	be last	unk_100, or 0
		bcs	main_75
		ld	d, #0F545h

main_75:				; CODE XREF: __RESET+5E9j
		st	d, unk_17A

main_76:				; CODE XREF: __RESET+578j __RESET+57Bj ...
		clr	count_A3	; incremented at F47D
		clrb	bit4, flags_44

main_77:				; CODE XREF: __RESET+5A2j __RESET+5A6j
		clrb	bit0, flags_40
		ld	y, #012Dh
		jsr	sub_C64D	; called with either 12D or 149	in Y
		setb	bit0, flags_40
		ld	y, #0149h
		jsr	sub_C64D	; called with either 12D or 149	in Y
		ld	y, #0098h	; not sure block
		bsr	subrDAD4
		bne	main_78
		ld	y, #009Ch	; not sure block
		bsr	subrDAD4
		bne	main_78
		ld	y, #009Ah	; not sure block
		bsr	subrDAD4
		beq	main_79

main_78:				; CODE XREF: __RESET+60Aj __RESET+611j
		clr	a
		jmp	main_101
; END OF FUNCTION CHUNK	FOR __RESET
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

subrDAD4:				; CODE XREF: __RESET+608p __RESET+60Fp ...
		ld	d, y + 00h
		xor	b, #0FFh
		cmp	a, b
		bne	sub2DAD4
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0B3h ; ³
		.db  66h ; f
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		bcc	retDAD4

sub2DAD4:				; CODE XREF: ROM:DAD9j
		ld	a, #80h
		mov	a, b

retDAD4:				; CODE XREF: ROM:DAE0j
		xor	b, #0FFh
		st	d, y + 00h
		cmp	d, y + 00h
		ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR __RESET

main_79:				; CODE XREF: __RESET+618j
		ld	d, unk_140	; bits 5,0 oxl2	related
		and	a, unk_15C	; bits 5,0 oxr2	related
		cmpb	a, #02h
		beq	main_80
<<<<<<< HEAD
		ld	d, word_170	; nonzero and decreasing from cold start
=======
		ld	d, word_170	; inversely temp dependant, additional math elsewhere
>>>>>>> origin/master
		bne	main_80
		tbbs	bit2, PORTD_ASRIN, main_80 ; Port D Data Register / ASR	Input Data
		cmp	#0DCh, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		bcs	main_80
		cmp	#0ECh, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		ble	main_83

main_80:				; CODE XREF: __RESET+63Ej __RESET+643j ...
		clrb	bit2, flags_4B

main_81:				; CODE XREF: __RESET+668j __RESET+66Dj ...
		clr	a
		clrb	bit2, flags_42

main_82:				; CODE XREF: __RESET+693j
		st	a, unk_D8
		jmp	main_99
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_83:				; CODE XREF: __RESET+650j
		setb	bit2, flags_4B
		ld	a, unk_D8
		ld	x, word_7A	; meanKSint divided by a air temp comp factor
		tbbc	bit7, flags_44,	main_84	; bit 1	is igf1	related, bit2 igf2 related
		cmp	#02h, unk_5E	; could	be last	unk_100, or 0
		bcc	main_81
		cmp	x, #1C19h
		bcs	main_81
		ld	#40h, temp_51
		bra	main_85
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_84:				; CODE XREF: __RESET+662j
		cmp	#02h, unk_5E	; could	be last	unk_100, or 0
		bcs	main_81
		cmp	x, #0A76h
		bgt	main_81
		cmp	x, #056Eh
		bcs	main_81
		ld	#80h, temp_51

main_85:				; CODE XREF: __RESET+672j
		cmpb	a, temp_51
		bne	main_86
		clr	a
		or	a, temp_51

main_86:				; CODE XREF: __RESET+688j
		push	a
		and	a, #1Bh
		cmp	a, #1Bh
		pull	a
		bne	main_82
		and	a, #0C0h
		st	a, unk_D8
		shl	a
		ld	d, unk_176
		bcc	main_90
		clrb	bit2, flags_42
		cmp	a, b
		bgt	main_87
		inc	a
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  41h ; A		; brn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_87:				; CODE XREF: __RESET+6A2j
		dec	a
		st	a, unk_176
		mov	b, a
		clr	b
		jsr	SaturateData
		st	d, [y]
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  76h ; v
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		bcc	main_88
		inc	b
		cmpz	a
		bmi	main_88
		neg	b

main_88:				; CODE XREF: __RESET+6B1j __RESET+6B5j
<<<<<<< HEAD
		add	b, word_98	; 128 for entire superrun
=======
		add	b, word_98
>>>>>>> origin/master
		mov	b, a
		ld	b, word_9C
		sub	b, #0Fh
		cmp	a, b
		bcc	main_89
		mov	b, a

main_89:				; CODE XREF: __RESET+6C0j
		bsr	sub_DB80
<<<<<<< HEAD
		st	d, word_98	; 128 for entire superrun
=======
		st	d, word_98
>>>>>>> origin/master
		jmp	main_99
; END OF FUNCTION CHUNK	FOR __RESET

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_DB80:				; CODE XREF: __RESET:main_89p
					; __RESET:main_93p ...
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 179
		.db 102
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		mov	a, b
		xor	b, #0FFh
		ret
; End of function sub_DB80

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR __RESET

main_90:				; CODE XREF: __RESET+69Dj
		tbs	bit2, flags_42
		bne	main_91
		mov	d, y
		ld	a, word_98	; 128 for entire superrun
		sub	a, #0Fh
		st	a, unk_180
		ld	a, word_9C
		sub	a, #0Fh
		st	a, unk_181
		ld	a, word_9A
		sub	a, #0Fh
		st	a, unk_182
		mov	y, d

main_91:				; CODE XREF: __RESET+6D5j
		ld	#01h, temp_51
		cmp	a, #76h
		bcs	main_94
		neg	temp_51
		cmp	a, #8Ah
		bgt	main_94
		mov	b, a
		clr	b
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  8Ah ; Š
		.db  76h ; v
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		bcc	main_92
		ld	b, #04h
		cmpz	a
		bmi	main_92
		neg	b

main_92:				; CODE XREF: __RESET+702j __RESET+707j
		add	b, word_9A
		ld	a, unk_182
		cmp	a, b
		bcc	main_93
		mov	b, a

main_93:				; CODE XREF: __RESET+710j
		bsr	sub_DB80
		st	d, word_9A
		bra	main_99
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_94:				; CODE XREF: __RESET+6F3j __RESET+6F9j
		xor	b, temp_51
		bmi	main_99
		ld	a, unk_176
		add	a, temp_51
		st	a, unk_176
		neg	temp_51
		ld	a, word_98	; 128 for entire superrun
		add	a, temp_51
		ld	b, unk_180
		cmp	a, b
		bcc	main_95
		mov	b, a

main_95:				; CODE XREF: __RESET+72Fj
		bsr	sub_DB80
		st	d, word_98	; 128 for entire superrun
		mov	a, b
		shl	temp_51
		bcs	main_96
		sub	b, word_9C
		bcs	main_99
		bra	main_97
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_96:				; CODE XREF: __RESET+739j
		sub	b, word_9C
		bcc	main_99

main_97:				; CODE XREF: __RESET+73Fj
		add	a, word_9C
		rorc	a
		add	a, word_9C
		rorc	a
		ld	b, unk_181
		cmp	a, b
		bcc	main_98
		mov	b, a

main_98:				; CODE XREF: __RESET+74Fj
		jsr	sub_DB80
		st	d, word_9C

main_99:				; CODE XREF: __RESET+659j __RESET+6C7j ...
		ld	y, #0C246h
		jsr	TwoD_7A		; Lookup unk_7A, integer return	in Acca, fraction return in AccB
		setc
		rorc	a
		mul	a, #29h
		st	a, temp_51
		ld	d, word_7A	; meanKSint divided by a air temp comp factor
		div	d, temp_51
		bcc	main_100
		ld	b, #0FFh

main_100:				; CODE XREF: __RESET+767j
		st	b, temp_51
		ld	a, word_9A
		mul	a, temp_51
		shr	temp_51
		sub	a, temp_51

main_101:				; CODE XREF: __RESET+61Bj
		st	a, unk_175
		setb	bit2, flags_4A
		ld	a, RPM		; MSB is RPM/50, LSB is	fraction of 50
		di
		ld	x, threeDeltaNE
		cmp	x, #00568	; rev limit
		bcs	main_103	; inhibit injection, rev limiter style
		ld	b, unk_17D
		bpz	main_102
		cmp	a, #050		; 2500 RPM
		bcc	main_103	; inhibit injection, rev limiter style
		cmp	a, #030
		bcc	main_104	; 1500 RPM

main_102:				; CODE XREF: __RESET+787j
		clrb	bit3, flags_44
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  8Ch ; Œ		; three	byte NOP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_103:				; CODE XREF: __RESET+782j __RESET+78Bj
		setb	bit3, flags_44	; inhibit injection, rev limiter style

main_104:				; CODE XREF: __RESET+78Fj
		ei
		clr	a
<<<<<<< HEAD
		tbbs	bit7, flags_4C,	fuel_106 ; bounce if not running
		tbbs	bit0, flags_41,	fuel_106 ; bounce if IDL1
=======
		tbbs	bit7, flags_4C,	main_106 ; bit 7 demands a sampling of the oxygen sensors
		tbbs	bit0, flags_41,	main_106 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
>>>>>>> origin/master
		ld	y, #0C5C3h
		jsr	TwoD_7A		; Lookup unk_7A, integer return	in Acca, fraction return in AccB
		st	a, temp_51
		ld	y, #0C5D2h
		jsr	TwoD_rawTHW	; lookup Raw Water Temp, integer return	in Acca, fraction return in AccB
		ld	b, temp_51
		cmp	a, b
		ble	main_105
		mov	b, a

main_105:				; CODE XREF: __RESET+7AFj
		shr	a
		shr	a
		shr	a
		addc	a, #00h

<<<<<<< HEAD
fuel_106:				; CODE XREF: __RESET+798j __RESET+79Bj
		st	a, unk_1B0
		tbbc	bit7, flags_4C,	main_110 ; bounce if running
		cmp	#008, RPM	; 400 RPM
		bcs	main_111
		clrb	bit7, flags_4C	; clear	bit 7 if >400RPM
=======
main_106:				; CODE XREF: __RESET+798j __RESET+79Bj
		st	a, unk_1B0
		tbbc	bit7, flags_4C,	main_110 ; 300 RPM
		cmp	#008, RPM	; 400 RPM
		bcs	main_111
		clrb	bit7, flags_4C
>>>>>>> origin/master
		clrb	bit2, DOUT
		ld	y, #0C2EFh
		jsr	TwoD_rawTHW	; lookup Raw Water Temp, integer return	in Acca, fraction return in AccB
		st	d, word_170	; nonzero and decreasing from cold start
		ld	y, #0C2FFh
		jsr	TwoD_rawTHW	; bottoms out at 13 when temp is 210
		shr	d
		shr	d
<<<<<<< HEAD
		st	d, word_172	; nonzero and rapidly decreasing after start, larger peak from cold start
		cmp	#020, VTA_net	; is this the starting mode WOT	enrichment? it's 50%!!!
=======
		st	d, word_172	; inversely temp dependant, additional math elsewhere
		cmp	#020, VTA_net
>>>>>>> origin/master
		bcc	main_107
		mul	a, #80h
		bra	main_108
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_107:				; CODE XREF: __RESET+7DDj
		mul	a, #0C0h

main_108:				; CODE XREF: __RESET+7E1j
		shl	d
		shl	d
		cmp	a, #0FFh
		bcs	main_109
		ld	a, #0FFh

main_109:				; CODE XREF: __RESET+7E9j
		st	a, unk_174
		ld	y, #0C30Ah
		jsr	TwoD_rawTHW	; lookup Raw Water Temp, integer return	in Acca, fraction return in AccB
		st	d, word_16E	; inversely temp dependant, additional math elsewhere
		setb	bit2, DOUT
		bra	main_115
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_110:				; CODE XREF: __RESET+7BAj
		cmp	#006, RPM	; 300 RPM
		bcc	main_112	; 10V
<<<<<<< HEAD
		setb	bit7, flags_4C	; set bit 7 if below 300 RPM
=======
		setb	bit7, flags_4C
>>>>>>> origin/master

main_111:				; CODE XREF: __RESET+7C0j
		clr	count_CD	; incremented at E7A9
		clr	a
		st	a, unk_1BB

main_112:				; CODE XREF: __RESET+800j
		cmp	#128, Bvolts	; 10V
		bcs	main_113
		tbbs	bit0, flags_45,	main_113 ; bounce if starting
<<<<<<< HEAD
		tbbc	bit7, flags_4C,	main_114 ; bounce if running
=======
		tbbc	bit7, flags_4C,	main_114 ; bit 7 demands a sampling of the oxygen sensors
>>>>>>> origin/master

main_113:				; CODE XREF: __RESET+80Dj __RESET+80Fj
		setb	bit6, flags_49
		clr	a
		st	a, count_178	; tof increment	rate
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  8Ch ; Œ		; cmpx
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_114:				; CODE XREF: __RESET+812j
		clrb	bit6, flags_49

main_115:				; CODE XREF: __RESET+7FBj
		jsr	sub_C634
		ld	y, #0C2B1h
		jsr	TwoD_rawTHW	; lookup Raw Water Temp, integer return	in Acca, fraction return in AccB
		st	a, temp_51
		ld	d, word_172	; nonzero and rapidly decreasing after start, larger peak from cold start
		shl	d
		bcs	main_116
		add	a, #128
		bcc	main_117

main_116:				; CODE XREF: __RESET+82Dj
		ld	a, #0FFh

main_117:				; CODE XREF: __RESET+831j
		mul	a, temp_51
		ld	b, ADC_pin16	; adc pin 16 (always 0)
		shr	b
		bcc	main_118
		add	a, #008		; add a	bit more to D3 fuel addition

main_118:				; CODE XREF: __RESET+83Bj
		st	a, unk_D3	; multiplied by	16 and used for	injectors
		clrb	bit0, flags_40

<<<<<<< HEAD
fuel_119:				; CODE XREF: __RESET+9C3j
		tbbc	bit7, flags_4C,	fuel_121 ; bounce if running
		tbbs	bit3, flags_43,	fuel_120 ; bounce if AFM bad
		tbbc	bit4, flags_47,	fuel_120 ; bounce if coolant is	cold
		tbbc	bit0, flags_45,	fuel_121 ; bounce if NOT starting

fuel_120:				; CODE XREF: __RESET+846j __RESET+849j ...
		setb	bit1, flags_46	; abnormal program path	while DD0F is normal.
=======
main_119:				; CODE XREF: __RESET+9C3j
		tbbc	bit7, flags_4C,	main_121 ; used	here for injection PW calculation
		tbbs	bit3, flags_43,	main_120 ; is this an abnormal program path while DD0F is normal?
		tbbc	bit4, flags_47,	main_120 ; is this an abnormal program path while DD0F is normal?
		tbbc	bit0, flags_45,	main_121 ; bounce if NOT starting

main_120:				; CODE XREF: __RESET+846j __RESET+849j ...
		setb	bit1, flags_46	; is this an abnormal program path while DD0F is normal?
>>>>>>> origin/master
		jsr	calcInjPW	; calculate the	pulsewidths
		clr	count_AB	; incremented at F47D
		jmp	main_144	; assign pulsewidth
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

<<<<<<< HEAD
fuel_121:				; CODE XREF: __RESET:fuel_119j
					; __RESET+84Cj
		ld	y, compLOAD	; used here for	injection PW calculation
		tbbc	bit3, flags_43,	fuel_124 ; ;;;;;;;;;;;;;;bounce	if AFM is good
		ld	d, VTA_net
		cmp	d, #04194	; WOT check
		ble	fuel_122	; Alpha-N injection routine
=======
main_121:				; CODE XREF: __RESET:main_119j
					; __RESET+84Cj
		ld	y, compLOAD	; used here for	injection PW calculation
		tbbc	bit3, flags_43,	main_124 ; bounce if AFM is good
		ld	d, VTA_net
		cmp	d, #04194
		ble	main_122	; Alpha-N injection routine
>>>>>>> origin/master
		add	d, #12583	; is around 4194*3
		shr	d
		shr	d

<<<<<<< HEAD
fuel_122:				; CODE XREF: __RESET+863j
=======
main_122:				; CODE XREF: __RESET+863j
>>>>>>> origin/master
		ld	x, #01049	; Alpha-N injection routine
		jsr	divDbyX		; divide D by X, does some shifting to return ?? bits
		st	d, temp_53
		ld	d, RPM		; MSB is RPM/50, LSB is	fraction of 50
		ld	y, #0C26Ch
		jsr	ThreeDtable2	; inputs in D and temp_53:temp_54, output in D
<<<<<<< HEAD
		st	d, temp_56	; store	output of TPS vs RPM table (alpha-N table)
=======
		st	d, temp_56
>>>>>>> origin/master
		ld	y, #0C2A8h
		ld	a, unk_DB	; magic	from address 0x80
		jsr	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB
		push	d
		ld	d, RPM		; MSB is RPM/50, LSB is	fraction of 50
		shr	d
		shr	d
		mov	d, x
		pull	d
<<<<<<< HEAD
		cmp	x, #00256	; 200 RPM, x is	now 200	rpm/bit
		bcs	fuel_120	; bounce if barely running
		jsr	divDbyX		; divide D by X, does some shifting to return ?? bits
		shl	d
		bcc	fuel_123
		ld	d, #0FFFFh

fuel_123:				; CODE XREF: __RESET+894j
		mov	d, y

fuel_124:				; CODE XREF: __RESET+85Bj
		ld	d, ScaleFactor	; about	65 percent
		jsr	MulDbyY		; returns upper	16 bits	in Y, lower 16 bits in D
		tbbc	bit3, flags_43,	fuel_126 ; ;;;;;;;;;;;;;;;;;;;;bounce if AFM good
		mov	y, d
		add	d, temp_56	; add value from TPS/RPM 3d table
		bcc	fuel_125
		ld	d, #0FFFFh

fuel_125:				; CODE XREF: __RESET+8A6j
		mov	d, y

fuel_126:				; CODE XREF: __RESET+8A0j
		push	y		; push the load	based pulsewidth
		ld	x, #0C33Bh
		tbbc	bit6, flags_4A,	fuel_127 ; branch to compare pw	to 7.2ms - will	always be true it seems
=======
		cmp	x, #00256
		bcs	main_120	; bounce if barely running
		jsr	divDbyX		; divide D by X, does some shifting to return ?? bits
		shl	d
		bcc	main_123
		ld	d, #0FFFFh

main_123:				; CODE XREF: __RESET+894j
		mov	d, y

main_124:				; CODE XREF: __RESET+85Bj
		ld	d, ScaleFactor	; about	65 percent
		jsr	MulDbyY		; returns upper	16 bits	in Y, lower 16 bits in D
		tbbc	bit3, flags_43,	main_126 ; bounce if AFM good
		mov	y, d
		add	d, temp_56	; add value from TPS/RPM 3d table
		bcc	main_125
		ld	d, #0FFFFh

main_125:				; CODE XREF: __RESET+8A6j
		mov	d, y

main_126:				; CODE XREF: __RESET+8A0j
		push	y		; push the load	based pulsewidth
		ld	x, #0C33Bh
		tbbc	bit6, flags_4A,	main_127 ; branch to limit pw to 7.2ms
>>>>>>> origin/master
		ld	b, #04h
		add	x, b		; compare pw to	16ms

<<<<<<< HEAD
fuel_127:				; CODE XREF: __RESET+8B0j
		cmp	y, x + 00h
		bcc	fuel_128
		cmp	#029, RPM	; 1450 RPM
		bcs	fuel_128	; branch if RPM	lower
		cmp	#098, count_AB	; incremented at F47D
		bcs	fuel_131
		setb	bit0, flags_44
		bra	fuel_131
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fuel_128:				; CODE XREF: __RESET+8B8j __RESET+8BDj
		cmp	y, x + 02h
		bcc	fuel_129
		cmp	#028, RPM	; 1400 RPM
		bcc	fuel_131

fuel_129:				; CODE XREF: __RESET+8CAj
		tbbc	bit0, flags_44,	fuel_130 ; bit 1 is igf1 related, bit2 igf2 related
		clrb	bit0, flags_44
		tbbc	bit6, flags_4A,	fuel_130 ; bits	6,5,4 are inherited from 109. 6	seems to always	be low when no sub throttle exists
		cmp	y, x + 02h
		bcs	fuel_130
		tbbs	bit3, flags_43,	fuel_130 ; bit3: AFM bad bit4: rev limiter
		tbbc	bit4, flags_47,	fuel_130 ; bit4: high when hot (but how	hot?)
		tbbs	bit0, flags_42,	fuel_130
		cmp	#05h, unk_5E	; could	be last	unk_100, or 0
		bcs	fuel_130
=======
main_127:				; CODE XREF: __RESET+8B0j
		cmp	y, x + 00h
		bcc	main_128
		cmp	#029, RPM	; 1450 RPM
		bcs	main_128	; branch if RPM	lower
		cmp	#098, count_AB	; incremented at F47D
		bcs	main_131
		setb	bit0, flags_44
		bra	main_131
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_128:				; CODE XREF: __RESET+8B8j __RESET+8BDj
		cmp	y, x + 02h
		bcc	main_129
		cmp	#028, RPM	; 1400 RPM
		bcc	main_131

main_129:				; CODE XREF: __RESET+8CAj
		tbbc	bit0, flags_44,	main_130 ; bit 1 is igf1 related, bit2 igf2 related
		clrb	bit0, flags_44
		tbbc	bit6, flags_4A,	main_130
		cmp	y, x + 02h
		bcs	main_130
		tbbs	bit3, flags_43,	main_130 ; bit3: AFM bad bit4: rev limiter
		tbbc	bit4, flags_47,	main_130 ; bit4: high when hot (but how	hot?)
		tbbs	bit0, flags_42,	main_130
		cmp	#05h, unk_5E	; could	be last	unk_100, or 0
		bcs	main_130
>>>>>>> origin/master
		di
		setb	bit6, flags_42
		setb	bit5, flags_42
		ld	d, #00D3h
		st	d, word_193
		ei

<<<<<<< HEAD
fuel_130:				; CODE XREF: __RESET:fuel_129j
					; __RESET+8D6j	...
		clr	count_AB	; incremented at F47D

fuel_131:				; CODE XREF: __RESET+8C2j __RESET+8C6j ...
=======
main_130:				; CODE XREF: __RESET:main_129j
					; __RESET+8D6j	...
		clr	count_AB	; incremented at F47D

main_131:				; CODE XREF: __RESET+8C2j __RESET+8C6j ...
>>>>>>> origin/master
		ld	y, #0C31Ch
		jsr	TwoD_rawTHW	; bottoms out at thw=234 returning a value of 48, otherwise returns values higher with colder temps
		push	a
		ld	y, #0C2FAh
		jsr	TwoD_RPM	; saturates until 1500RPM, slopes down to 154 at 3500RPM
		ld	y, word_170	; nonzero and decreasing from cold start
		jsr	MulAbyY		; returns upper	16b in AccD
		add	a, #128
		mov	d, x
		ld	a, unk_D5	; zero during entire superrun
		clr	b
		shr	d
		st	d, temp_51
		ld	d, word_16A
<<<<<<< HEAD
		tbbc	bit0, flags_40,	fuel_132 ; B3 :	forced timing to 5/10 deg BTDC
		ld	d, word_16C

fuel_132:				; CODE XREF: __RESET+918j
		add	d, temp_51
		bcc	fuel_133
		ld	d, #0FFFFh

fuel_133:				; CODE XREF: __RESET+920j
		shr	d
		st	d, temp_51
		ld	a, unk_D4	; zero during entire superrun
		beq	fuel_134
		tbbs	bit0, flags_40,	fuel_134 ; B3 :	forced timing to 5/10 deg BTDC
		add	a, #03h

fuel_134:				; CODE XREF: __RESET+92Aj __RESET+92Cj
=======
		tbbc	bit0, flags_40,	main_132
		ld	d, word_16C

main_132:				; CODE XREF: __RESET+918j
		add	d, temp_51
		bcc	main_133
		ld	d, #0FFFFh

main_133:				; CODE XREF: __RESET+920j
		shr	d
		st	d, temp_51
		ld	a, unk_D4	; timing related
		beq	main_134
		tbbs	bit0, flags_40,	main_134
		add	a, #03h

main_134:				; CODE XREF: __RESET+92Aj __RESET+92Cj
>>>>>>> origin/master
		clr	b
		shr	d
		add	d, word_172	; nonzero and rapidly decreasing after start, larger peak from cold start
		add	a, unk_174
		rorc	a
		rorc	b
		add	d, temp_51
<<<<<<< HEAD
		bcc	fuel_135
		pull	a		; pushed from ddb5
		bra	fuel_137
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fuel_135:				; CODE XREF: __RESET+93Dj
=======
		bcc	main_135
		pull	a		; pushed from ddb5
		bra	main_137
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_135:				; CODE XREF: __RESET+93Dj
>>>>>>> origin/master
		xch	x, y
		jsr	MulDbyY		; returns upper	16 bits	in Y, lower 16 bits in D
		pull	a		; pushed from ddb5
		st	a, temp_51
		mov	y, d
		shl	d
<<<<<<< HEAD
		bcs	fuel_136
		cmp	a, temp_51
		bcs	fuel_138

fuel_136:				; CODE XREF: __RESET+94Bj
		ld	a, temp_51

fuel_137:				; CODE XREF: __RESET+940j
		clr	b

fuel_138:				; CODE XREF: __RESET+94Fj
		cmp	d, #00819
		bcc	fuel_139
		ld	d, #00819	; establish minimum

fuel_139:				; CODE XREF: __RESET+957j
=======
		bcs	main_136
		cmp	a, temp_51
		bcs	main_138

main_136:				; CODE XREF: __RESET+94Bj
		ld	a, temp_51

main_137:				; CODE XREF: __RESET+940j
		clr	b

main_138:				; CODE XREF: __RESET+94Fj
		cmp	d, #0333h
		bcc	main_139
		ld	d, #00819	; establish minimum

main_139:				; CODE XREF: __RESET+957j
>>>>>>> origin/master
		mov	d, y
		nop
		nop
		nop
		nop
		nop			; whaaaaaaa....?
		nop
		nop
		nop
		nop
		nop
		nop
<<<<<<< HEAD
		ld	d, unk_12E	; closed loop fuel adjustments?
		tbbc	bit0, flags_40,	fuel_140 ; B3 :	forced timing to 5/10 deg BTDC
		ld	d, unk_14A	; closed loop fuel adjustments (other bank)?

fuel_140:				; CODE XREF: __RESET+96Bj
		jsr	sub_C8BB	; feels	like it	acounts	for oxygen sensor correction
=======
		ld	d, unk_12E
		tbbc	bit0, flags_40,	main_140
		ld	d, unk_14A

main_140:				; CODE XREF: __RESET+96Bj
		jsr	sub_C8BB
>>>>>>> origin/master
		jsr	MulDbyY		; returns upper	16 bits	in Y, lower 16 bits in D
		shl	d
		mov	y, d
		rolc	b
<<<<<<< HEAD
		rolc	a		; D should now contain ratio to	adjust feed forward pulsewidth by
		pull	y		; pushed from dd62, this is compLOAD based pulsewidth
		bcs	fuel_141
		jsr	MulDbyY		; returns upper	16 bits	in Y, lower 16 bits in D

fuel_141:				; CODE XREF: __RESET+97Cj
=======
		rolc	a
		pull	y		; pushed from dd62, this is compLOAD based pulsewidth
		bcs	main_141
		jsr	MulDbyY		; returns upper	16 bits	in Y, lower 16 bits in D

main_141:				; CODE XREF: __RESET+97Cj
>>>>>>> origin/master
		st	y, temp_51
		ld	d, threeDeltaNE
		shl	d
		shl	d
<<<<<<< HEAD
		bcs	fuel_142	; engine running too slow, limit need not be applied
		shl	d		; 24 delta NE, 1 otto cycle
		bcs	fuel_142	; engine running too slow, limit need not be applied
		cmp	d, temp_51
		bcc	fuel_142
		st	d, temp_51	; limit	injector pw to 2 crank revolutions

fuel_142:				; CODE XREF: __RESET+987j __RESET+98Aj ...
		tbbc	bit1, flags_46,	fuel_145 ; bit 1 flags limp in injection mode, B5 RPM under 5200ish
=======
		bcs	main_142	; engine running too slow, limit need not be applied
		shl	d		; 24 delta NE, 1 otto cycle
		bcs	main_142	; engine running too slow, limit need not be applied
		cmp	d, temp_51
		bcc	main_142
		st	d, temp_51	; limit	injector pw to 2 crank revolutions

main_142:				; CODE XREF: __RESET+987j __RESET+98Aj ...
		tbbc	bit1, flags_46,	main_145 ; bit 1 flags limp in injection mode
>>>>>>> origin/master
		di
		ld	a, flags_77	; set bit 5, make a decision on	bit 5
		mov	a, b
		or	a, #20h
		st	a, flags_77	; set bit 5
		ei
		cmpb	b, #20h
<<<<<<< HEAD
		beq	fuel_143	; weird	90% test, keepin' it rich baby!
		jmp	fuel_147	; skip applying	newly calulated	value
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fuel_143:				; CODE XREF: __RESET+9A0j
=======
		beq	main_143	; weird	90% test, keepin' it rich baby!
		jmp	main_147	; skip applying	newly calulated	value
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_143:				; CODE XREF: __RESET+9A0j
>>>>>>> origin/master
		ld	y, InjectPW1	; pulsewidth for LEFT bank (odd	cyl), 4us/bit
		ld	a, #230		; fraction of 90% in this case
		jsr	MulAbyY		; returns upper	16b in AccD
		cmp	d, temp_51
		bcc	main_144	; bounce if 90%	of InjectPW1 is	bigger than unk_51
		clrb	bit1, flags_46
		ld	d, temp_51	; select unk_51	because	it was bigger

main_144:				; CODE XREF: __RESET+856j __RESET+9AFj
		st	d, InjectPW1	; pulsewidth for LEFT bank (odd	cyl), 4us/bit
<<<<<<< HEAD
		bra	fuel_146
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fuel_145:				; CODE XREF: __RESET:fuel_142j
		ld	d, temp_51
		tbs	bit0, flags_40	; B3 : forced timing to	5/10 deg BTDC
		bne	fuel_146
		st	d, InjectPW1	; =unk_51
		jmp	fuel_119	; bounce if running
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fuel_146:				; CODE XREF: __RESET+9B8j __RESET+9BEj
		st	d, InjectPW2	; pulsewidth for RIGHT bank (even cyl),	4us/bit

fuel_147:				; CODE XREF: __RESET+9A2j
		ld	b, #018
		tbbs	bit7, flags_4C,	main_151 ; bounce if not running
=======
		bra	main_146
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_145:				; CODE XREF: __RESET:main_142j
		ld	d, temp_51
		tbs	bit0, flags_40
		bne	main_146
		st	d, InjectPW1	; =unk_51
		jmp	main_119
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_146:				; CODE XREF: __RESET+9B8j __RESET+9BEj
		st	d, InjectPW2	; pulsewidth for RIGHT bank (even cyl),	4us/bit

main_147:				; CODE XREF: __RESET+9A2j
		ld	b, #018
		tbbs	bit7, flags_4C,	main_151 ; bit 7 demands a sampling of the oxygen sensors
>>>>>>> origin/master
		ld	d, InjDeadtime	; injector deadtime, 4us/bit
		add	d, #01618	; 6472us
		add	d, InjectPW1	; pulsewidth for LEFT bank (odd	cyl), 4us/bit
		bcs	main_148
		shl	d
		bcc	main_149

main_148:				; CODE XREF: __RESET+9D7j
		ld	d, #0FFFFh

main_149:				; CODE XREF: __RESET+9DAj
		mov	d, y
		ld	a, RPM		; MSB is RPM/50, LSB is	fraction of 50
		jsr	MulAbyY		; returns upper	16b in AccD
		sub	d, #04655
		bcs	main_150
		clr	a
		clr	b

main_150:				; CODE XREF: __RESET+9E8j
		neg	a
		neg	b
		subc	a, #00h
		div	d, #195

main_151:				; CODE XREF: __RESET+9CBj
		cmp	b, #007
		bcc	main_152
		ld	b, #007		; lower	bound on 110

main_152:				; CODE XREF: __RESET+9F4j
		st	b, byte_110	; 7 to 23, highest at lowest fuel flow
		tbbc	bit5, RAMST, main_155 ;	Built-in RAM status
		di			; =====================interrupt sensitive
		ld	d, word_80
		xor	b, #0FFh
		cmp	a, b
		beq	main_153
<<<<<<< HEAD
		cmp	a, unk_DB	; magic	from address 0x80
		beq	main_153
		mov	b, a
		cmp	a, unk_DB	; magic	from address 0x80
		beq	main_153
		ld	a, unk_DB	; magic	from address 0x80
=======
		cmp	a, unk_DB
		beq	main_153
		mov	b, a
		cmp	a, unk_DB
		beq	main_153
		ld	a, unk_DB
>>>>>>> origin/master
		setb	bit3, flags_48
		setb	bit4, flags_48

main_153:				; CODE XREF: __RESET+A04j __RESET+A08j ...
		cmp	a, #7Dh
		ble	main_154
		jsr	sub_C4DA	; return in A not exceeding 125
		mov	a, b
		add	b, #032
		st	b, unk_DC
		setb	bit3, flags_48
		setb	bit4, flags_48

main_154:				; CODE XREF: __RESET+A17j
<<<<<<< HEAD
		st	a, unk_DB	; magic	from address 0x80
=======
		st	a, unk_DB
>>>>>>> origin/master
		mov	a, b
		xor	b, #0FFh
		st	d, word_80
		cmp	d, word_80
		ei			; ======================end interrupt sensitive
		beq	main_157

main_155:				; CODE XREF: __RESET+9FBj
		cmp	#0BFh, unk_E1
		bcs	main_156
		setb	bit0, PORTD_ASRIN

main_156:				; CODE XREF: __RESET+A34j
		bra	main_162
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_157:				; CODE XREF: __RESET+A2Fj
		jsr	sub_C505
		mov	a, b
		xor	b, #0FFh
		st	d, word_82
		cmp	#3Dh, count_B9	; incremented at F55E
		bcs	main_163
		clr	unk_DD
		tbbc	bit2, flags_48,	main_158
		clrb	bit2, flags_48
		clrb	bit1, flags_48
		clrb	bit2, flags_46
		ld	#0ACh, unk_DC
		bra	main_161
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_158:				; CODE XREF: __RESET+A49j
		cmp	#9Dh, unk_DC
		bgt	main_161
<<<<<<< HEAD
		cmp	#7Dh, unk_DB	; magic	from address 0x80
=======
		cmp	#7Dh, unk_DB
>>>>>>> origin/master
		bne	main_159
		ld	a, ISC_11F	; ISC related
		cmpb	a, #03h
		beq	main_160

main_159:				; CODE XREF: __RESET+A5Fj
		inc	unk_DC
		bra	main_161
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_160:				; CODE XREF: __RESET+A66j
		cmp	a, #08h
		bne	main_161
		cmp	#83h, unk_E1
		bcs	main_161
		setb	bit0, PORTD_ASRIN

main_161:				; CODE XREF: __RESET+A55j __RESET+A5Aj ...
		setb	bit7, flags_48

main_162:				; CODE XREF: __RESET:main_156j
		bra	main_172
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_163:				; CODE XREF: __RESET+A45j
		tbbc	bit7, flags_48,	main_164 ; bounce if starting
		clrb	bit7, flags_48
		ld	a, unk_DB	; magic	from address 0x80
		add	a, #20h
		st	a, unk_DC

main_164:				; CODE XREF: __RESET:main_163j
		tbbs	bit0, flags_45,	main_165 ; bounce if starting
		cmp	#020, RPM	; MSB is RPM/50, LSB is	fraction of 50
		bcs	main_166
		tbbc	bit3, flags_48,	main_166
		jsr	sub_C4DA	; return in A not exceeding 125
		mov	a, b
		add	b, #20h
		st	d, unk_DB	; magic	from address 0x80
		mov	a, b
		xor	b, #0FFh
		st	d, word_80

main_165:				; CODE XREF: __RESET:main_164j
		clrb	bit3, flags_48

main_166:				; CODE XREF: __RESET+A8Cj __RESET+A8Ej
		tbbs	bit2, flags_48,	main_169
		tbbc	bit3, flags_48,	main_167
		clr	count_C8	; decrements at	E488
		bra	main_171	; 300RPM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_167:				; CODE XREF: __RESET+AA3j
		ld	y, #0C486h
		jsr	TwoD_rawTHW	; lookup Raw Water Temp, integer return	in Acca, fraction return in AccB
		cmp	a, RPM		; MSB is RPM/50, LSB is	fraction of 50
		bgt	main_168
		cmp	#80h, Bvolts	; 10V
		bcs	main_168
		clrb	bit1, flags_48
		setb	bit2, flags_48
		jsr	sub_C4DA	; return in A not exceeding 125
		clrb	bit1, flags_42
		clr	b
		add	a, #20h
		st	d, unk_DC
		setb	bit0, flags_42
		clr	a
		st	a, unk_121

main_168:				; CODE XREF: __RESET+AB2j __RESET+AB7j
		bra	main_172
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_169:				; CODE XREF: __RESET:main_166j
		tbbs	bit1, flags_48,	main_171 ; 300RPM
<<<<<<< HEAD
		ld	d, unk_DB	; magic	from address 0x80
=======
		ld	d, unk_DB
>>>>>>> origin/master
		add	a, #20h
		cmp	a, b
		bne	main_172
		setb	bit1, flags_48
		setb	bit2, flags_46
		clr	unk_E3
		ld	a, #1Fh
		cmp	#86h, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		bcc	main_170
		ld	a, #153

main_170:				; CODE XREF: __RESET+AE4j
		st	a, count_C8	; decrements at	E488

main_171:				; CODE XREF: __RESET+AA8j
					; __RESET:main_169j
		cmp	#006, RPM	; 300RPM
		bcc	main_173

main_172:				; CODE XREF: __RESET:main_162j
					; __RESET:main_168j ...
		clrb	bit0, flags_47
		setb	bit5, flags_48
		ld	#1Eh, unk_DE
		clr	a
		clr	b
		st	d, word_DF
		jmp	main_239
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_173:				; CODE XREF: __RESET+AEDj
<<<<<<< HEAD
		tbbs	bit1, flags_45,	main_174 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbs	bit1, flags_45,	main_174 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		tbbc	bit1, flags_42,	main_177
		clrb	bit1, flags_42
		ld	#00h, count_BC	; decremented at F566
		bra	main_175
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_174:				; CODE XREF: __RESET:main_173j
		tbbs	bit1, flags_42,	main_177
		setb	bit1, flags_42
		ld	#25h, count_BC	; decremented at F566

main_175:				; CODE XREF: __RESET+B08j
		tbs	bit1, flags_43	; bit3:	AFM bad	bit4: rev limiter
		beq	main_176
		clrb	bit1, flags_43

main_176:				; CODE XREF: __RESET+B14j
		bra	main_184
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_177:				; CODE XREF: __RESET+B00j
					; __RESET:main_174j
		tbbc	bit1, flags_43,	main_181 ; bit3: AFM bad bit4: rev limiter
		ld	a, count_BC	; decremented at F566
		bne	main_181
		clrb	bit1, flags_43
		ld	y, #0C4D6h
		tbbs	bit0, flags_42,	main_178
		inc	y

main_178:				; CODE XREF: __RESET+B26j
		ld	a, y + 00h
<<<<<<< HEAD
		tbbc	bit2, flags_46,	main_179 ; bit 1 flags limp in injection mode, B5 RPM under 5200ish
=======
		tbbc	bit2, flags_46,	main_179 ; bit 1 flags limp in injection mode
>>>>>>> origin/master
		shr	a

main_179:				; CODE XREF: __RESET+B2Cj
		tbbs	bit1, flags_42,	main_180
		neg	a

main_180:				; CODE XREF: __RESET:main_179j
		bra	main_188
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_181:				; CODE XREF: __RESET:main_177j
					; __RESET+B1Fj
<<<<<<< HEAD
		tbbs	bit5, flags_45,	main_182 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbs	bit5, flags_45,	main_182 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		tbbc	bit0, flags_42,	main_185
		clrb	bit0, flags_42
		ld	#00h, count_BB	; decremented at F566
		bra	main_183
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_182:				; CODE XREF: __RESET:main_181j
		tbbs	bit0, flags_42,	main_185
		setb	bit0, flags_42
		ld	#06h, count_BB	; decremented at F566

main_183:				; CODE XREF: __RESET+B41j
		tbs	bit0, flags_43	; bit3:	AFM bad	bit4: rev limiter
		beq	main_184
		clrb	bit0, flags_43

main_184:				; CODE XREF: __RESET:main_176j
					; __RESET+B4Dj
		cmp	#1Fh, count_C8	; decrements at	E488
		bcc	main_189
		ld	#1Fh, count_C8	; decrements at	E488
		bra	main_189
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_185:				; CODE XREF: __RESET+B39j
					; __RESET:main_182j
		tbbc	bit0, flags_43,	main_189 ; bit3: AFM bad bit4: rev limiter
		ld	a, count_BB	; decremented at F566
		bne	main_189
		clrb	bit0, flags_43
		ld	y, #0C4D8h
		tbbs	bit1, flags_42,	main_186
		inc	y

main_186:				; CODE XREF: __RESET+B67j
		ld	a, y + 00h
<<<<<<< HEAD
		tbbc	bit2, flags_46,	main_187 ; bit 1 flags limp in injection mode, B5 RPM under 5200ish
=======
		tbbc	bit2, flags_46,	main_187 ; bit 1 flags limp in injection mode
>>>>>>> origin/master
		shr	a

main_187:				; CODE XREF: __RESET+B6Dj
		tbbc	bit0, flags_42,	main_188
		neg	a

main_188:				; CODE XREF: __RESET:main_180j
					; __RESET:main_187j
		di
		add	a, unk_DD
		st	a, unk_DD
		ei
		setb	bit5, flags_48

main_189:				; CODE XREF: __RESET+B54j __RESET+B59j ...
		tbbc	bit4, flags_44,	main_190 ; bit 1 is igf1 related, bit2 igf2 related
<<<<<<< HEAD
		tbbs	bit5, flags_45,	main_190 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
		cmp	#37h, unk_5E	; could	be last	unk_100, or 0
		bcs	main_190
		cmp	#14h, unk_DB	; magic	from address 0x80
=======
		tbbs	bit5, flags_45,	main_190 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		cmp	#37h, unk_5E	; could	be last	unk_100, or 0
		bcs	main_190
		cmp	#14h, unk_DB
>>>>>>> origin/master
		bcs	main_190
		cmp	#032, RPM	; MSB is RPM/50, LSB is	fraction of 50
		bcs	main_190
		cmp	#036, RPM	; MSB is RPM/50, LSB is	fraction of 50
		bcs	main_191
		setb	bit0, flags_48
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  8Ch ; Œ		; cmp x
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_190:				; CODE XREF: __RESET:main_189j
					; __RESET+B80j	...
		clrb	bit0, flags_48

main_191:				; CODE XREF: __RESET+B95j
		ld	y, #0C4C0h
		jsr	TwoD_RPM	; lookup RPM, integer return in	Acca, fraction return in AccB
		st	a, unk_E2
		tbbs	bit3, flags_43,	main_198 ; bit3: AFM bad bit4: rev limiter
		tbbc	bit4, flags_47,	main_198 ; bit4: high when hot (but how	hot?)
		tbbs	bit0, flags_42,	main_198
		ld	a, unk_103
		and	a, #01h
		beq	main_198
		tbbc	bit1, flags_42,	main_192
		ld	y, #0C4D1h
		bra	main_193
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_192:				; CODE XREF: __RESET+BB4j
		ld	y, #0C4CCh

main_193:				; CODE XREF: __RESET+BBAj
		ld	a, unk_5E	; could	be last	unk_100, or 0
		jsr	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB
		st	a, temp_51
		tbbc	bit1, flags_42,	main_195
		clr	a
		ld	b, flags_183	; bit 0	set oer	1550 RPM, bit 1	set under 1700 RPM
		cmpb	b, #01h
		beq	main_194
		ld	a, #05h
		cmpb	b, #02h
		beq	main_194
		ld	a, #0Ah

main_194:				; CODE XREF: __RESET+BCFj __RESET+BD5j
		bra	main_196
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_195:				; CODE XREF: __RESET+BC6j
		ld	d, RPM		; MSB is RPM/50, LSB is	fraction of 50
		jsr	DivDby64sat	; shift	D right	6 times, then saturate B if A>0
		mov	b, a
		ld	y, #0C4C7h
		jsr	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB

main_196:				; CODE XREF: __RESET:main_194j
		cmp	a, temp_51
		ble	main_197
		ld	a, temp_51

main_197:				; CODE XREF: __RESET+BE9j
		mov	a, b
		sub	a, unk_121
		neg	a
		st	b, unk_121
		bra	main_199
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_198:				; CODE XREF: __RESET+BA4j __RESET+BA7j ...
		ld	a, unk_121
		clr	b
		st	b, unk_121

main_199:				; CODE XREF: __RESET+BF5j
		di
		add	a, unk_DD
		st	a, unk_DD
		ei
		ld	a, byte_1A8	; air temp and baro compensation for load from AFM
		ld	y, #0C498h
		jsr	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB
		ld	b, unk_DA
		shr	b
		shr	b
		add	a, b
		ld	y, #0C4BCh
		ld	b, flags_42
		and	b, #03h
		add	y, b
		ld	b, y + 00h
		st	b, temp_52
		add	b, #3Bh
		add	a, b
		st	a, temp_51
		tbbs	bit0, flags_41,	main_200 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
		cmp	#1Fh, count_C8	; decrements at	E488
		bcc	main_200
		ld	#1Fh, count_C8	; decrements at	E488

main_200:				; CODE XREF: __RESET+C23j __RESET+C29j
		ld	a, count_C8	; decrements at	E488
		beq	main_201
		cmp	a, #03h
		bgt	main_207
		bra	main_208
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_201:				; CODE XREF: __RESET+C30j
		cmp	#02h, unk_5E	; could	be last	unk_100, or 0
		bcc	main_207
		ld	#03h, count_C8	; decrements at	E488
		ld	y, #0C4A6h
		ld	a, #30h
		tbbs	bit0, flags_42,	main_202
		ld	y, #0C4ADh
		ld	a, #2Ah

main_202:				; CODE XREF: __RESET+C45j
		st	a, temp_52
		jsr	TwoD_rawTHW	; lookup Raw Water Temp, integer return	in Acca, fraction return in AccB
		push	a
		ld	d, RPM		; MSB is RPM/50, LSB is	fraction of 50
		cmp	a, #064		; 3200 RPM
		bcc	main_204
		shl	d
		shl	d
		pull	b
		cmp	a, temp_52
		bcc	main_203
		inc	unk_DC
		bra	main_207
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_203:				; CODE XREF: __RESET+C5Ej
		cmp	a, b
		bgt	main_205
		setb	bit0, flags_47
		bra	main_208
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_204:				; CODE XREF: __RESET+C57j
		pull	b

main_205:				; CODE XREF: __RESET+C65j
		tbbs	bit0, flags_42,	main_206
		cmp	#1Ah, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
		bcs	main_207
<<<<<<< HEAD
		ld	a, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1
=======
		ld	a, flags_7D
>>>>>>> origin/master
		cmpb	a, #10h
		bne	main_207

main_206:				; CODE XREF: __RESET:main_205j
		dec	unk_DC
		bra	main_207

main_207:				; CODE XREF: __RESET+C34j __RESET+C3Bj ...
		clrb	bit0, flags_47

main_208:				; CODE XREF: __RESET+C36j __RESET+C69j
		ei
		cmp	#1Eh, unk_E3
		bcs	main_210
		clr	unk_E3
		tbbs	bit4, flags_47,	main_210 ; bit4: high when hot (but how	hot?)
		jsr	sub_C4DF	; return in A not exceeding 125
		add	a, #20h
		cmp	a, unk_DC
		beq	main_210
		bcs	main_209
		inc	unk_DC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  8Ch ; Œ		; cmp x
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_209:				; CODE XREF: __RESET+C94j
		dec	unk_DC

main_210:				; CODE XREF: __RESET+C84j __RESET+C88j ...
		di
		ld	a, flags_77	; make a decision on bit 1
		cmpb	a, #02h
		beq	main_211	; if the bit was clear,	set it.
		ei
		jmp	main_236
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_211:				; CODE XREF: __RESET+CA0j
		or	a, #02h
		st	a, flags_77	; set bit 1
		ei
		tbbc	bit4, flags_47,	main_212 ; bit4: high when hot (but how	hot?)
		tbbc	bit0, flags_41,	main_212 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
<<<<<<< HEAD
		ld	a, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1
=======
		ld	a, flags_7D
>>>>>>> origin/master
		cmpb	a, #10h
		bne	main_212
		cmp	#02h, unk_5E	; could	be last	unk_100, or 0
		bcs	main_213

main_212:				; CODE XREF: __RESET+CABj __RESET+CAEj ...
		clr	a
		bra	main_214
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_213:				; CODE XREF: __RESET+CBAj
		ld	a, unk_DE
		cmp	a, #2Dh
		bcc	main_215
		inc	a

main_214:				; CODE XREF: __RESET+CBDj
		jmp	main_234
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_215:				; CODE XREF: __RESET+CC3j
		clrb	bit2, flags_46
		cmp	a, #2Eh
		bcc	main_216
		jmp	main_233
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_216:				; CODE XREF: __RESET+CCDj
		cmp	a, #4Eh
		bcc	main_219
		ld	d, RPM		; MSB is RPM/50, LSB is	fraction of 50
		sub	a, #008		; subtract 400 RPM
		bcc	main_217	; =RPM/100
		clr	a
		clr	b

main_217:				; CODE XREF: __RESET+CDAj
		shr	d		; =RPM/100
		add	d, word_DF
		bcc	main_218
		ld	a, #0FFh

main_218:				; CODE XREF: __RESET+CE1j
		st	d, word_DF
		ld	a, unk_DE
		inc	a
		jmp	main_235
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_219:				; CODE XREF: __RESET+CD4j
		ld	a, word_DF
		tbbc	bit6, flags_48,	main_220
		shl	a
		bcc	main_220
		ld	a, #0FFh

main_220:				; CODE XREF: __RESET+CEFj __RESET+CF3j
		st	a, temp_52
		ld	x, #0C4B4h
		ld	a, flags_42
		and	a, #03h
		mov	a, b
		add	x, a
		ld	a, x + 00h
		ld	x, #0C4B8h
		add	x, b
<<<<<<< HEAD
		ld	b, ADC_pin15	; adc pin 15 (always 0)
		tbbc	bit1, flags_42,	main_221
		ld	b, ADC_rq1D	; adc request 1D (probably pin 14, always 0)
=======
		ld	b, ADC_pin15	; adc pin 15 (0V)
		tbbc	bit1, flags_42,	main_221
		ld	b, ADC_rq1D	; adc request 1D (probably pin 14, 0V)
>>>>>>> origin/master

main_221:				; CODE XREF: __RESET+D0Bj
		tbbc	bit0, flags_42,	main_222
		shr	b

main_222:				; CODE XREF: __RESET:main_221j
		shr	b
		bcc	main_223
		add	a, x + 00h

main_223:				; CODE XREF: __RESET+D16j
		sub	a, temp_52
		bcs	main_225
		cmp	a, #07h
		ble	main_228
		inc	unk_DC
		cmp	a, #16h
		ble	main_224
		inc	unk_DC

main_224:				; CODE XREF: __RESET+D26j
		jmp	main_233
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_225:				; CODE XREF: __RESET+D1Cj
		neg	a
		cmp	a, #07h
		ble	main_228
		ld	b, unk_E4
		shr	b
		shr	b
		sub	b, temp_51
		bcs	main_226
		clr	b

main_226:				; CODE XREF: __RESET+D38j
		neg	b
		cmp	b, unk_DC
		bcc	main_229
		dec	unk_DC
		cmp	a, #16h
		ble	main_227
		cmp	b, unk_DC
		bcc	main_229
		dec	unk_DC
		cmp	a, #26h
		ble	main_227
		cmp	b, unk_DC
		bcc	main_229
		dec	unk_DC
		cmp	b, unk_DC
		bcc	main_229
		dec	unk_DC

main_227:				; CODE XREF: __RESET+D44j __RESET+D4Ej
		bra	main_233
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_228:				; CODE XREF: __RESET+D20j __RESET+D30j
		clrb	bit5, flags_48
		tbbs	bit4, flags_48,	main_233
		ld	a, temp_51
		sub	a, #20h
<<<<<<< HEAD
		sub	a, unk_DB	; magic	from address 0x80
=======
		sub	a, unk_DB
>>>>>>> origin/master
		beq	main_233
		bcs	main_230

main_229:				; CODE XREF: __RESET+D3Ej __RESET+D48j ...
		ld	a, unk_DA
		beq	main_233
		ld	b, unk_E4
		beq	main_233
		dec	unk_E4
		dec	a
		bra	main_232
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_230:				; CODE XREF: __RESET+D6Bj
		ld	a, unk_DA
		cmp	a, #120
		bcc	main_233
		cmp	#160, unk_E4
		bcc	main_231
		inc	unk_E4

main_231:				; CODE XREF: __RESET+D83j
		inc	a

main_232:				; CODE XREF: __RESET+D78j
		st	a, unk_DA
		mov	a, b
		xor	b, #0FFh
		st	d, word_82

main_233:				; CODE XREF: __RESET+CCFj
					; __RESET:main_224j ...
		ld	a, #2Eh
		clrb	bit6, flags_48
		tbbc	bit5, flags_48,	main_234
		ld	a, #3Eh
		setb	bit6, flags_48

main_234:				; CODE XREF: __RESET:main_214j
					; __RESET+D93j
		ld	x, #0000h
		st	x, word_DF

main_235:				; CODE XREF: __RESET+CEAj
		st	a, unk_DE

main_236:				; CODE XREF: __RESET+CA3j
		di
		ld	a, unk_DB	; magic	from address 0x80
		add	a, #20h
		mov	a, b
		sub	a, unk_DC
		bcc	main_237
		neg	a

main_237:				; CODE XREF: __RESET+DA9j
		cmp	a, #3Ch
		ble	main_238
		st	b, unk_DC

main_238:				; CODE XREF: __RESET+DAEj
		ei
		di
		ld	a, unk_DC
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0A1h ; ¡
		.db  02h
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		st	a, unk_DC
		ei

main_239:				; CODE XREF: __RESET+AFAj
		setb	bit2, flags_4A
		cmp	#006, RPM	; MSB is RPM/50, LSB is	fraction of 50
		bcs	main_240
		cmp	#077, Bvolts	; 6V
		bcc	main_241

main_240:				; CODE XREF: __RESET+DC3j
		clr	count_C6	; increments at	E478

main_241:				; CODE XREF: __RESET+DC8j
		cmp	#4Ch, count_C6	; increments at	E478
		bcc	main_242
<<<<<<< HEAD
		tbbs	bit0, flags_4C,	main_243 ; bit 7 set when not running (300 to 400 RPM gap)
=======
		tbbs	bit0, flags_4C,	main_243 ; bit 7 demands a sampling of the oxygen sensors
>>>>>>> origin/master
		tbbs	bit3, flags_4E,	main_243 ; bit1	is igf1	related, bit2 igf2 related
		cmp	#006, RPM	; MSB is RPM/50, LSB is	fraction of 50
		bcs	main_244
		cmp	#077, Bvolts	; 6V
		bcs	main_244
		cmp	#9Fh, count_B3	; incremented at F55E
		bcs	main_245
		setb	bit0, flags_4C
		ld	a, word_86
		and	a, #08h
		beq	main_244

main_242:				; CODE XREF: __RESET+DCFj
		setb	bit3, flags_4E
		bra	main_244
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_243:				; CODE XREF: __RESET+DD1j __RESET+DD4j
		cmp	#7Ah, count_B3	; incremented at F55E
		bcs	main_245
		ld	a, KS_count2
		cmp	a, #0Fh
		bcs	main_244
		clrb	bit3, flags_4E
		clrb	bit0, flags_4C

main_244:				; CODE XREF: __RESET+DDAj __RESET+DDFj ...
		clr	a
		st	a, count_B3	; incremented at F55E
		st	a, KS_count2

main_245:				; CODE XREF: __RESET+DE4j __RESET+DF5j
		setb	bit2, flags_4A
		di
		ld	a, flags_77	; set bit 3, make a decision on	bit 3
		mov	a, b
		or	a, #08h
		st	a, flags_77	; set bit 3
		ei
		cmpb	b, #08h
		beq	main_246
		jmp	main_282
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_246:				; CODE XREF: __RESET+E15j
		ld	a, unk_1AF
<<<<<<< HEAD
		tbbs	bit5, flags_45,	main_250 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbs	bit5, flags_45,	main_250 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		cmp	a, #0FEh
		bcc	main_247
		add	a, #02h

main_247:				; CODE XREF: __RESET+E22j
		ld	b, unk_109
		cmpb	b, #01h
		beq	main_251
		cmp	#040, RPM	; MSB is RPM/50, LSB is	fraction of 50
		bcs	main_251	; branch if below 2000 RPM
		cmp	#046, RPM	; MSB is RPM/50, LSB is	fraction of 50
		bcs	main_252	; branch if below 2300 RPM
		cmp	a, #0F4h
		bgt	main_252
		cmp	a, #06h
		bcs	main_252
		cmp	a, #92h
		bgt	main_249
		or	a, #01h

main_248:				; CODE XREF: __RESET+E4Bj
		setb	bit5, flags_44
		bra	main_252
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_249:				; CODE XREF: __RESET+E41j
		cmpb	a, #01h
		bne	main_248
		bra	main_252
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_250:				; CODE XREF: __RESET+E1Dj
		clr	a

main_251:				; CODE XREF: __RESET+E2Bj __RESET+E30j
		clrb	bit5, flags_44

main_252:				; CODE XREF: __RESET+E35j __RESET+E39j ...
		st	a, unk_1AF
		ld	a, unk_E1
		shl	a
<<<<<<< HEAD
		tbbc	bit4, flags_45,	main_253 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbc	bit4, flags_45,	main_253 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		clrb	bit0, PORTD_ASRIN
		bcc	main_255
		clr	a
		bra	main_256
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_253:				; CODE XREF: __RESET+E58j
		bcs	main_254
		setb	bit2, SSD
		ld	a, #80h
		bra	main_256
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_254:				; CODE XREF: __RESET:main_253j
		setb	bit2, SSD

main_255:				; CODE XREF: __RESET+E5Dj
		inc	a
		inc	a
		beq	main_257
		rorc	a

main_256:				; CODE XREF: __RESET+E60j __RESET+E68j
		st	a, unk_E1

main_257:				; CODE XREF: __RESET+E6Ej
		ld	y, #012Dh
		clrb	bit0, flags_40
		ld	a, unk_140	; bits 5,0 oxl2	related
		and	a, unk_15C	; bits 5,0 oxr2	related
		cmpb	a, #02h
		bne	main_259
		clr	a
		clr	b
		st	d, unk_13E
		st	d, unk_15A
		ld	a, unk_17A
		bmi	main_258
		ld	d, #0FFFFh
		st	d, unk_17A

main_258:				; CODE XREF: __RESET+E8Dj
		jmp	main_270
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_259:				; CODE XREF: __RESET+E80j __RESET+F29j
		push	y
		ld	y, #0C328h
		cmp	#0B3h, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		bcc	main_260
		ld	y, #0C32Fh

main_260:				; CODE XREF: __RESET+E9Fj
		jsr	TwoD_7A		; Lookup unk_7A, integer return	in Acca, fraction return in AccB
		pull	y
		mov	a, b
		clr	a
		st	d, temp_51
		ld	x, #0000h
		ld	d, y + 13h
		tbbc	bit0, flags_41,	main_267 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
		cmp	#05h, unk_5E	; could	be last	unk_100, or 0
		bgt	main_261
		ld	#2Bh, temp_52
		cmpb	a, #04h
		bne	main_261
		ld	#15h, temp_52

main_261:				; CODE XREF: __RESET+EB7j __RESET+EBEj
		ld	x, unk_17A
		tbbc	bit4, flags_42,	main_263
		cmp	#0Fh, unk_5E	; could	be last	unk_100, or 0
		bcc	main_265
		inc	x
		bmi	main_264
		tbbs	bit2, PORTD_ASRIN, main_263 ; Port D Data Register / ASR Input Data
<<<<<<< HEAD
		tbbs	bit6, flags_45,	main_263 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
		tbbc	bit4, flags_47,	main_263 ; bit4: high when hot (but how	hot?)
		cmp	x, #55D5h
		bgt	main_265
		tbbc	bit0, flags_40,	main_262 ; B3 :	forced timing to 5/10 deg BTDC
=======
		tbbs	bit6, flags_45,	main_263 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		tbbc	bit4, flags_47,	main_263 ; bit4: high when hot (but how	hot?)
		cmp	x, #55D5h
		bgt	main_265
		tbbc	bit0, flags_40,	main_262
>>>>>>> origin/master
		st	x, unk_17A

main_262:				; CODE XREF: __RESET+EDFj
		bra	main_266
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_263:				; CODE XREF: __RESET+EC6j __RESET+ED1j ...
		ld	x, #0FFFFh

main_264:				; CODE XREF: __RESET+ECFj
<<<<<<< HEAD
		tbbc	bit0, flags_40,	main_265 ; B3 :	forced timing to 5/10 deg BTDC
=======
		tbbc	bit0, flags_40,	main_265
>>>>>>> origin/master
		st	x, unk_17A

main_265:				; CODE XREF: __RESET+ECCj __RESET+EDDj ...
		ld	x, #0000h
		jmp	main_268
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_266:				; CODE XREF: __RESET:main_262j
		ld	x, y + 11h
		beq	main_268
		ld	a, y + 13h
		cmpb	a, #04h
		bne	main_268
		clr	temp_52
		dec	x
		bne	main_268
		ld	d, #051Fh
		bra	main_269
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_267:				; CODE XREF: __RESET+EB1j
		ld	d, y + 11h
		beq	main_268
		ld	a, y + 13h
		cmpb	a, #04h
		bne	main_268
		ld	d, #0F5Ch
		st	d, temp_51

main_268:				; CODE XREF: __RESET+EF3j __RESET+EF8j ...
		ld	d, temp_51

main_269:				; CODE XREF: __RESET+F08j
		push	x
		jsr	sub_C895
		pull	x
		st	x, y + 11h
		ld	y, #0149h
<<<<<<< HEAD
		tbs	bit0, flags_40	; B3 : forced timing to	5/10 deg BTDC
=======
		tbs	bit0, flags_40
>>>>>>> origin/master
		bne	main_270
		jmp	main_259
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_270:				; CODE XREF: __RESET:main_258j
					; __RESET+F27j
<<<<<<< HEAD
		tbbc	bit1, flags_45,	main_276 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
		cmp	#92h, count_A4	; incremented at F47D
		bcs	main_277
		tbbs	bit5, flags_45,	main_273 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
		ld	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
=======
		tbbc	bit1, flags_45,	main_276 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		cmp	#92h, count_A4	; incremented at F47D
		bcs	main_277
		tbbs	bit5, flags_45,	main_273 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		ld	a, flags_A2	; bit7:	VTA_net	high, bit4: VTA_net high
>>>>>>> origin/master
		cmpb	a, #10h		; bigger throttle bit
		beq	main_273
		cmp	#64h, unk_5E	; could	be last	unk_100, or 0
		bgt	main_273
		ld	a, count_1A0	; increments at	E480
		cmp	a, #0FFh
		bcc	main_271
		ld	a, #0B3h
		bra	main_278
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_271:				; CODE XREF: __RESET+F47j
		ld	a, count_1A1	; increments at	E480
		cmp	a, #0FFh
		bcs	main_274
		cmp	#49h, count_A5	; incremented at F47D
		bcs	main_275
		ld	a, #94h
		ld	b, unk_108
		cmpb	b, #10h
		beq	main_272
		add	a, #3Dh

main_272:				; CODE XREF: __RESET+F60j
		st	a, count_1A0	; increments at	E480
		bra	main_279
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_273:				; CODE XREF: __RESET+F34j __RESET+F3Bj ...
		ld	a, #0FFh
		st	a, count_1A0	; increments at	E480

main_274:				; CODE XREF: __RESET+F52j
		clr	count_A5	; incremented at F47D

main_275:				; CODE XREF: __RESET+F57j
		ld	b, #04h
		jsr	orFlags_50	; or b with Flags_50
		bra	main_280
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_276:				; CODE XREF: __RESET:main_270j
		clr	count_A4	; incremented at F47D

main_277:				; CODE XREF: __RESET+F32j
		ld	a, #0FFh
		st	a, count_1A0	; increments at	E480
		clr	count_A5	; incremented at F47D

main_278:				; CODE XREF: __RESET+F4Bj
		st	a, count_1A1	; increments at	E480

main_279:				; CODE XREF: __RESET+F67j
		ld	b, #0FBh
		jsr	andFlags_50	; and b	with Flags_50

main_280:				; CODE XREF: __RESET+F75j
		ld	a, RPM		; MSB is RPM/50, LSB is	fraction of 50
		bne	main_281
<<<<<<< HEAD
		ld	a, flags_45	; IC303	input chip: B7 /TE2, B6	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
=======
		ld	a, flags_45	; IC303	input chip: B7 /TE2, B /TE1, B5	/NSW, B4 IGSW,	B3, B2 IDL2, B1	, B0 STA
>>>>>>> origin/master
		and	a, #71h
		cmp	a, #61h
		bne	main_281
		tbbs	bit0, flags_41,	main_281 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
		jsr	sub_D2B9
		nop			; user sub injection!
		nop
		nop

main_281:				; CODE XREF: __RESET+F8Aj __RESET+F92j ...
		ld	a, Bvolts	; ADC measurement of +B/4. scaling is thus 20*value/255=volts
		ld	y, #0C2BFh
		jsr	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB
		jsr	divDby64	; shift	D right	6 times
		st	d, InjDeadtime	; set from table output	C2BF

main_282:				; CODE XREF: __RESET+E17j
		setb	bit2, flags_4A
		di
		ld	a, flags_77	; set bit 2, make a decision on	bit 2
		mov	a, b
		or	a, #04h
		st	a, flags_77	; set bit 2
		ei
		cmpb	b, #04h
		beq	main_283
		jmp	main_293
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_283:				; CODE XREF: __RESET+FB8j
		ld	b, #010
		ld	y, #00BEh
		jsr	satcount	; increment B bytes of ram by 1	starting from Y, saturates at FF
		ld	b, #004
		ld	y, #01A0h
		jsr	satcount	; increment B bytes of ram by 1	starting from Y, saturates at FF
		ld	b, #002
		ld	y, #00C8h
		jsr	satuncount	; decrements B bytes of	ram by 1 starting from Y, saturates at 00
		ld	a, count_143	; only counts while warm
		inc	a
		beq	main_284
		st	a, count_143	; only counts while warm

main_284:				; CODE XREF: __RESET+FD9j
		ld	a, count_15F	; only counts while warm? oxy sensor related?
		inc	a
		beq	main_285
		st	a, count_15F	; only counts while warm? oxy sensor related?

main_285:				; CODE XREF: __RESET+FE2j
		di
		ld	a, count_5F	; counts up to 255 since last start, about 15 counts per second
		cmp	a, #03h
		bcs	main_286
		tbbs	bit0, flags_45,	main_287 ; bounce if starting

main_286:				; CODE XREF: __RESET+FECj
		inc	a
		beq	main_287
		st	a, count_5F	; counts up to 255 since last start, about 15 counts per second

main_287:				; CODE XREF: __RESET+FEEj __RESET+FF2j
		ei
		jsr	SUB_C918	; bounce if TE1	shorted	to gnd
		ld	y, #0C343h
		jsr	TwoD_RPM	; lookup RPM, integer return in	Acca, fraction return in AccB
		ld	x, unk_17E
		add	x, a
		ld	a, word_8E
		cmpb	a, #10h
		bne	main_288
		cmp	#05h, unk_5E	; could	be last	unk_100, or 0
		bcc	main_288
		tbbs	bit0, flags_41,	main_288 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
<<<<<<< HEAD
		tbbs	bit5, flags_45,	main_289 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbs	bit5, flags_45,	main_289 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master

main_288:				; CODE XREF: __RESET+1008j
					; __RESET+100Dj ...
		clr	a
		clr	b
		ld	x, #0000h
		bra	main_292
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_289:				; CODE XREF: __RESET+1012j
		ld	d, unk_17C
		add	a, #10h
		bcc	main_291	; main loop user sub!
		tbbc	bit4, flags_43,	main_290 ; bit3: AFM bad bit4: rev limiter
		clrb	bit4, flags_43
		add	b, #06h
		cmp	b, #5Ah
		bcs	main_291	; main loop user sub!
		ld	b, #80h
		bra	main_291	; main loop user sub!
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_290:				; CODE XREF: __RESET+1023j
		cmpz	b
		beq	main_291	; main loop user sub!
		bmi	main_291	; main loop user sub!
		dec	b

main_291:				; CODE XREF: __RESET+1021j
					; __RESET+102Cj ...
		nop			; main loop user sub!
		nop
		nop
		cmp	x, #6978h
		bcs	main_292
		ld	x, #6978h
		ld	b, #80h

main_292:				; CODE XREF: __RESET+101Aj
					; __RESET+103Ej
		st	d, unk_17C
		st	x, unk_17E
		jsr	sub_D499

main_293:				; CODE XREF: __RESET+FBAj
		tbs	bit7, flags_42
		beq	main_294
		jmp	main_321	; set on timer overflow
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_294:				; CODE XREF: __RESET+1050j
		di
		ld	a, unk_140	; bits 5,0 oxl2	related
		and	a, #0FEh
		tbbc	bit4, flags_49,	main_295 ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		or	a, #21h

main_295:				; CODE XREF: __RESET+105Bj
		st	a, unk_140	; bits 5,0 oxl2	related
		ld	a, unk_15C	; bits 5,0 oxr2	related
		and	a, #0FEh
		tbbc	bit5, flags_49,	main_296 ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		or	a, #21h

main_296:				; CODE XREF: __RESET+1068j
		st	a, unk_15C	; bits 5,0 oxr2	related
		ei
		clrb	bit0, flags_40
		ld	x, #0090h
		ld	y, #012Dh

main_297:				; CODE XREF: __RESET+117Dj
		ld	a, flags_44	; bit 1	is igf1	related, bit2 igf2 related
		cmpb	a, #3Fh
		beq	main_298
		ld	#2Eh, count_C9	; decrements at	E488

main_298:				; CODE XREF: __RESET+107Dj
		ld	d, y + 13h
		st	d, temp_51
		ld	b, x + 00h
		and	b, #03h
		bne	main_302
<<<<<<< HEAD
		ld	b, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1
		st	b, temp_53
		ld	b, #03h
		tbbc	bit0, flags_40,	main_299 ; B3 :	forced timing to 5/10 deg BTDC
=======
		ld	b, flags_7D
		st	b, temp_53
		ld	b, #03h
		tbbc	bit0, flags_40,	main_299
>>>>>>> origin/master
		ld	b, #0Ch

main_299:				; CODE XREF: __RESET+1092j
		and	b, temp_53
		bne	main_302
		cmpb	a, #20h
		bne	main_300
		cmp	#1Eh, count_CF	; incremented at E7A9
		bcs	main_301

main_300:				; CODE XREF: __RESET+109Dj
		ld	b, unk_103
		cmpb	b, #40h
		beq	main_301
		cmpb	a, #02h
		beq	main_303
		ld	d, temp_51
		tbbs	bit0, flags_41,	main_303 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
		cmp	#14h, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
		bcs	main_303
		cmp	#00h, count_C9	; decrements at	E488
		beq	main_308
		bra	main_303
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_301:				; CODE XREF: __RESET+10A2j
					; __RESET+10A9j
		ld	d, temp_51
		and	a, #01h
		and	b, #0FEh
		add	a, b
		st	b, temp_52
		bra	main_303
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_302:				; CODE XREF: __RESET+108Aj
					; __RESET+1099j
		ld	a, #66h
		bra	main_305
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_303:				; CODE XREF: __RESET+10ADj
					; __RESET+10B1j ...
		ld	b, #02h
<<<<<<< HEAD
		tbbc	bit0, flags_40,	main_304 ; B3 :	forced timing to 5/10 deg BTDC
=======
		tbbc	bit0, flags_40,	main_304
>>>>>>> origin/master
		ld	b, #20h

main_304:				; CODE XREF: __RESET+10D1j
		and	b, unk_179
		beq	main_307
		ld	d, y + 0Fh
		add	a, b
		rorc	a

main_305:				; CODE XREF: __RESET+10CDj
		ld	x, #0304h
<<<<<<< HEAD
		tbbc	bit0, flags_40,	main_306 ; B3 :	forced timing to 5/10 deg BTDC
=======
		tbbc	bit0, flags_40,	main_306
>>>>>>> origin/master
		ld	x, #0306h

main_306:				; CODE XREF: __RESET+10E2j
		jsr	sub_C907

main_307:				; CODE XREF: __RESET+10D9j
		ld	b, temp_52
		and	b, #0FDh
		jmp	main_320
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_308:				; CODE XREF: __RESET+10BCj
		and	a, #01h
		and	b, #01h
		cmp	a, b
		bne	main_312
		ld	x, y + 0Dh
		ld	b, ADC_rq1F	; should always	be zero	for this particular pcm
		cmpz	a
		beq	main_310
		shr	b
		shr	b
		mov	x, d
		bcs	main_309
		sub	d, #0002h
		bra	main_317
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_309:				; CODE XREF: __RESET+1104j
		sub	d, #0001h
		bra	main_317
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_310:				; CODE XREF: __RESET+10FFj
		shr	b
		mov	x, d
		bcs	main_311
		add	d, #0003h
		bra	main_317
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_311:				; CODE XREF: __RESET+1112j
		add	d, #0001h
		bra	main_317
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_312:				; CODE XREF: __RESET+10F7j
		ld	a, unk_179
<<<<<<< HEAD
		tbbs	bit0, flags_40,	main_313 ; B3 :	forced timing to 5/10 deg BTDC
=======
		tbbs	bit0, flags_40,	main_313
>>>>>>> origin/master
		and	a, #03h
		inc	a
		ld	b, #03h
		bra	main_314
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_313:				; CODE XREF: __RESET+1121j
		and	a, #30h
		add	a, #10h
		ld	b, #30h

main_314:				; CODE XREF: __RESET+1129j
		cmp	a, b
		ble	main_315
		mov	b, a

main_315:				; CODE XREF: __RESET+1132j
		or	a, unk_179
		st	a, unk_179
		ld	d, temp_51
		cmpb	a, #01h
		bne	main_316
		and	b, #0FEh
		st	b, temp_52
		ld	d, y + 0Dh
		add	d, #0106h
		bra	main_317
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_316:				; CODE XREF: __RESET+113Fj
		or	b, #01h
		st	b, temp_52
		ld	d, y + 0Dh
		sub	d, #0106h

main_317:				; CODE XREF: __RESET+1109j
					; __RESET+110Ej ...
		jsr	SaturateD16b
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.dw 28F6h
		.dw 0A3Dh
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		mov	d, x
		shl	d
		shl	d
		cmp	a, y + 0Fh
		ble	main_318
		st	a, y + 0Fh

main_318:				; CODE XREF: __RESET+1161j
		cmp	a, y + 10h
		bcc	main_319
		st	a, y + 10h

main_319:				; CODE XREF: __RESET+1167j
		ld	b, temp_52
		or	b, #02h
		st	x, y + 0Dh

main_320:				; CODE XREF: __RESET+10EFj
		st	b, y + 14h
<<<<<<< HEAD
		tbs	bit0, flags_40	; B3 : forced timing to	5/10 deg BTDC
=======
		tbs	bit0, flags_40
>>>>>>> origin/master
		bne	main_321	; set on timer overflow
		ld	x, #0092h
		ld	y, #0149h
		jmp	main_297
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_321:				; CODE XREF: __RESET+1052j
					; __RESET+1175j
		tbbs	bit5, IRQL, mainTOF_01 ; set on	timer overflow
		jmp	main_322	; --------------------------end	of pseudo interrupt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

mainTOF_01:				; CODE XREF: __RESET:main_321j
		clrb	bit5, IRQL	; timer	overflow psuedo	interrupt
		ld	b, #003
		ld	y, #00CAh
		jsr	satcount	; increment B bytes of ram by 1	starting from Y, saturates at FF
		clr	a
		ld	b, unk_142
		or	b, unk_15E
		and	b, #40h
		beq	mainTOF_02
		ld	a, count_1D3	; tof increment	rate
		inc	a
		beq	mainTOF_03

mainTOF_02:				; CODE XREF: __RESET+1199j
		st	a, count_1D3	; tof increment	rate

mainTOF_03:				; CODE XREF: __RESET+119Fj
<<<<<<< HEAD
		ld	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
=======
		ld	a, flags_A2	; bit7:	VTA_net	high, bit4: VTA_net high
>>>>>>> origin/master
		and	a, #05h
		cmp	a, #05h
		bne	mainTOF_04
		cmp	#147, Bvolts	; 11.5V
		bcs	mainTOF_04
		cmp	#6Bh, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		bcs	mainTOF_04
		ld	d, word_7A	; meanKSint divided by a air temp comp factor
		cmp	d, #084Dh
		bcc	mainTOF_05
		cmp	#2Eh, count_CA	; incremented at E643
		bcs	mainTOF_06

mainTOF_04:				; CODE XREF: __RESET+11AAj
					; __RESET+11AFj ...
		ld	b, #0FEh
		jsr	andFlags_50	; and b	with Flags_50
		bra	mainTOF_07
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

mainTOF_05:				; CODE XREF: __RESET+11BBj
		clr	count_CA	; incremented at E643

mainTOF_06:				; CODE XREF: __RESET+11C0j
		ld	b, #01h
		jsr	orFlags_50	; or b with Flags_50
		ld	a, count_178	; tof increment	rate
		inc	a
		beq	mainTOF_07
		st	a, count_178	; tof increment	rate

mainTOF_07:				; CODE XREF: __RESET+11C7j
					; __RESET+11D4j
		ld	a, flags_A2	; MSN= trouble bit7: VTA_net high, bit4: VTA_net high, lsN is oxy heater "checked" bits
		and	a, #00001010b
		cmp	a, #00001010b
		bne	mainTOF_08	; bounce if bits high
		cmp	#147, Bvolts	; 11.5V
		bcs	mainTOF_08	; bounce if low	voltage
		cmp	#179, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		bcs	mainTOF_08	; bounce if too	cold
		ld	d, word_7A	; meanKSint divided by a air temp comp factor
		cmp	d, #084Dh
		bcc	mainTOF_10
		cmp	#2Eh, count_CB	; incremented at E643
		bcs	mainTOF_11

mainTOF_08:				; CODE XREF: __RESET+11DFj
					; __RESET+11E4j ...
		ld	b, #0FDh
		jsr	andFlags_50	; and b	with Flags_50
		cmp	#1Eh, count_CF	; incremented at E7A9
		bcc	mainTOF_09
		clr	count_CF	; incremented at E7A9

mainTOF_09:				; CODE XREF: __RESET+11FFj
		bra	mainTOF_12
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

mainTOF_10:				; CODE XREF: __RESET+11F0j
		clr	count_CB	; incremented at E643

mainTOF_11:				; CODE XREF: __RESET+11F5j
		ld	b, #02h
		jsr	orFlags_50	; or b with Flags_50

mainTOF_12:				; CODE XREF: __RESET:mainTOF_09j
<<<<<<< HEAD
		st	b, flags_50	; could	be bits	for 6336 output	chip, B0 probably HTR L+R1, B1 probably	HTR L+R2
=======
		st	b, flags_50	; could	be bits	for 6336 output	chip
>>>>>>> origin/master
		ld	a, count_11D	; tof increment	rate
		inc	a
		cmp	a, #04h
		bcs	mainTOF_13
		clr	a

mainTOF_13:				; CODE XREF: __RESET+1214j
		st	a, count_11D	; tof increment	rate
		beq	mainTOF_14
		jmp	main_322	; --------------------------end	of pseudo interrupt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

mainTOF_14:				; CODE XREF: __RESET+121Aj
		cmp	#0Ah, THG	; THG lookup table output from exhaust gas temp	sensor ADC reading
		bcc	mainTOF_15
		clr	count_CE	; incremented at E7A9

mainTOF_15:				; CODE XREF: __RESET+1222j
		tbbc	bit6, flags_4B,	mainTOF_16
		cmp	#0F0h, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		bcc	mainTOF_16
		cmp	#38h, rawTHA	; Contains the NOT of air temp reading from ADC, sensor	is tied	to ground on other side
		bcs	mainTOF_16
		cmp	#5Ah, ATM_press	; adc pin 17 - PCM atmospheric pressure	sensor,	debiased and scaled
		bcs	mainTOF_16
		ld	a, unk_12E
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0E5h
		.db 1Ah
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		bcs	mainTOF_16
		ld	a, unk_14A
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0E5h ; å
		.db  1Ah
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		bcs	mainTOF_16
		cmp	#58h, count_CE	; incremented at E7A9
		bcs	mainTOF_16
		tbbs	bit0, flags_4F,	mainTOF_16
		tbbs	bit1, flags_4F,	mainTOF_16
		tbbs	bit2, flags_4F,	mainTOF_16
		ld	a, word_90
		and	a, #7Bh
		bne	mainTOF_16
		ld	a, word_92
		and	a, #7Bh
		bne	mainTOF_16
<<<<<<< HEAD
		ld	a, flags_7D	; error	bits: b3 oxy htr R2, b2	oxy htr	R1, b1 oxy htr L2, b0 oxy htr L1
=======
		ld	a, flags_7D
>>>>>>> origin/master
		and	a, #00h
		beq	mainTOF_17

mainTOF_16:				; CODE XREF: __RESET:mainTOF_15j
					; __RESET+122Cj ...
		clr	a
		jmp	mainTOF_20
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

mainTOF_17:				; CODE XREF: __RESET+126Aj
		ld	a, unk_1D7
		ld	b, flags_50	; could	be bits	for 6336 output	chip, B0 probably HTR L+R1, B1 probably	HTR L+R2
		and	b, #10h
		bne	mainTOF_19
		ld	x, meanKSint	; deltaKS/KS_count, filtered
		cmp	x, #05250
		bgt	mainTOF_19
		cmp	#60h, LOAD	; 24576	word value
		bcc	mainTOF_19
		cmp	x, #04500
		bcc	mainTOF_20
		ld	b, #02h
		cmp	x, #03500
		bcc	mainTOF_18
		inc	b

mainTOF_18:				; CODE XREF: __RESET+128Fj
		add	a, b
		bcc	mainTOF_20
		ld	a, #0FFh
		bra	mainTOF_20
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

mainTOF_19:				; CODE XREF: __RESET+1277j
					; __RESET+127Ej ...
		sub	a, #02h
		bcc	mainTOF_20
		clr	a

mainTOF_20:				; CODE XREF: __RESET+126Dj
					; __RESET+1288j ...
		ld	b, #96h
		push	a
		ld	a, ADC_rq1F	; should always	be zero	for this particular PCM
		cmpb	a, #04h
		bne	mainTOF_21
		cmp	#121, rawTHA	; Contains the NOT of air temp reading from ADC, sensor	is tied	to ground on other side
		bcc	mainTOF_23
		bra	mainTOF_22
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

mainTOF_21:				; CODE XREF: __RESET+12A6j
		cmp	#134, rawTHA	; Contains the NOT of air temp reading from ADC, sensor	is tied	to ground on other side
		bcc	mainTOF_23

mainTOF_22:				; CODE XREF: __RESET+12ADj
		ld	b, #0FFh

mainTOF_23:				; CODE XREF: __RESET+12ABj
					; __RESET+12B2j
		pull	a
		cmp	a, b
		bcc	mainTOF_24
		st	a, unk_1D7
		bra	main_322	; --------------------------end	of pseudo interrupt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

mainTOF_24:				; CODE XREF: __RESET+12B8j
		st	b, unk_1D7
		cmp	#075, THG	; THG lookup table output from exhaust gas temp	sensor ADC reading
		bcc	mainTOF_26
		ld	a, flags_146
		or	a, #80h
		st	a, flags_146
		tbbc	bit3, flags_4B,	mainTOF_25
		setb	bit6, flags_4D
		ld	a, flags_147
		or	a, #80h
		st	a, flags_147

mainTOF_25:				; CODE XREF: __RESET+12CFj
		bra	main_322	; --------------------------end	of pseudo interrupt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

mainTOF_26:				; CODE XREF: __RESET+12C5j
		ld	x, #0D255h
		ld	y, #012Dh
		jsr	sub_D222

main_322:				; CODE XREF: __RESET+1183j
					; __RESET+121Cj ...
		ld	a, count_BD	; --------------------------end	of pseudo interrupt
		bne	main_329
		ld	#0F4h, count_BD	; decremented at F566
		ld	b, #005
		ld	y, #00CDh
		jsr	satcount	; increment B bytes of ram by 1	starting from Y, saturates at FF
		ld	b, count_1BC
		inc	b
		beq	main_323
		st	b, count_1BC

main_323:				; CODE XREF: __RESET+12FAj
		ld	b, count_1BE
		inc	b
		beq	main_324
		st	b, count_1BE

main_324:				; CODE XREF: __RESET+1303j
		ld	a, unk_1D8
		bne	main_325
		ld	b, unk_140	; bits 5,0 oxl2	related
		and	b, #02h
		beq	main_326

main_325:				; CODE XREF: __RESET+130Bj
		inc	a
		beq	main_326
		st	a, unk_1D8

main_326:				; CODE XREF: __RESET+1312j
					; __RESET+1315j
		clr	a
		clr	b
		cmp	#3Bh, count_CD	; incremented at E7A9
		ble	main_328
		inc	b
		ld	y, meanKSint	; deltaKS/KS_count, filtered
		cmp	y, #07550
		bcs	main_327
		cmp	y, #10700
		bcs	main_329
		ld	b, unk_7E
		beq	main_329
		dec	unk_7E
		bra	main_329
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_327:				; CODE XREF: __RESET+1327j
		add	b, unk_7E
		cmp	b, #0DCh
		ble	main_328
		ld	b, #0DCh

main_328:				; CODE XREF: __RESET+131Fj
					; __RESET+133Aj
		st	b, unk_7E

main_329:				; CODE XREF: __RESET+12E9j
					; __RESET+132Cj ...
		setb	bit2, flags_4A
		ld	a, flags_77	; set bit 7, make a decision on	bit 7
		mov	a, b
		or	b, #80h
		st	b, flags_77	; set bit 7
		cmpb	a, #80h
		beq	main_330
<<<<<<< HEAD
		jmp	main_369	; timing algorithm is over now
=======
		jmp	main_369
>>>>>>> origin/master
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_330:				; CODE XREF: __RESET+134Bj
		clr	a
		tbbs	bit0, flags_41,	main_331 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
		ld	b, word_94
		cmpb	b, #80h
		bne	main_331
<<<<<<< HEAD
		ld	b, flags_50	; could	be bits	for 6336 output	chip, B0 probably HTR L+R1, B1 probably	HTR L+R2
		cmpb	b, #10h
		beq	Timing_332
=======
		ld	b, flags_50	; could	be bits	for 6336 output	chip
		cmpb	b, #10h
		beq	main_332
>>>>>>> origin/master

main_331:				; CODE XREF: __RESET+1351j
					; __RESET+1358j
		clr	count_B8	; incremented at F55E

<<<<<<< HEAD
Timing_332:				; CODE XREF: __RESET+135Ej
=======
main_332:				; CODE XREF: __RESET+135Ej
>>>>>>> origin/master
		cmp	#62h, count_B8	; incremented at F55E
		ble	main_333
		ld	y, #0C3FEh
		ld	d, LOAD		; Load,	uncompensated for ThA
		jsr	DivDby12	; divides D by 12, returns 16b result in unks 53:54
		ld	d, RPM		; MSB is RPM/50, LSB is	fraction of 50
		jsr	ThreeD_RPM	; returns 8b value from	3d table lookup	in AccA

main_333:				; CODE XREF: __RESET+1365j
		st	a, byte_18C	; lookup from RPM by LOAD table
		ld	a, unk_185
		cmp	#104, RPM	; 5200RPM
		bcs	main_334	; 5000 RPM
		or	a, #01h

main_334:				; CODE XREF: __RESET+137Dj
		cmp	#100, RPM	; 5000 RPM
		bcc	main_335
		and	a, #0FEh

main_335:				; CODE XREF: __RESET+1384j
		tbbs	bit3, flags_43,	main_336 ; bit3: AFM bad bit4: rev limiter
		tbbc	bit7, flags_44,	main_337 ; bit 1 is igf1 related, bit2 igf2 related
<<<<<<< HEAD
		tbbs	bit5, flags_45,	main_336 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbs	bit5, flags_45,	main_336 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		ld	b, unk_103
		cmpb	b, #02h
		bne	main_337

main_336:				; CODE XREF: __RESET:main_335j
					; __RESET+138Ej
		or	a, #80h
		bra	main_338
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_337:				; CODE XREF: __RESET+138Bj
					; __RESET+1396j
		and	a, #7Fh

main_338:				; CODE XREF: __RESET+139Aj
		st	a, unk_185
		ld	a, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		push	a
		ld	y, #0C45Eh
		jsr	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB
		st	a, temp_51	; 51 has decreasing with temp 8b value
		pull	a
		ld	y, #0C467h
		jsr	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB
		st	a, temp_52
		ld	a, unk_185
		cmpb	a, #80h
		bne	main_339
		ld	a, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
		cmp	a, #108
		bcs	main_340

main_339:				; CODE XREF: __RESET+13BAj
		ld	b, temp_51
		bra	main_342
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_340:				; CODE XREF: __RESET+13C0j
		sub	a, #028
		bgt	main_341
		ld	b, temp_52
		bra	main_342
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_341:				; CODE XREF: __RESET+13C8j
		push	a
		mov	s, x
		ld	a, temp_51
		sub	a, temp_52
		mul	a, x + 00h
		div	d, #080
		add	b, temp_52
		inc	s

main_342:				; CODE XREF: __RESET+13C4j
					; __RESET+13CCj
		mov	b, a
		st	a, temp_51	; something dependant on temp, other maths could have been done
		tbbc	bit1, flags_48,	main_344
<<<<<<< HEAD
		ld	d, word_172	; nonzero and rapidly decreasing after start, larger peak from cold start
=======
		ld	d, word_172	; inversely temp dependant, additional math elsewhere
>>>>>>> origin/master
		shl	d
		mul	a, #171
		cmp	a, #038
		ble	main_343
		ld	a, #038

main_343:				; CODE XREF: __RESET+13E9j
		add	a, temp_51
		st	a, temp_51

main_344:				; CODE XREF: __RESET+13DEj
		ld	a, unk_109
		cmpb	a, #002
		beq	main_345
<<<<<<< HEAD
		tbbs	bit5, flags_45,	main_345 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbs	bit5, flags_45,	main_345 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		ld	a, unk_185
		and	a, #80h
		bne	main_345
		ld	a, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
		ld	y, #0C481h
		jsr	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB
		ld	b, temp_51
		sub	b, #128
		bcc	main_346
		add	a, b
		bcs	main_347

main_345:				; CODE XREF: __RESET+13F6j
					; __RESET+13F8j ...
		clr	a
		bra	main_347
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_346:				; CODE XREF: __RESET+140Ej
		add	a, b

main_347:				; CODE XREF: __RESET+1411j
					; __RESET+1414j
		st	a, unk_18E
		clr	a
		cmp	#100, RPM	; 5000RPM
		bcs	main_348
		cmp	#040, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
		bcs	main_348
		ld	y, #0C474h
		jsr	TwoD_rawTHW	; lookup Raw Water Temp, integer return	in Acca, fraction return in AccB

main_348:				; CODE XREF: __RESET+141Ej
					; __RESET+1423j
		sub	a, temp_51
		neg	a
		st	a, unk_18D	; im thinking it's a net retard, summed from a number of positive vales then negated
		ld	a, unk_18B
		ld	b, unk_106
		cmp	a, b
		bcs	main_350
		sub	a, #001
		bcc	main_349
		clr	a

main_349:				; CODE XREF: __RESET+143Cj
		cmp	a, b
		bcs	main_351
<<<<<<< HEAD
		bra	Timing_352
=======
		bra	main_352
>>>>>>> origin/master
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_350:				; CODE XREF: __RESET+1438j
		add	a, #001
		cmp	a, b
<<<<<<< HEAD
		bcs	Timing_352
=======
		bcs	main_352
>>>>>>> origin/master

main_351:				; CODE XREF: __RESET+1440j
		mov	b, a

<<<<<<< HEAD
Timing_352:				; CODE XREF: __RESET+1442j
					; __RESET+1447j
		st	a, unk_18B
		tbbs	bit7, flags_4C,	main_357 ; force timing	to 5deg	btdc
		ld	a, unk_185
		cmpb	a, #128
		bne	Timing_356	; set TE1 test mode timing to 10 degrees
		ld	y, #0C34Eh	; This looks like the timing table, compload in	53:54, RPM in D
=======
main_352:				; CODE XREF: __RESET+1442j
					; __RESET+1447j
		st	a, unk_18B
		tbbs	bit7, flags_4C,	main_357 ; 35degrees of	offset
		ld	a, unk_185
		cmpb	a, #128
		bne	main_356
		ld	y, #0C34Eh
>>>>>>> origin/master
		ld	d, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
		jsr	DivDby12	; divides D by 12, returns 16b result in unks 53:54
		ld	d, RPM		; MSB is RPM/50, LSB is	fraction of 50
		jsr	ThreeDtable	; inputs in D and temp_53:temp_54, output in D
<<<<<<< HEAD
		ld	b, ADC_pin15	; adc pin 15 (always 0)
		cmpb	b, #0Ch
		beq	Timing_355	; this will always branch
		cmpb	b, #08h
		bne	Timing_353
		sub	a, #009
		bra	Timing_354
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Timing_353:				; CODE XREF: __RESET+146Dj
		sub	a, #017

Timing_354:				; CODE XREF: __RESET+1471j
		bcc	Timing_355
		clr	a

Timing_355:				; CODE XREF: __RESET+1469j
					; __RESET:Timing_354j
		bra	Timing_363	; flag normal timing
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Timing_356:				; CODE XREF: __RESET+1455j
		tbbc	bit6, flags_45,	Timing_359 ; set TE1 test mode timing to 10 degrees
		cmp	#02h, unk_5E	; could	be last	unk_100, or 0
		bcc	Timing_359
		ld	d, #00341	; 10 deg
		bra	main_358	; flag forced timing
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_357:				; CODE XREF: __RESET+144Dj
		ld	d, #00299	; 5 degrees BTDC

main_358:				; CODE XREF: __RESET+1485j
					; __RESET+14B4j
		setb	bit3, flags_40	; flag forced timing
		st	d, Timing_NE	; set fixed timing
		clr	a
		st	a, byte_18A	; set to zero
		jmp	main_369	; timing algorithm is over now
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Timing_359:				; CODE XREF: __RESET:Timing_356j
					; __RESET+1480j
		ld	d, RPM		; MSB is RPM/50, LSB is	fraction of 50
		bmi	Timing_360
		shl	d		; increased resolution below 6350RPM

Timing_360:				; CODE XREF: __RESET+1498j
		ld	y, #0C3F9h
		jsr	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB
		tbbc	bit5, flags_45,	Timing_361 ; lower bound 10 deg
		tbbc	bit1, flags_45,	Timing_362 ; IC303 input chip: B7 /TE2,	B6 /TE1, B5 /NSW, B4 IGSW,  B3,	B2 IDL2, B1 , B0 STA

Timing_361:				; CODE XREF: __RESET+14A1j
		cmp	a, #085		; lower	bound 10 deg
		bcc	Timing_362
		ld	a, #085

Timing_362:				; CODE XREF: __RESET+14A4j
					; __RESET+14A9j
		tbbc	bit3, flags_43,	Timing_363 ; flag normal timing
=======
		ld	b, ADC_pin15	; adc pin 15 (0V)
		cmpb	b, #0Ch
		beq	main_355
		cmpb	b, #08h
		bne	main_353
		sub	a, #009
		bra	main_354
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_353:				; CODE XREF: __RESET+146Dj
		sub	a, #017

main_354:				; CODE XREF: __RESET+1471j
		bcc	main_355
		clr	a

main_355:				; CODE XREF: __RESET+1469j
					; __RESET:main_354j
		bra	main_363
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_356:				; CODE XREF: __RESET+1455j
		tbbc	bit6, flags_45,	main_359 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		cmp	#02h, unk_5E	; could	be last	unk_100, or 0
		bcc	main_359
		ld	d, #00341	; 40 deg
		bra	main_358
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_357:				; CODE XREF: __RESET+144Dj
		ld	d, #00299	; 35degrees of offset

main_358:				; CODE XREF: __RESET+1485j
					; __RESET+14B4j
		setb	bit3, flags_40
		st	d, unk_188	; initial timing calculation?
		clr	a
		st	a, byte_18A	; set to zero
		jmp	main_369
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_359:				; CODE XREF: __RESET:main_356j
					; __RESET+1480j
		ld	d, RPM		; MSB is RPM/50, LSB is	fraction of 50
		bmi	main_360
		shl	d		; increased resolution below 6350RPM

main_360:				; CODE XREF: __RESET+1498j
		ld	y, #0C3F9h
		jsr	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB
		tbbc	bit5, flags_45,	main_361 ; saturate around 10 deg
		tbbc	bit1, flags_45,	main_362 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA

main_361:				; CODE XREF: __RESET+14A1j
		cmp	a, #085		; saturate around 10 deg
		bcc	main_362
		ld	a, #085

main_362:				; CODE XREF: __RESET+14A4j
					; __RESET+14A9j
		tbbc	bit3, flags_43,	main_363 ; bit3: AFM bad bit4: rev limiter
>>>>>>> origin/master
		mov	a, b
		clr	a
		shl	d
		inc	a
<<<<<<< HEAD
		bra	main_358	; flag forced timing
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Timing_363:				; CODE XREF: __RESET:Timing_355j
					; __RESET:Timing_362j
		clrb	bit3, flags_40	; flag normal timing
		mov	a, b		; a had	output from 3d table c34e (scaled 0 to 60 deg)
=======
		bra	main_358
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_363:				; CODE XREF: __RESET:main_355j
					; __RESET:main_362j
		clrb	bit3, flags_40
		mov	a, b
>>>>>>> origin/master
		clr	a
		add	b, unk_18D	; im thinking it's a net retard, summed from a number of positive vales then negated
		addc	a, #00h
		add	b, byte_18C	; lookup from RPM by LOAD table
		addc	a, #00h
		shl	d
<<<<<<< HEAD
		cmp	d, Timing_NE	; represents the number	of NE ticks from TDC to	fire spark ( use formula 30*[(Timing_NE-1)+Timing_frac/256] )
		ble	Timing_364	; variable timing assignment, used to fire spark in NE_Sub1
		st	d, temp_51
		ld	d, Timing_NE	; represents the number	of NE ticks from TDC to	fire spark ( use formula 30*[(Timing_NE-1)+Timing_frac/256] )
		add	d, #0009h
		cmp	d, temp_51
		ble	Timing_364	; variable timing assignment, used to fire spark in NE_Sub1
		ld	d, temp_51

Timing_364:				; CODE XREF: __RESET+14C8j
					; __RESET+14D4j
		st	d, Timing_NE	; variable timing assignment, used to fire spark in NE_Sub1
		ld	a, unk_18B
		cmp	a, unk_18E
		bcc	Timing_365
		ld	a, unk_18E

Timing_365:				; CODE XREF: __RESET+14E1j
		tbbc	bit5, flags_4A,	Timing_366 ; bits 6,5,4	are inherited from 109.	6 seems	to always be low when no sub throttle exists
		cmp	a, #128
		bcc	Timing_366
		ld	a, #128

Timing_366:				; CODE XREF: __RESET:Timing_365j
					; __RESET+14EBj
		ld	b, byte_18A	; subtracted from timing in NEsub
		cmp	a, b
		bcc	Timing_368	; useful assignment of timing related
		sub	b, #04h
		bcc	Timing_367
		clr	a
		bra	Timing_368	; useful assignment of timing related
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Timing_367:				; CODE XREF: __RESET+14F7j
		cmp	a, b
		bcc	Timing_368	; useful assignment of timing related
		mov	b, a

Timing_368:				; CODE XREF: __RESET+14F3j
=======
		cmp	d, unk_188	; initial timing calculation?
		ble	main_364	; final	timing assignment?
		st	d, temp_51
		ld	d, unk_188	; initial timing calculation?
		add	d, #0009h
		cmp	d, temp_51
		ble	main_364	; final	timing assignment?
		ld	d, temp_51

main_364:				; CODE XREF: __RESET+14C8j
					; __RESET+14D4j
		st	d, unk_188	; final	timing assignment?
		ld	a, unk_18B
		cmp	a, unk_18E
		bcc	main_365
		ld	a, unk_18E

main_365:				; CODE XREF: __RESET+14E1j
		tbbc	bit5, flags_4A,	main_366
		cmp	a, #128
		bcc	main_366
		ld	a, #128

main_366:				; CODE XREF: __RESET:main_365j
					; __RESET+14EBj
		ld	b, byte_18A	; timing related
		cmp	a, b
		bcc	main_368	; useful assignment of timing related
		sub	b, #04h
		bcc	main_367
		clr	a
		bra	main_368	; useful assignment of timing related
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_367:				; CODE XREF: __RESET+14F7j
		cmp	a, b
		bcc	main_368	; useful assignment of timing related
		mov	b, a

main_368:				; CODE XREF: __RESET+14F3j
>>>>>>> origin/master
					; __RESET+14FAj ...
		st	a, byte_18A	; useful assignment of timing related

main_369:				; CODE XREF: __RESET+134Dj
					; __RESET+1493j
<<<<<<< HEAD
		di			; timing algorithm is over now
=======
		di
>>>>>>> origin/master
		ld	a, flags_77	; set bit 4, make a decision on	bit 4
		mov	a, b
		or	a, #10h
		st	a, flags_77	; set bit 4
		ei
		cmpb	b, #10h
		bne	main_379
		ld	y, #0C2EFh
		jsr	TwoD_rawTHW	; lookup Raw Water Temp, integer return	in Acca, fraction return in AccB
		mul	a, #0E9h
		sub	a, #0Ch
		bcc	main_370
		clr	a
		clr	b

main_370:				; CODE XREF: __RESET+151Aj
		st	d, temp_51
		ld	d, word_170	; nonzero and decreasing from cold start
		sub	d, #0008h
		ble	main_371
		cmp	d, temp_51
		bcc	main_372

main_371:				; CODE XREF: __RESET+1526j
		ld	d, temp_51

main_372:				; CODE XREF: __RESET+152Aj
<<<<<<< HEAD
		st	d, word_170	; nonzero and decreasing from cold start
		ld	d, word_172	; nonzero and rapidly decreasing after start, larger peak from cold start
=======
		st	d, word_170	; inversely temp dependant, additional math elsewhere
		ld	d, word_172	; inversely temp dependant, additional math elsewhere
>>>>>>> origin/master
		sub	d, #00024
		bcc	main_373
		clr	a
		clr	b

main_373:				; CODE XREF: __RESET+1537j
<<<<<<< HEAD
		st	d, word_172	; nonzero and rapidly decreasing after start, larger peak from cold start
		ld	a, unk_174
		ld	b, #03h
		cmp	#020, VTA_net	; WOT check
		ble	main_374
		cmp	#158, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
=======
		st	d, word_172	; inversely temp dependant, additional math elsewhere
		ld	a, unk_174
		ld	b, #03h
		cmp	#14h, VTA_net
		ble	main_374
		cmp	#9Eh, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
>>>>>>> origin/master
		bcs	main_374
		ld	b, #01h

main_374:				; CODE XREF: __RESET+1546j
					; __RESET+154Bj
		sub	a, b
		bcc	main_375
		clr	a

main_375:				; CODE XREF: __RESET+1550j
		st	a, unk_174
		ld	a, unk_D5
		sub	a, #01h
		bcc	main_376
		clr	a

main_376:				; CODE XREF: __RESET+155Aj
		st	a, unk_D5
		ld	d, word_16E	; inversely temp dependant, additional math elsewhere
		sub	d, #000Dh
		bcc	main_377
		clr	a
		clr	b

main_377:				; CODE XREF: __RESET+1565j
		st	d, temp_51
		ld	y, #0C313h
		jsr	TwoD_rawTHW	; lookup Raw Water Temp, integer return	in Acca, fraction return in AccB
		cmp	d, temp_51
		bcc	main_378
		ld	d, temp_51

main_378:				; CODE XREF: __RESET+1573j
		st	d, word_16E	; inversely temp dependant, additional math elsewhere

main_379:				; CODE XREF: __RESET+150Ej
		setb	bit2, flags_4A
		ld	y, #0C5BAh
		jsr	TwoD_RPM	; lookup RPM, integer return in	Acca, fraction return in AccB
		st	a, temp_51
		ld	a, unk_1CD
		ld	b, unk_6C	; sort of a filtered, saturated	VTA_net
		cmp	b, #2Fh
		bcc	main_380
		or	a, #01h

main_380:				; CODE XREF: __RESET+158Bj
		cmp	b, #32h
		ble	main_381
		and	a, #0FEh

main_381:				; CODE XREF: __RESET+1591j
		ld	b, RPM		; MSB is RPM/50, LSB is	fraction of 50
		cmp	b, #4Ch
		bcc	main_382
		and	a, #0FDh

main_382:				; CODE XREF: __RESET+1599j
		cmp	b, #50h
		bcs	main_383
		or	a, #02h

main_383:				; CODE XREF: __RESET+159Fj
<<<<<<< HEAD
		tbbs	bit6, flags_45,	main_385 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbs	bit6, flags_45,	main_385 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		ld	b, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
		cmp	b, temp_51
		bcc	main_384
		or	a, #04h

main_384:				; CODE XREF: __RESET+15AAj
		sub	b, #08h
		bcs	main_386
		cmp	b, temp_51
		ble	main_386

main_385:				; CODE XREF: __RESET:main_383j
		and	a, #0FBh

main_386:				; CODE XREF: __RESET+15B0j
					; __RESET+15B4j
		ld	b, unk_103
		cmpb	b, #08h
		beq	main_388
		tbbs	bit3, flags_43,	main_388 ; bit3: AFM bad bit4: rev limiter
<<<<<<< HEAD
		tbbs	bit4, flags_4A,	main_388 ; bits	6,5,4 are inherited from 109. 6	seems to always	be low when no sub throttle exists
		tbbc	bit5, flags_45,	main_387 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
		tbbc	bit6, flags_45,	main_388 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbs	bit4, flags_4A,	main_388
		tbbc	bit5, flags_45,	main_387 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		tbbc	bit6, flags_45,	main_388 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master

main_387:				; CODE XREF: __RESET+15C5j
		cmpb	a, #07h
		bne	main_388
		ld	b, #0Fh
		jsr	andFlags_50	; and b	with Flags_50
		bra	main_389
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_388:				; CODE XREF: __RESET+15BDj
					; __RESET+15BFj ...
		ld	b, #10h
		jsr	orFlags_50	; or b with Flags_50

main_389:				; CODE XREF: __RESET+15D4j
		st	a, unk_1CD
		cmp	#64h, unk_5E	; could	be last	unk_100, or 0
		bcs	main_390
		ld	x, #0308h
		ld	b, #01h
		jsr	sub_CF4C

main_390:				; CODE XREF: __RESET+15E1j
		cmp	#31h, count_CD	; incremented at E7A9
		beq	main_392
		bgt	main_393	; bounce if fuel pressure is up
<<<<<<< HEAD
		tbbc	bit0, flags_45,	main_395 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbc	bit0, flags_45,	main_395 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		ld	b, unk_103
		cmpb	b, #10h
		beq	main_395
		cmpb	b, #20h
		bne	main_391	; fuel pressure	down
		ld	a, word_308
		and	a, #01h
		beq	main_395

main_391:				; CODE XREF: __RESET+15FEj
		setb	bit2, PORTD_ASRIN ; fuel pressure down
		bra	main_395
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_392:				; CODE XREF: __RESET+15EEj
		ld	b, word_308
		and	b, #0FEh
		ld	x, #0308h
		jsr	sub_CF4E

main_393:				; CODE XREF: __RESET+15F0j
		tbbc	bit2, PORTD_ASRIN, main_394 ; bounce if	fuel pressure is up
		setb	bit2, flags_47

main_394:				; CODE XREF: __RESET:main_393j
		clrb	bit2, PORTD_ASRIN ; fuel pressure up

main_395:				; CODE XREF: __RESET+15F2j
					; __RESET+15FAj ...
		clr	a
<<<<<<< HEAD
		tbbs	bit7, flags_4C,	main_396 ; bit 7 set when not running (300 to 400 RPM gap)
		tbbc	bit0, flags_47,	main_396 ; bit4: high when hot (but how	hot?)
		ld	a, ADC_rq1D	; adc request 1D (probably pin 14, always 0)
=======
		tbbs	bit7, flags_4C,	main_396 ; bit 7 demands a sampling of the oxygen sensors
		tbbc	bit0, flags_47,	main_396 ; bit4: high when hot (but how	hot?)
		ld	a, ADC_rq1D	; adc request 1D (probably pin 14, 0V)
>>>>>>> origin/master
		and	a, #04h
		beq	main_397
		clr	a

main_396:				; CODE XREF: __RESET+161Ej
					; __RESET+1621j
		st	a, count_C0	; flag for Gx increments at E478
		st	a, count_C1	; flag for Gx increments at E478
		bra	main_400
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_397:				; CODE XREF: __RESET+1629j
		cmp	#0Fh, count_C0	; flag for Gx increments at E478
		bcs	main_398
		setb	bit6, flags_4F
		bra	main_400
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_398:				; CODE XREF: __RESET+1635j
		cmp	#0Fh, count_C1	; flag for Gx increments at E478
		bcs	main_399
		setb	bit6, flags_4F
		bra	main_400
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_399:				; CODE XREF: __RESET+163Ej
		cmp	#0Fh, count_BF	; increments at	E478
		bcs	main_401
		clrb	bit6, flags_4F

main_400:				; CODE XREF: __RESET+1630j
					; __RESET+1639j ...
		st	a, count_BF	; increments at	E478

main_401:				; CODE XREF: __RESET+1647j
		clr	a
		cmp	#7Ah, count_B9	; incremented at F55E
		bcs	main_402
		clr	unk_7F

main_402:				; CODE XREF: __RESET+1651j
<<<<<<< HEAD
		ld	b, flags_1AB	; buffers IC302	inputs for debouncing and storing into flags_1AA
		cmpb	b, #40h		; DI signal from FP ECU
		bne	main_403
		st	a, count_1A3	; increments at	E480
		tbbs	bit0, flags_45,	main_403 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
		cmp	#102, Bvolts	; 8V
		bcs	main_403
		tbbc	bit4, flags_45,	main_403 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		ld	b, flags_1AB	; flags_1AA related
		cmpb	b, #40h
		bne	main_403
		st	a, count_1A3	; increments at	E480
		tbbs	bit0, flags_45,	main_403 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		cmp	#102, Bvolts	; 8V
		bcs	main_403
		tbbc	bit4, flags_45,	main_403 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		cmp	#02h, unk_7F
		bcs	main_403
		ld	a, count_1A2	; increments at	E480
		cmp	a, #10h
		bcs	main_404
		setb	bit5, flags_4C
		bra	main_404
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_403:				; CODE XREF: __RESET+165Aj
					; __RESET+165Fj ...
		st	a, count_1A2	; increments at	E480

main_404:				; CODE XREF: __RESET+1674j
					; __RESET+1678j
		cmp	#020, RPM	; MSB is RPM/50, LSB is	fraction of 50
		bcs	main_405
		setb	bit7, flags_40

main_405:				; CODE XREF: __RESET+1680j
		ld	a, count_1A3	; increments at	E480
		cmp	a, #4Dh
		bcc	main_406
<<<<<<< HEAD
		tbbs	bit7, flags_40,	main_407 ; B3 :	forced timing to 5/10 deg BTDC
		tbbc	bit5, flags_4C,	main_408 ; bit 7 set when not running (300 to 400 RPM gap)
=======
		tbbs	bit7, flags_40,	main_407
		tbbc	bit5, flags_4C,	main_408 ; bit 7 demands a sampling of the oxygen sensors
>>>>>>> origin/master
		ld	a, flags_162
		or	a, #80h
		st	a, flags_162
		tbbc	bit3, flags_4B,	main_408
		setb	bit6, flags_4D
		ld	a, flags_163
		or	a, #80h
		st	a, flags_163
		bra	main_408
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

main_406:				; CODE XREF: __RESET+1689j
		clrb	bit5, flags_4C

main_407:				; CODE XREF: __RESET+168Bj
		ld	x, #0D256h
		ld	y, #0149h
		jsr	sub_D222

main_408:				; CODE XREF: __RESET+168Ej
					; __RESET+1699j ...
		clr	a
<<<<<<< HEAD
		ld	x, word_172	; nonzero and rapidly decreasing after start, larger peak from cold start
=======
		ld	x, word_172	; inversely temp dependant, additional math elsewhere
>>>>>>> origin/master
		beq	main_409
		or	a, #01h

main_409:				; CODE XREF: __RESET+16B7j
<<<<<<< HEAD
		ld	x, word_170	; nonzero and decreasing from cold start
=======
		ld	x, word_170	; inversely temp dependant, additional math elsewhere
>>>>>>> origin/master
		beq	main_410
		or	a, #02h

main_410:				; CODE XREF: __RESET+16BEj
		ld	b, unk_140	; bits 5,0 oxl2	related
		and	b, #02h
		beq	main_411
		or	a, #20h

main_411:				; CODE XREF: __RESET+16C7j
		ld	b, unk_15C	; bits 5,0 oxr2	related
		and	b, #02h
		beq	main_412
		or	a, #80h

main_412:				; CODE XREF: __RESET+16D0j
<<<<<<< HEAD
		ld	b, unk_197	; subtracted from timing in main loop
=======
		ld	b, unk_197	; timing related
>>>>>>> origin/master
		beq	main_413
		or	a, #40h

main_413:				; CODE XREF: __RESET+16D7j
<<<<<<< HEAD
		st	a, flags_1C5
=======
		st	a, unk_1C5
>>>>>>> origin/master
		clr	b
		ld	a, flags_1C6	; written at end of main loop; B3 /NSW (/STA), b2 , b1 IDL1, b0	STA
		and	a, #80h
<<<<<<< HEAD
		tbbc	bit0, flags_45,	main_414 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbc	bit0, flags_45,	main_414 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		or	a, #01h

main_414:				; CODE XREF: __RESET+16E4j
		tbbc	bit0, flags_41,	main_415 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
		or	a, #02h

main_415:				; CODE XREF: __RESET:main_414j
<<<<<<< HEAD
		tbbc	bit1, flags_45,	main_416 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
		or	a, #04h

main_416:				; CODE XREF: __RESET:main_415j
		tbbc	bit5, flags_45,	main_417 ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbc	bit1, flags_45,	main_416 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		or	a, #04h

main_416:				; CODE XREF: __RESET:main_415j
		tbbc	bit5, flags_45,	main_417 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		or	a, #08h

main_417:				; CODE XREF: __RESET:main_416j
		tbbc	bit0, flags_49,	main_418 ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		or	a, #10h

main_418:				; CODE XREF: __RESET:main_417j
		tbbc	bit2, flags_49,	main_419 ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		or	a, #20h

main_419:				; CODE XREF: __RESET:main_418j
<<<<<<< HEAD
		st	a, flags_1C6	; written at end of main loop; B3 /NSW (/STA), b2 , b1 IDL1, b0	STA
		ld	b, flags_45	; IC303	input chip: B7 /TE2, B6	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		st	b, f45_shadow	; shadows flags_45
=======
		st	a, unk_1C6
		ld	b, flags_45	; IC303	input chip: B7 /TE2, B /TE1, B5	/NSW, B4 IGSW,	B3, B2 IDL2, B1	, B0 STA
		st	b, unk_F8
>>>>>>> origin/master
		ld	d, InjectPW1	; pulsewidth for LEFT bank (odd	cyl), 4us/bit
		jsr	sub_EC27
		st	b, InjPW_LOres	; injector pulsewidth divided by 32 and	saturated at 8 bits
		ld	d, RPM		; MSB is RPM/50, LSB is	fraction of 50
		shl	d
		bcc	main_420	; this will crap out at	6350 RPM
		ld	a, #0FFh

main_420:				; CODE XREF: __RESET+1715j
<<<<<<< HEAD
		st	a, RPM_HIres	; RPM/25
=======
		st	a, unk_1C9
>>>>>>> origin/master
		ld	d, meanKSint	; deltaKS/KS_count, filtered
		shl	d
		bcc	main_421
		ld	a, #0FFh

main_421:				; CODE XREF: __RESET+171Fj
		st	a, byte_1C7	; last meanKSint MSB *2, saturated at ff
		ld	a, VTA_net
<<<<<<< HEAD
		st	a, lastVTAnet	; last VTA_net
		ld	a, VTA1_net	; VTA1 - VTA_min
		st	a, lastVTA1net	; last VTA1-Offset
=======
		st	a, byte_F4	; last VTA_net
		ld	a, VTA1_net	; VTA1 - VTA_min
		st	a, byte_F5	; last VTA1-Offset
>>>>>>> origin/master
		clr	a
		tbbs	bit0, flags_4D,	main_422
		ld	a, unk_100

main_422:				; CODE XREF: __RESET+1730j
		st	a, unk_5E	; could	be last	unk_100, or 0
		jsr	sub_D257
		nop			; please insert	user subroutine	here in	the form of "jsr beepboop"
		nop
		nop
		ld	#33h, TAIT	; re-init critical registers
		ld	#0C3h, DDRA	; Port A i/o config
		ld	#3Fh, DDRB	; Port B i/o config
		ld	#1Eh, ASR0P	; ASR0 pos edge	counter	value MSB
		ld	#0Fh, ASR0PL	; ASR0 pos edge	counter	value LSB
		ld	#0FDh, ASR1P	; ASR1 pos edge	counter	value MSB
		ld	#30h, ASR0NL	; ASR0 neg edge	counter	value LSB
		ld	#08h, unk_1D	; bit3 seems to	be a uart global clock output enable
		ld	#30h, SMRC_SIR	; Serial Master	Register Control
		clrb	bit3, SSD
		clrb	bit2, DOM
		clrb	bit3, DOM
		di
		ld	a, asr0n_shadow	; stores configuration information written to asr0n
		and	a, #0C0h
		add	a, #34h
		st	a, asr0n_shadow	; stores configuration information written to asr0n
		ei
		ld	s, #02DFh

EndMainLoop:
		jmp	MainLoop
; END OF FUNCTION CHUNK	FOR __RESET

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_EC27:				; CODE XREF: __RESET+170Cp
		add	d, InjDeadtime	; injector deadtime, 4us/bit
		jsr	divDby32	; shift	D right	5 times
		cmpz	a
		beq	locret_EC32
		ld	b, #0FFh

locret_EC32:				; CODE XREF: sub_EC27+7j
		ret
; End of function sub_EC27

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

		; public intASR2
intASR2:				; DATA XREF: ROM:FFFAo
		push	x		; interrupts for NE
		push	y
		clrb	bit6, IRQLL	; clear	interrupt flag
		ld	b, NEcounts
		mov	b, a
		tbbc	bit4, PORTA, intASR2_4 ; Low bit indicates G1 pulse just prior to this NE
		tbbc	bit5, PORTA, intASR2_3 ; Low bit indicates G2 pulse just prior to this NE
		cmpz	b
		beq	intASR2_5
		cmp	b, #024		; 24 NE's to the Gn
		bcc	intASR2_1
		inc	b
		cmp	b, #013
		bne	intASR2_5
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  8Ch ; Œ		; cmp x, makes a three byte NOP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intASR2_1:				; CODE XREF: ROM:EC45j
		ld	b, #001

intASR2_2:				; CODE XREF: ROM:EC66j	ROM:EC70j
		tbbs	bit7, flags_4C,	intASR2_5 ; bit	7 set when not running (300 to 400 RPM gap)
		cmpz	a
		beq	intASR2_5
		setb	bit4, flags_46
		tbbc	bit3, flags_4B,	intASR2_5
		setb	bit6, flags_4D
		setb	bit7, flags_4F
		bra	intASR2_5
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intASR2_3:				; CODE XREF: ROM:EC3Dj
		ld	b, #001		; G2 triggered,	meaning	this NE	is 10DBTDC cyl #1
		inc	unk_7F
		cmp	a, #024
		bne	intASR2_2
		bra	intASR2_5
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intASR2_4:				; CODE XREF: ROM:EC3Aj
		ld	b, #013		; G1 triggered,	meaning	this NE	is 10DBTDC cyl #6
		inc	unk_7F
		cmp	a, #012
		bne	intASR2_2

intASR2_5:				; CODE XREF: ROM:EC41j	ROM:EC4Aj ...
		st	b, NEcounts
		ld	d, ASR2		; ASR2 edge counter value MSB
		mov	d, x
		cmp	#08h, count_B9	; incremented at F55E
		bcc	intASR2_6	; 152 RPM
		sub	d, lastASR2
		cmp	a, #20h		; limit	timer counts since last	interrupt 8192,	152 RPM
		bcs	intASR2_7

intASR2_6:				; CODE XREF: ROM:EC7Aj
		ld	d, #08192	; 152 RPM

intASR2_7:				; CODE XREF: ROM:EC81j
		st	x, lastASR2
		cmp	#02h, unk_7F
		bcc	intASR2_8
		cmp	#06h, count_B9	; incremented at F55E
		ble	intASR2_9
		clr	unk_7F
		bra	intASR2_9
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intASR2_8:				; CODE XREF: ROM:EC8Cj
		ld	#02h, unk_7F

intASR2_9:				; CODE XREF: ROM:EC91j	ROM:EC95j
		clr	count_B9	; incremented at F55E
		cmp	#00h, NEcounts
		bne	intASR2_10
		jmp	ASR2_reti	; bomb out of interrupt	if NEcounts is zero
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intASR2_10:				; CODE XREF: ROM:EC9Fj
		tbs	bit0, flags_4A	; bits 6,5,4 are inherited from	109. 6 seems to	always be low when no sub throttle exists
		beq	intASR2_11
		ld	y, #0060h
		xch	a, y + 02h	; word 62 (most	current	deltaNE	is here)
		xch	b, y + 03h
		xch	a, y + 00h	; word 60 (last	deltaNE	is now here)
		xch	b, y + 01h
		add	d, deltaNE	; deltaNE from interrupt before	last is	now in D
		add	d, deltaNE_1
		st	d, threeDeltaNE
		cmp	d, #00568	; rev limit 6602 RPM
		bcc	intASR2_11
		setb	bit3, flags_44	; smells like a	rev limiter
		setb	bit4, flags_43

intASR2_11:				; CODE XREF: ROM:ECA6j	ROM:ECBCj
		ld	y, #00C0h
		cmp	#013, NEcounts
		beq	intASR2_12
		inc	y
		cmp	#001, NEcounts
		bne	intASR2_17	; asr3 irq flag	(G1)

intASR2_12:				; CODE XREF: ROM:ECC8j
		tbbc	bit0, flags_41,	intASR2_14 ; B0	IDL1, b5 indidcates something about ram	stats during last suspend
		ld	d, threeDeltaNE
		cmp	d, #01500	; 2500 RPM
		bcs	intASR2_14
		cmp	d, #16384	; 229RPM
		bcc	intASR2_14
<<<<<<< HEAD
		tbbs	bit4, flags_46,	intASR2_15 ; bit 1 flags limp in injection mode, B5 RPM	under 5200ish
=======
		tbbs	bit4, flags_46,	intASR2_15 ; bit 1 flags limp in injection mode
>>>>>>> origin/master
		clr	a
		ld	b, threeDeltaNE
		div	d, #026		; divide MSB
		push	b		; b is integer result
		ld	b, threeDeltaNEl
		div	d, #026		; divide LSB
		pull	a		; now contains timer counts per	3.5 degrees (90/26)
		sub	d, deltaNE_1	; which	shouldnt ever be smaller than d
		bcc	intASR2_15	; this branch would occur if there was problems
		neg	a
		neg	b
		subc	a, #00h
		push	d		; this part of the stack now has the number of timer counts for	26.5 degrees
		ld	d, threeDeltaNE	; threeDeltaNE is the duration (in timer counts) of the	last 90	degrees	of crank rotation
		shl	d
		shl	d		; times	4
		push	b
		mov	a, b
		clr	a
		div	d, #090
		mov	s, x
		xch	b, x + 00h	; a contains modulo from division, X+00	is pushed LSB, b contains division result
		div	d, #090
		pull	a
		push	d		; d contains result of 4*threeDeltaNE/90, or timer counts per 4	degrees
		ld	d, lastASR2
		sub	d, ASR3		; last G1 edge
		mov	s, x
		cmp	d, x + 02h	; 26.5 degree time
		bgt	intASR2_13
		cmp	d, x + 00h	; 4 degree time
		bcs	intASR2_13
		clr	y + 00h		; clearing this	variable is proper operation

intASR2_13:				; CODE XREF: ROM:ED0Ej	ROM:ED12j
		pull	x
		pull	x		; tidy stack
		bra	intASR2_16
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intASR2_14:				; CODE XREF: ROM:intASR2_12j ROM:ECD8j ...
		clr	y + 00h

intASR2_15:				; CODE XREF: ROM:ECDFj	ROM:ECEFj
		clr	count_BF	; increments at	E478

intASR2_16:				; CODE XREF: ROM:ED18j
		clrb	bit4, flags_46
		bra	intASR2_18	; service G1 flag
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intASR2_17:				; CODE XREF: ROM:ECCEj
		tbbc	bit7, IRQLL, intASR2_19	; asr3 irq flag	(G1)
		setb	bit4, flags_46

intASR2_18:				; CODE XREF: ROM:ED20j
		clrb	bit7, IRQLL	; service G1 flag

intASR2_19:				; CODE XREF: ROM:intASR2_17j
		clr	a
		ld	b, deltaNE_1	; one deltaNE is 30 degrees of crank rotation
		div	d, #003
		push	b
		ld	b, deltaNE_1l
		div	d, #003
		pull	a		; D now	contains the duration in timer counts of 10 degrees crank rotation
		add	d, ASR2		; ASR2 edge counter value MSB
		setb	bit1, DOM
		st	d, CPR1		; compare 1 is triggered 10 deg	after NE pulse
		ld	b, NEcounts
		cmp	b, #024
		bne	intASR2_20
		clrb	bit1, PORTA

intASR2_20:				; CODE XREF: ROM:ED3Ej
		clr	a
		dec	b
		div	d, #003
		st	a, ModuloNE	; will have a number from 0 to 2
		cmpz	a
		beq	intASR2_21
		cmp	a, #002		; 2 would be 40	deg BTDC
		bne	intASR2_26
		bra	intASR2_25
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intASR2_21:				; CODE XREF: ROM:ED49j
		clrb	bit1, DOUT
		ld	b, unk_E5
		and	b, #0FCh
		tbbc	bit0, PORTC, intASR2_22	; Port C Data Register
		or	b, #08h

intASR2_22:				; CODE XREF: ROM:ED57j
		tbbs	bit7, PORTB, intASR2_23	; Port B Data Register
		or	b, #02h

intASR2_23:				; CODE XREF: ROM:intASR2_22j
		tbbs	bit6, PORTB, intASR2_24	; Port B Data Register
		or	b, #01h

intASR2_24:				; CODE XREF: ROM:intASR2_23j
		st	b, unk_E5

intASR2_25:				; CODE XREF: ROM:ED4Fj
		jmp	intASR2_39
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intASR2_26:				; CODE XREF: ROM:ED4Dj
		setb	bit1, DOUT
		setb	bit1, PORTA
		tbbs	bit7, flags_4C,	intASR2_28 ; bit 7 set when not	running	(300 to	400 RPM	gap)
		tbbc	bit5, RAMST, intASR2_28	; Built-in RAM status
		ld	a, unk_E5
		mov	a, b
		tbbc	bit0, PORTC, intASR2_27	; Port C Data Register
		add	b, #04h

intASR2_27:				; CODE XREF: ROM:ED78j
		shr	b
		shr	b
		and	b, #03h
		shr	b
		rorc	b
		bvc	intASR2_32
		bcs	intASR2_34
		tbbs	bit3, flags_43,	intASR2_35 ; bit3: AFM bad bit4: rev limiter
		cmp	#3Ch, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
		bcs	intASR2_35
<<<<<<< HEAD
		ld	a, byte_186	; subtracted from timing in NEsub
=======
		ld	a, byte_186	; timing related
>>>>>>> origin/master
		bne	intASR2_35
		ld	a, unk_103
		cmpb	a, #40h
		beq	intASR2_35
		tbbs	bit5, flags_4A,	intASR2_35 ; bits 6,5,4	are inherited from 109.	6 seems	to always be low when no sub throttle exists
		cmp	#032, RPM	; MSB is RPM/50, LSB is	fraction of 50
		bcs	intASR2_35
		cmp	#104, RPM	; MSB is RPM/50, LSB is	fraction of 50
		bcc	intASR2_35
		cmp	#011, unk_E6
		bcc	intASR2_29
		inc	unk_E6
		bra	intASR2_36
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intASR2_28:				; CODE XREF: ROM:ED6Fj	ROM:ED72j
		bra	intASR2_37
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intASR2_29:				; CODE XREF: ROM:EDABj
		ld	b, #0Fh
		tbbs	bit0, IRQLL, intASR2_30	; IRL flag, shouldnt be	used.
		ld	b, #0F0h

intASR2_30:				; CODE XREF: ROM:EDB5j
		ld	a, unk_19E
		st	b, unk_19E
		cmp	a, unk_19E
		bne	intASR2_36
		cmp	a, #0Fh
		beq	intASR2_31
		setb	bit5, flags_4E
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  8Ch ; Œ		; cmp x, a three byte NOP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intASR2_31:				; CODE XREF: ROM:EDC7j
		setb	bit7, flags_4E
		setb	bit0, flags_46
		bra	intASR2_36
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intASR2_32:				; CODE XREF: ROM:ED83j
		ld	b, unk_E8
		beq	intASR2_33
		ld	b, #0Bh
		st	b, unk_E8

intASR2_33:				; CODE XREF: ROM:EDD4j
		cmp	#013, RPM	; MSB is RPM/50, LSB is	fraction of 50
		bcs	intASR2_36
		cmp	#104, RPM	; 5200RPM
		bcc	intASR2_36
		and	a, #0E0h
		add	a, #20h
		bcc	intASR2_38
		clrb	bit2, DOUT
		tbs	bit2, flags_41	; B0 IDL1, b5 indidcates something about ram stats during last suspend
		beq	intASR2_37
		setb	bit6, flags_4E
		ld	a, #0Bh
		st	a, unk_E8
		bra	intASR2_37
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intASR2_34:				; CODE XREF: ROM:ED85j
		clr	unk_E8
		clrb	bit6, flags_4E

intASR2_35:				; CODE XREF: ROM:ED87j	ROM:ED8Dj ...
		cmp	#0Bh, unk_E6
		bcc	intASR2_36
		clr	unk_E6

intASR2_36:				; CODE XREF: ROM:EDAFj	ROM:EDC3j ...
		clrb	bit2, flags_41

intASR2_37:				; CODE XREF: ROM:intASR2_28j ROM:EDEEj ...
		ld	a, #40h

intASR2_38:				; CODE XREF: ROM:EDE8j
		ld	b, unk_E5
		and	b, #03h
		add	a, b
		st	a, unk_E5
		setb	bit2, DOUT

intASR2_39:				; CODE XREF: ROM:intASR2_25j
		ld	a, ModuloNE	; contains modulo: NEcounts%3, represents 30 degree chunks after 10dBTDC cylinder NEcounts/3
		tbbc	bit2, flags_40,	intASR2_41 ; B3	: forced timing	to 5/10	deg BTDC
		setb	bit0, DOM	; IGT bit related
		cmpz	a
		beq	intASR2_40	; bounce if 10 deg BTDC, looks like failsafe timing, 30	degrees	dwell, 10 deg BTDC spark
		cmp	a, #002
		bne	ASR2_reti
		setb	bit0, DOUT	; set IGT bit
		jsr	Cmp0NOW
		bra	ASR2_reti
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intASR2_40:				; CODE XREF: ROM:EE18j
		clrb	bit0, DOUT	; clear	IGT bit, fire spark @ 10 deg BTDC
		jsr	Cmp0NOW
		bra	intASR2_42
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intASR2_41:				; CODE XREF: ROM:EE12j
		cmpz	a
		bne	intASR2_43
		ld	a, unk_18F	; final	timing related
		jsr	NEsub1_18	; we end up here if we're late, which is why we're checking target NEcounts+1

intASR2_42:				; CODE XREF: ROM:EE2Aj
		setb	bit2, flags_40
		tbbs	bit7, flags_4C,	ASR2_reti ; bit	7 set when not running (300 to 400 RPM gap)
		clrb	bit2, flags_40

intASR2_43:				; CODE XREF: ROM:EE2Dj
		jsr	NEsub1

ASR2_reti:				; CODE XREF: ROM:ECA1j	ROM:EE1Cj ...
		clrb	bit5, flags_4F
		clrb	bit4, PORTAL
		clrb	bit5, PORTAL
		setb	bit6, flags_44
		setb	bit1, IRQLL	; trigger IV6
		pull	y
		pull	x
		reti

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


NEsub1:					; CODE XREF: ROM:intASR2_43p
		ld	a, ModuloNE	; contains modulo: NEcounts%3, represents 30 degree chunks after 10dBTDC cylinder NEcounts/3
		beq	NEsub1_1	; bounce only if 10 deg	BTDC
		jmp	NEsub1_17	; skip timing calculation?
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEsub1_1:				; CODE XREF: NEsub1+2j
		clr	a
		clr	b
<<<<<<< HEAD
		tbbs	bit3, flags_40,	NEsub1_3 ; B3 :	forced timing to 5/10 deg BTDC
		ld	b, byte_18A	; subtracted from timing in NEsub
		shl	d
		cmpz	a
		bne	NEsub1_3
		cmp	b, byte_186	; was 0	mostly in superrun
		bcc	NEsub1_2	; select highest
		ld	b, byte_186	; subtracted from timing in NEsub

NEsub1_2:				; CODE XREF: NEsub1+16j
		cmp	b, unk_197	; subtracted from timing in main loop
		bcc	NEsub1_3	; select highest
		ld	b, unk_197	; subtracted from timing in main loop

NEsub1_3:				; CODE XREF: NEsub1+9j	NEsub1+11j ...
		push	d
		ld	d, Timing_NE	; represents the number	of NE ticks from TDC to	fire spark ( use formula 30*[(Timing_NE-1)+Timing_frac/256] )
=======
		tbbs	bit3, flags_40,	NEsub1_3
		ld	b, byte_18A	; timing related
		shl	d
		cmpz	a
		bne	NEsub1_3
		cmp	b, byte_186	; timing related
		bcc	NEsub1_2	; select highest
		ld	b, byte_186	; timing related

NEsub1_2:				; CODE XREF: NEsub1+16j
		cmp	b, unk_197	; timing related
		bcc	NEsub1_3	; select highest
		ld	b, unk_197	; timing related

NEsub1_3:				; CODE XREF: NEsub1+9j	NEsub1+11j ...
		push	d
		ld	d, unk_188	; initial timing calculation?
>>>>>>> origin/master
		mov	s, x
		sub	d, x + 00h	; subtract the largest of 2*18A, 186 or	197
		bcc	NEsub1_4
		clr	a
		clr	b

NEsub1_4:				; CODE XREF: NEsub1+2Aj
		pull	x
		clrb	bit4, flags_40
		cmp	#022, NEcounts	; 10 deg BTDC2
		beq	NEsub1_5	; upper	bound data (60 deg)
		cmp	#007, NEcounts	; 10 deg BTDC 4
		beq	NEsub1_5	; upper	bound data (60 deg)
		cmp	#016, NEcounts	; 10 deg BTDC5
		beq	NEsub1_5	; upper	bound data (60 deg)
		push	a
		ld	a, unk_185
		cmpb	a, #01h		; looking for lsb
		pull	a
		beq	NEsub1_5	; lsb low prevents addition below
		add	d, #00026	; add 3	deg
		setb	bit4, flags_40

NEsub1_5:				; CODE XREF: NEsub1+34j NEsub1+39j ...
		cmp	d, #00768	; upper	bound data (60 deg)
		ble	NEsub1_6	; lower	bound data (4 deg)
		ld	d, #00768	; saturate at 768 (300h)

NEsub1_6:				; CODE XREF: NEsub1+51j
		cmp	d, #00290	; lower	bound data (4 deg)
		bcc	NEsub1_7	; skip the word_193 stuff
		ld	d, #00290	; saturate at 290 (122h)

NEsub1_7:				; CODE XREF: NEsub1+59j
		tbbc	bit6, flags_42,	NEsub1_12 ; skip the word_193 stuff
		push	d
		mov	s, x		; stack	now points to limited value
		ld	d, word_193
<<<<<<< HEAD
		tbbs	bit0, flags_42,	NEsub1_9 ; 4 deg
		cmp	#020, RPM	; 1000 RPM
		ble	NEsub1_9	; 4 deg
		tbbs	bit5, flags_42,	NEsub1_8
		tbbc	bit0, flags_41,	NEsub1_9 ; 4 deg
=======
		tbbs	bit0, flags_42,	NEsub1_9
		cmp	#020, RPM	; 1000 RPM
		ble	NEsub1_9
		tbbs	bit5, flags_42,	NEsub1_8
		tbbc	bit0, flags_41,	NEsub1_9 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
>>>>>>> origin/master
		add	d, #00002
		bra	NEsub1_10
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEsub1_8:				; CODE XREF: NEsub1+6Ej
		cmp	#036, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
<<<<<<< HEAD
		bcc	NEsub1_9	; 4 deg
=======
		bcc	NEsub1_9
>>>>>>> origin/master
		add	d, #0002h
		bra	NEsub1_10
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEsub1_9:				; CODE XREF: NEsub1+66j NEsub1+6Cj ...
		add	d, #00034	; 4 deg

NEsub1_10:				; CODE XREF: NEsub1+77j NEsub1+81j
		cmp	d, x + 00h
		ble	NEsub1_11	; provided calculated stuff was	greater	than 193, keep 193 as it
		ld	d, x + 00h	; get the calculated timing, minus nesub retards
		clrb	bit6, flags_42
		clrb	bit5, flags_42

NEsub1_11:				; CODE XREF: NEsub1+88j
		st	d, word_193
		pull	x		; tidy stack

NEsub1_12:				; CODE XREF: NEsub1:NEsub1_7j
		tbbs	bit4, flags_40,	NEsub1_13 ; this is where the magic begins, 43 counts/768*90=5 degrees
		mov	d, x
		shr	d
		shr	d
		st	b, final_timing	; final	timing (multiply by 60/256)
		mov	x, d

NEsub1_13:				; CODE XREF: NEsub1:NEsub1_12j
		sub	d, #00811	; this is where	the magic begins, 43 counts/768*90=5 degrees
		neg	a
		neg	b
		subc	a, #00h
		shr	b
		add	a, NEcounts
		cmp	a, #024
		ble	NEsub1_14
		sub	a, #024

NEsub1_14:				; CODE XREF: NEsub1+AAj
		cmp	a, NEcounts
		beq	NEsub1_16	; only write to	18f, 190, 190 seems to be timing related
		cmp	b, RPM		; MSB is RPM/50, LSB is	fraction of 50
		bcc	NEsub1_16	; only write to	18f, 190, 190 seems to be timing related

NEsub1_15:				; CODE XREF: NEsub1_18+2Fj
		dec	a
		add	b, #128
		bcc	NEsub1_16	; only write to	18f, 190, 190 seems to be timing related
		ld	b, #0FFh	; saturate

NEsub1_16:				; CODE XREF: NEsub1+B0j NEsub1+B4j ...
		st	d, unk_18F	; only write to	18f, 190, 190 seems to be timing related

NEsub1_17:				; CODE XREF: NEsub1+4j
		ld	a, unk_18F	; 18f perhaps stores the necount modulo	to offset 190 from?
		cmp	a, NEcounts
		beq	NEsub1_20
; End of function NEsub1


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; we end up here if we're late, which is why we're checking target NEcounts+1

NEsub1_18:				; CODE XREF: ROM:EE32p
		inc	a
		cmp	a, #024
		ble	NEsub1_19
		ld	a, #01h

NEsub1_19:				; CODE XREF: NEsub1_18+3j
		cmp	a, NEcounts
		bne	NEsub1_ret2
		ld	a, unk_190
		bsr	calcIGT_time	; accepts ratio	in AccA
		clrc			; possibly turn	off IGt
		tbbs	bit0, LDOUT, NEsub1_divert ; bounces immediately to Cmp0IGTdwell
		setb	bit5, flags_40

NEsub1_ret2:				; CODE XREF: NEsub1_18+9j
		ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEsub1_20:				; CODE XREF: NEsub1+C5j
		ld	a, unk_190
		bsr	calcIGT_time	; accepts ratio	in AccA
		cmp	#00h, ModuloNE	; contains modulo: NEcounts%3, represents 30 degree chunks after 10dBTDC cylinder NEcounts/3
		setc
		bne	NEsub1_divert	; bounces immediately to Cmp0IGTdwell
		ld	a, unk_190
		cmp	a, RPM		; MSB is RPM/50, LSB is	fraction of 50
		bcc	NEsub1_ret1
		jsr	Cmp0IGTdwell	; sets IGt if carry is set
		ld	d, unk_18F	; final	timing related
		bra	NEsub1_15
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEsub1_ret1:				; CODE XREF: NEsub1_18+27j
		setc
		tbbc	bit0, LDOUT, NEsub1_divert ; bounces immediately to Cmp0IGTdwell
		setb	bit6, flags_40
		ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEsub1_divert:				; CODE XREF: NEsub1_18+11j
					; NEsub1_18+20j ...
		jmp	Cmp0IGTdwell	; bounces immediately to Cmp0IGTdwell
; End of function NEsub1_18


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; accepts ratio	in AccA

calcIGT_time:				; CODE XREF: NEsub1_18+Ep
					; NEsub1_18+1Ap
		push	a
		mul	a, threeDeltaNE
		mov	d, y
		pull	a
		mul	a, threeDeltaNEl
		addc	a, #00h
		add	y, a		; here we have the upper 16b of	a*threeDeltaNE in Y
		ld	a, #171		; fraction 2/3
		jsr	MulAbyY		; returns upper	16b in AccD
		add	d, lastASR2
		st	d, IGT_time
		ret
; End of function calcIGT_time


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


		; public IV6
IV6:					; DATA XREF: ROM:FFEAo

; FUNCTION CHUNK AT F3CA SIZE 00000160 BYTES
; FUNCTION CHUNK AT F52E SIZE 0000013B BYTES

		clrb	bit1, IRQLL
		push	x
		push	y
		tbbc	bit6, flags_44,	IV6_1 ;	bit 1 is igf1 related, bit2 igf2 related
		clrb	bit6, flags_44
		jmp	IV6_2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IV6_1:					; CODE XREF: IV6+4j IV6:IV6_44j
		tbbc	bit3, flags_4A,	IV6_ret	; bomb out
		clrb	bit3, flags_4A
		jmp	IV6_TXadc
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IV6_ret:				; CODE XREF: IV6:IV6_1j IV6:loc_F666j
		pull	y		; bomb out
		pull	x
		reti
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IV6_2:					; CODE XREF: IV6+9j IV6+1CEj
		ld	a, NEcounts
		mov	a, b
		xch	b, NEcountsIV6	; buffered copy	of NEcounts for	IV6 purposes
		beq	IV6_4
		cmpz	b
		beq	IV6_6
		cmp	a, b
		beq	IV6_5		; skip a lot of	IV6
		dec	a
		bne	IV6_3
		ld	a, #024

IV6_3:					; CODE XREF: IV6+25j
		cmp	a, b
		beq	IV6_6
		clrb	bit3, flags_47
		st	a, NEcountsIV6	; buffered copy	of NEcounts for	IV6 purposes
		bra	IV6_6
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IV6_4:					; CODE XREF: IV6+1Cj
		tbbc	bit5, flags_47,	IV6_5 ;	skip a lot of IV6
		clrb	bit5, flags_47
		tbs	bit5, flags_41	; B0 IDL1, b5 indidcates something about ram stats during last suspend
		beq	IV6_5		; skip a lot of	IV6
		ld	a, unk_D2
		clr	b
		shr	d
		shr	d
		jsr	DoAllInj	; inject the value of unk_D2 multiplied	by 64

IV6_5:					; CODE XREF: IV6+22j IV6:IV6_4j ...
		jmp	IV6_43		; skip a lot of	IV6
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IV6_6:					; CODE XREF: IV6+1Fj IV6+2Aj ...
		clr	a
		div	d, #03h
		st	d, unk_58
		ld	a, unk_58
		shr	a
		bcc	IV6_14
		ld	b, NEcountsIV6	; buffered copy	of NEcounts for	IV6 purposes
		cmp	b, #02h
		beq	IV6_7		; clear	bit 0
		cmp	b, #05h
		beq	IV6_7		; clear	bit 0
		cmp	b, #0Eh
		beq	IV6_7		; clear	bit 0
		cmp	b, #11h
		bne	IV6_8		; clear	bit 6

IV6_7:					; CODE XREF: IV6+54j IV6+58j ...
		ld	a, flags_77	; clear	bit 0
		and	a, #0FEh
		st	a, flags_77	; clear	bit 0

IV6_8:					; CODE XREF: IV6+60j
		ld	a, flags_77	; clear	bit 6
		and	a, #0BFh
		st	a, flags_77	; clear	bit 6
		di
		clr	a
		ld	b, deltaKS	; Cumulative sum of KS intervals, counted by KS_count, reset in	IV6
		div	d, KS_count	; counts KS interrupts,	reset in IV6
		bcs	IV6_12
		push	b		; push the fraction
		ld	b, deltaKSl
		div	d, KS_count	; counts KS interrupts,	reset in IV6
		ld	a, KS_count2
		add	a, KS_count	; counts KS interrupts,	reset in IV6
		bcc	IV6_9
		ld	a, #0FFh

IV6_9:					; CODE XREF: IV6+82j
		st	a, KS_count2
		clr	a
		st	a, KS_count	; clear	it
		st	a, deltaKS	; clear	it
		st	a, deltaKSl	; clear	it
		ei
		pull	a		; d now	has deltaKS/KS_count
		add	d, meanKSint	; deltaKS/KS_count, filtered
		rorc	a
		rorc	b
		cmp	#10h, unk_69	; choose filtering process
		bcc	IV6_10		; heavy	filter branch
		inc	unk_69
		bra	IV6_11		; no more filter branch
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IV6_10:					; CODE XREF: IV6+9Bj
		add	d, meanKSint	; deltaKS/KS_count, filtered
		rorc	a
		rorc	b
		add	d, meanKSint	; deltaKS/KS_count, filtered
		rorc	a
		rorc	b
		add	d, meanKSint	; deltaKS/KS_count, filtered
		rorc	a
		rorc	b

IV6_11:					; CODE XREF: IV6+9Fj
		st	d, meanKSint	; deltaKS/KS_count, filtered

IV6_12:					; CODE XREF: IV6+75j
		ei
		clr	a
		cmp	#082, VTA_net	; should always	be less	from superrun
		bcs	IV6_13
		ld	a, unk_E9
		inc	a
		cmp	a, #08h
		bcs	IV6_13
		ld	a, #80h

IV6_13:					; CODE XREF: IV6+B4j IV6+BBj
		st	a, unk_E9
		jsr	sub_F1A9
		bra	IV6_21
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IV6_14:					; CODE XREF: IV6+4Ej
		shr	a
		bcs	IV6_21
		ld	a, flags_77
		and	a, #7Fh
		st	a, flags_77
<<<<<<< HEAD
		ld	a, byte_186	; subtracted from timing in NEsub
=======
		ld	a, byte_186	; timing related
>>>>>>> origin/master
		ld	b, unk_102
		cmpb	b, #80h
		beq	IV6_16
		ld	b, unk_187	; timing related
		cmp	a, b
		beq	IV6_20		; only assignment
		bgt	IV6_17
		cmpz	a
		bne	IV6_19
		setb	bit1, flags_41
		cmp	#080, RPM	; 4000 RPM
		bcc	IV6_15
		clrb	bit1, flags_41

IV6_15:					; CODE XREF: IV6+E9j
		bra	IV6_19
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IV6_16:					; CODE XREF: IV6+D7j
		clr	b

IV6_17:					; CODE XREF: IV6+DFj
		sub	a, #22h
		bgt	IV6_18
		clr	a

IV6_18:					; CODE XREF: IV6+F2j
		cmp	a, b
		bgt	IV6_20		; only assignment

IV6_19:					; CODE XREF: IV6+E2j IV6:IV6_15j
		mov	b, a

IV6_20:					; CODE XREF: IV6+DDj IV6+F6j
		st	a, byte_186	; only assignment

IV6_21:					; CODE XREF: IV6+C4j IV6+C7j
		ld	a, flags_44	; bit 1	is igf1	related, bit2 igf2 related
		and	a, #3Fh
		beq	IV6_22		; on the right path
		ld	a, #0FFh
		st	a, byte_112	; necounts/motor phase related
		jmp	IV6_29		; bounces past doinjectors
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IV6_22:					; CODE XREF: IV6+100j
		ld	a, NEcountsIV6	; on the right path
		ld	y, #0C2DBh

IV6_23:					; CODE XREF: IV6+126j
		cmp	y, #0C2DFh	; this value is	too high, carry	should always be set
		bcs	IV6_24
		jmp	IV6_33		; bounces past doinjectors because this	loop has failed	somehow
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IV6_24:					; CODE XREF: IV6+112j
		ld	b, y + 00h
		add	b, byte_113	; necounts/motor phase related
		cmp	b, #024
		ble	IV6_25		; check	to see if the engine phase is one of 4 precise positions
		sub	b, #024

IV6_25:					; CODE XREF: IV6+11Ej
		cmp	a, b		; check	to see if the engine phase is one of 4 precise positions
		beq	IV6_27

IV6_26:					; CODE XREF: IV6+131j
		inc	y
		bra	IV6_23		; this value is	too high, carry	should always be set
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IV6_27:					; CODE XREF: IV6+123j
		push	d
		mov	y, d
		sub	d, #0C2DBh	; now contains value from 0..3
		cmp	b, byte_112	; necounts/motor phase related
		pull	d
		beq	IV6_26
		mov	y, d
		sub	d, #0C2DBh
		st	b, byte_112	; necounts/motor phase related
		ld	y, #InjBits	; data used by DoInjectors #10
		shl	b		; double b: values 0,2,4,6
		add	y, b

IV6_28:					; either 00 or 02
		ld	a, y + 10h
		ld	x, #0164h	; choose either	InjectPW1 or InjectPW2
		add	x, a
		ld	d, x + 00h
		jsr	DoInjector
		ld	b, flags_77	; going	to clear bit 4
		and	b, #0DFh
		st	b, flags_77	; clear	bit 4

IV6_29:					; CODE XREF: IV6+107j
		ld	a, byte_110	; 7 to 23, highest at lowest fuel flow
		ld	b, byte_111
		sub	a, b
		bmi	IV6_30
		cmp	a, #002
		ble	IV6_31
		ld	a, #002
		bra	IV6_31
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IV6_30:					; CODE XREF: IV6+157j
		cmp	a, #0FEh
		bcc	IV6_31
		ld	a, #0FEh

IV6_31:					; CODE XREF: IV6+15Bj IV6+15Fj ...
		add	a, b
		st	a, byte_111	; old 111 ñ2
		add	a, #013
		cmp	a, #024
		ble	IV6_32
		sub	a, #024

IV6_32:					; CODE XREF: IV6+16Fj
		st	a, byte_113	; necounts/motor phase related

IV6_33:					; CODE XREF: IV6+114j
		cmp	#0FFh, unk_D7
		beq	IV6_34
		inc	unk_D7

IV6_34:					; CODE XREF: IV6+179j
		ld	b, NEcountsIV6	; buffered copy	of NEcounts for	IV6 purposes
		cmp	b, #07h
		beq	IV6_35
		cmp	b, #13h
		bne	IV6_37

IV6_35:					; CODE XREF: IV6+181j
		ld	a, unk_E3
		inc	a
		beq	IV6_36
		st	a, unk_E3

IV6_36:					; CODE XREF: IV6+18Aj
		ld	b, flags_44	; bit 1	is igf1	related, bit2 igf2 related
		and	b, #3Fh
		bne	IV6_37
		ld	a, flags_77
		and	a, #0EFh
		st	a, flags_77

IV6_37:					; CODE XREF: IV6+185j IV6+192j
		tbbc	bit3, flags_43,	IV6_39 ; bit3: AFM bad bit4: rev limiter
		cmp	#7Ah, count_B4	; incremented at F55E
		bcs	IV6_42
		cmp	#0Fh, unk_EB
		bcs	IV6_38
		clrb	bit3, flags_43

IV6_38:					; CODE XREF: IV6+1A5j
		clr	count_B4	; incremented at F55E
		bra	IV6_41
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IV6_39:					; CODE XREF: IV6:IV6_37j
		clr	count_B4	; incremented at F55E
		cmp	#006, RPM	; MSB is RPM/50, LSB is	fraction of 50
		bcs	IV6_41
		cmp	#30h, badKScount ; Incremented by IV6, cleared by KS interrupt
		bcc	IV6_40
		inc	badKScount	; Incremented by IV6, cleared by KS interrupt
		bra	IV6_42
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IV6_40:					; CODE XREF: IV6+1B7j
		setb	bit3, flags_43

IV6_41:					; CODE XREF: IV6+1ABj IV6+1B2j
		clr	badKScount	; Incremented by IV6, cleared by KS interrupt
		clr	unk_EB

IV6_42:					; CODE XREF: IV6+1A0j IV6+1BBj
		clrb	bit0, flags_4E
<<<<<<< HEAD
		tbbc	bit0, flags_45,	IV6_43 ; IC303 input chip: B7 /TE2, B6 /TE1, B5	/NSW, B4 IGSW,	B3, B2 IDL2, B1	, B0 STA
=======
		tbbc	bit0, flags_45,	IV6_43 ; IC303 input chip: B7 /TE2, B /TE1, B5 /NSW, B4	IGSW,  B3, B2 IDL2, B1 , B0 STA
>>>>>>> origin/master
		setb	bit4, flags_4C

IV6_43:					; CODE XREF: IV6:IV6_5j IV6+1C5j
		tbs	bit3, flags_47	; bit4:	high when hot (but how hot?)
		bne	IV6_44
		jmp	IV6_2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IV6_44:					; CODE XREF: IV6+1CCj
		jmp	IV6_1
; End of function IV6

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
InjBits:	.db  10h		; DATA XREF: IV6+13Ao DoAllInjo
					; data used by DoInjectors #10
		.db  00h
		.db  20h		; #20
		.db  00h
		.db  40h ; @		; #30
		.db  00h
		.db  80h ; €		; #40
		.db  00h
		.db 0EFh ; ï		; offset 08h, #10
		.db  00h
		.db 0DFh ; ß		; #20
		.db  00h
		.db 0BFh ; ¿		; #30
		.db  00h
		.db  7Fh ; 		; #40
		.db  00h
		.db  00h		; offset 10h, select injectpw1
		.db  00h
		.db  02h		; select injectpw2
		.db  00h
		.db  02h		; select injectpw2
		.db  00h
		.db  00h		; select injectpw1
		.db  00h
		.dw 0038h		; offset 18h (CPR4)
		.dw 003Ah		; (CPR5)
		.dw 003Ch		; (CPR6)
		.dw 003Eh		; (CPR7)

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DoInjector:				; CODE XREF: IV6+147p DoAllInj+4p
		di
		push	d
		ld	a, LDOUT	; Latch	DOUT
		cmpb	a, y + 00h	; compare BITS,	it's an AND, not a subtraction
		bne	DoInj_ison	; not equal when injector is already on
		pull	d
		add	d, InjDeadtime	; injector deadtime, 4us/bit
		bra	DoInj6
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DoInj_ison:				; CODE XREF: DoInjector+6j
		ld	x, y + 18h
		ld	d, x + 00h	; load compare time (off time)
		mov	s, x
		sub	d, TIMER	; subtract timer from scheduled	off time
		cmp	a, #0FFh	; a rigid assumption, but reasonably valid
		bne	DoInj3		; data was pushed at start of sub, then	stack was copied into x
		clr	a		; we did exceed	injector off time, and it's not off...
		clr	b

DoInj3:					; CODE XREF: DoInjector+17j
		add	d, x + 00h	; data was pushed at start of sub, then	stack was copied into x
		bcs	DoInj4		; on overflow, cap pw to 7FEE
		cmp	d, #7FEEh
		ble	DoInj5		; tidy up stack

DoInj4:					; CODE XREF: DoInjector+1Dj
		ld	d, #7FEEh

DoInj5:					; CODE XREF: DoInjector+22j
		pull	x		; tidy up stack

DoInj6:					; CODE XREF: DoInjector+Cj
		add	d, TIMER	; Timer	MSB (bit11~bit18)
		ld	x, y + 18h	; get address of specific CPR to target
		st	d, x + 00h	; store	in CPR4	through	CPR7
		ld	d, DOUT		; DOUT:DOM
		or	a, y + 00h	; setting injector bit high
		and	b, y + 08h	; setting corresponding	DOM bit	low
		st	d, DOUT		; commit to registers
		ld	d, DOUT		; DOUT Data Register
		and	a, y + 08h	; now we set the injector bit low
		or	b, y + 00h	; and the corresponding	DOM high
		st	b, DOM		; then write in	backwards order
		st	a, DOUT		; DOUT Data Register
		ei			; and all of that ends up generating a high pulse of
					; some kind of length at the desired pin. certainly
					; it's output compare. 4us/bit
		ret
; End of function DoInjector


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DoAllInj:				; CODE XREF: __RESET+5CFp IV6+40p ...
		ld	y, #InjBits	; data used by DoInjectors #10

DoAllloop:				; CODE XREF: DoAllInj+Cj
		push	d
		bsr	DoInjector
		inc	y
		inc	y
		pull	d
		cmp	y, #0F13Eh	; InjBits+6 , executes on +6 pass still
		ble	DoAllloop
		ret
; End of function DoAllInj


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_F1A9:				; CODE XREF: IV6+C1p
		ld	a, count_19C
		inc	a
		beq	loc_F1B2
		st	a, count_19C

loc_F1B2:				; CODE XREF: sub_F1A9+4j
		ld	a, count_19D
		inc	a
		beq	loc_F1BB
		st	a, count_19D

loc_F1BB:				; CODE XREF: sub_F1A9+Dj
		clr	a
		ld	b, unk_187	; timing related
		beq	loc_F1C7
		ld	a, count_1CC
		inc	a
		beq	loc_F1CA	; 5150 RPM

loc_F1C7:				; CODE XREF: sub_F1A9+16j
		st	a, count_1CC

loc_F1CA:				; CODE XREF: sub_F1A9+1Cj
		cmp	#103, RPM	; 5150 RPM
		bcc	loc_F1D1	; 5250 RPM
		setb	bit5, flags_46

loc_F1D1:				; CODE XREF: sub_F1A9+24j
		cmp	#105, RPM	; 5250 RPM
		bcs	loc_F1D8
		clrb	bit5, flags_46

loc_F1D8:				; CODE XREF: sub_F1A9+2Bj
		ld	a, unk_196
		shl	a
		shl	a
		and	a, #0Ch
		tbbs	bit3, flags_43,	loc_F1EE ; bit3: AFM bad bit4: rev limiter
		cmp	#18h, compLOAD	; air temp and Baro compensated	Load (likely in	units of mass)
		bcs	loc_F1EE
		or	a, #80h
		cmp	#013, RPM	; 650 RPM
		bcc	loc_F1F2	; 3000 RPM

loc_F1EE:				; CODE XREF: sub_F1A9+36j sub_F1A9+3Cj
		or	a, #01h
		bra	loc_F200
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F1F2:				; CODE XREF: sub_F1A9+43j
		cmp	#060, RPM	; 3000 RPM
		bcs	loc_F200
<<<<<<< HEAD
		tbbc	bit5, flags_46,	loc_F1FE ; bit 1 flags limp in injection mode, B5 RPM under 5200ish
=======
		tbbc	bit5, flags_46,	loc_F1FE ; bit 1 flags limp in injection mode
>>>>>>> origin/master
		or	a, #02h
		bra	loc_F200
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F1FE:				; CODE XREF: sub_F1A9+4Ej
		or	a, #03h

loc_F200:				; CODE XREF: sub_F1A9+47j sub_F1A9+4Cj ...
		st	a, unk_196
		clr	b
<<<<<<< HEAD
		tbbs	bit0, flags_46,	loc_F216 ; bit 1 flags limp in injection mode, B5 RPM under 5200ish
=======
		tbbs	bit0, flags_46,	loc_F216 ; bit 1 flags limp in injection mode
>>>>>>> origin/master
		push	a
		ld	a, flags_4E	; bit1 is igf1 related,	bit2 igf2 related
		and	a, #0E0h
		pull	a
		bne	loc_F216
		cmpb	a, #80h
		bne	loc_F21E
		st	b, unk_199	; output from 3d table c54c

loc_F216:				; CODE XREF: sub_F1A9+5Bj sub_F1A9+64j
		st	b, unk_19B
		st	b, unk_198
		bra	loc_F251
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F21E:				; CODE XREF: sub_F1A9+68j
		ld	b, unk_103
		and	b, #40h
		bne	loc_F231
		ld	a, #0CDh
		st	a, unk_19B
		clr	a
		st	a, unk_198
		jmp	loc_F251
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F231:				; CODE XREF: sub_F1A9+7Aj
		ld	y, #009Eh
		mov	a, b
		shr	b
		bcs	loc_F23C
		shr	b
		shr	b
		bcc	loc_F25A

loc_F23C:				; CODE XREF: sub_F1A9+8Dj
		mov	a, b
		and	b, #02h
		add	y, b
		push	a
		ld	d, y + 00h
		xor	b, #0FFh
		cmp	a, b
		beq	loc_F249
		clr	a

loc_F249:				; CODE XREF: sub_F1A9+9Dj
		st	a, unk_19B
		pull	a
		cmpb	a, #01h
		beq	loc_F25A

loc_F251:				; CODE XREF: sub_F1A9+73j sub_F1A9+85j
		clr	b
		st	b, count_19C
		clr	count_AC	; incremented at F47D
		jmp	loc_F2F9
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F25A:				; CODE XREF: sub_F1A9+91j sub_F1A9+A6j
		ld	b, count_19C
		cmp	b, #08h
		bcs	loc_F278
		clr	b
		st	b, count_19C
		ld	b, unk_198
		shr	b
		st	b, unk_198
		ld	b, unk_19B
		sub	b, unk_198
		bcc	loc_F275
		clr	b

loc_F275:				; CODE XREF: sub_F1A9+C9j
		st	b, unk_19B

loc_F278:				; CODE XREF: sub_F1A9+B6j
<<<<<<< HEAD
		ld	b, byte_186	; subtracted from timing in NEsub
=======
		ld	b, byte_186	; timing related
>>>>>>> origin/master
		bne	loc_F289
		ld	b, unk_187	; timing related
		beq	loc_F28C
		ld	b, count_1CC
		cmp	b, #20h
		ble	loc_F28C

loc_F289:				; CODE XREF: sub_F1A9+D2j
		jmp	loc_F2F9
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F28C:				; CODE XREF: sub_F1A9+D7j sub_F1A9+DEj
<<<<<<< HEAD
		tbbs	bit5, flags_45,	loc_F2AA ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
		tbbs	bit5, flags_4A,	loc_F2AA ; bits	6,5,4 are inherited from 109. 6	seems to always	be low when no sub throttle exists
=======
		tbbs	bit5, flags_45,	loc_F2AA ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		tbbs	bit5, flags_4A,	loc_F2AA
>>>>>>> origin/master
		ld	y, #009Eh
		and	a, #02h
		add	y, a
		ld	a, y + 00h
		mov	a, b
		add	a, unk_19B
		rorc	a
		add	a, b
		rorc	a
		add	a, b
		rorc	a
		add	a, b
		rorc	a
		mov	a, b
		xor	b, #0FFh
		st	d, y + 00h

loc_F2AA:				; CODE XREF: sub_F1A9:loc_F28Cj
					; sub_F1A9+E6j
		ld	b, unk_E5
		and	b, #03h
		beq	loc_F2DB
		clr	count_AC	; incremented at F47D
		dec	b
		ld	y, #0C549h
		add	y, b
		ld	b, y + 00h
		ld	a, count_19D
		cmp	a, #08h
		bgt	loc_F2C1
		shl	b

loc_F2C1:				; CODE XREF: sub_F1A9+115j
		clr	a
		st	a, count_19D
		ld	a, unk_198
		add	a, b
		ld	b, unk_199	; output from 3d table c54c
		sub	b, unk_19A
		bcc	loc_F2D2
		clr	b

loc_F2D2:				; CODE XREF: sub_F1A9+126j
		cmp	a, b
		ble	loc_F2D6
		mov	b, a

loc_F2D6:				; CODE XREF: sub_F1A9+12Aj
		st	a, unk_198
		bra	loc_F2F9
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F2DB:				; CODE XREF: sub_F1A9+105j
		ld	a, unk_19B
		ld	b, unk_19A
		beq	loc_F2F9
		cmp	#62h, count_AC	; incremented at F47D
		bcs	loc_F2F9
		clr	count_AC	; incremented at F47D
		add	a, #02h
		bcs	loc_F2F3
		cmp	a, unk_199	; output from 3d table c54c
		ble	loc_F2F6

loc_F2F3:				; CODE XREF: sub_F1A9+143j
		ld	a, unk_199	; output from 3d table c54c

loc_F2F6:				; CODE XREF: sub_F1A9+148j
		st	a, unk_19B

loc_F2F9:				; CODE XREF: sub_F1A9+AEj
					; sub_F1A9:loc_F289j ...
		ld	a, unk_199	; output from 3d table c54c
		sub	a, unk_19B
		bcc	loc_F302
		clr	a

loc_F302:				; CODE XREF: sub_F1A9+156j
		st	a, unk_19A
		add	a, unk_198
		cmp	a, unk_199	; output from 3d table c54c
		ble	loc_F310
		ld	a, unk_199	; output from 3d table c54c

loc_F310:				; CODE XREF: sub_F1A9+162j
<<<<<<< HEAD
		ld	b, unk_197	; subtracted from timing in main loop
=======
		ld	b, unk_197	; timing related
>>>>>>> origin/master
		sub	b, #09h
		bcc	loc_F318
		clr	b

loc_F318:				; CODE XREF: sub_F1A9+16Cj
		cmp	a, b
		bcc	loc_F31C	; only writ here
		mov	b, a

loc_F31C:				; CODE XREF: sub_F1A9+170j
		st	a, unk_197	; only writ here
		ret
; End of function sub_F1A9


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


		; public IVc
IVc:					; DATA XREF: ROM:FFF6o
		clrb	bit4, IRQL
		ld	a, TIMER	; Timer	MSB (bit11~bit18)
		and	a, #04h		; toggles every	4096ms
		bne	ivc_04		; bounce if high, every	8ms
<<<<<<< HEAD
		tbbc	bit7, flags_45,	ivc_04 ; bounce	if TE2 is open
=======
		tbbc	bit7, flags_45,	ivc_04 ; IC303 input chip: B7 /TE2, B /TE1, B5 /NSW, B4	IGSW,  B3, B2 IDL2, B1 , B0 STA
>>>>>>> origin/master
		clrb	bit4, PORTB	; clear	pin 23
		ld	a, unk_7C	; counter
		bpz	ivc_01
		inc	a
		st	a, unk_7C	; counter
		cmp	a, #240
		blea	ivc_02		; set pin 29
		bra	ivc_03		; clear	pin 29
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ivc_01:					; CODE XREF: IVc+Fj
		ld	d, unk_1CA
		shr	d
		st	d, unk_1CA
		ble	ivc_03		; clear	pin 29

ivc_02:					; CODE XREF: IVc+16j
		setb	bit6, PORTA	; set pin 29
		setb	bit7, PORTA	; set pin 28
		bra	ivc_04
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ivc_03:					; CODE XREF: IVc+18j IVc+21j
		clrb	bit6, PORTA	; clear	pin 29
		clrb	bit7, PORTA	; clear	pin 28

ivc_04:					; CODE XREF: IVc+6j IVc+8j ...
		clr	a
		cmp	#137, unk_E1
		bcc	ivc_11
<<<<<<< HEAD
		tbbs	bit5, flags_4C,	ivc_07 ; bit 7 set when	not running (300 to 400	RPM gap)
		ld	b, flags_1AB	; buffers IC302	inputs for debouncing and storing into flags_1AA
=======
		tbbs	bit5, flags_4C,	ivc_07 ; bit 7 demands a sampling of the oxygen	sensors
		ld	b, flags_1AB	; flags_1AA related
>>>>>>> origin/master
		cmpb	b, #40h
		bne	ivc_09
		ld	b, unk_19F	; ISC related
		cmp	b, #010
		bcc	ivc_06
		ld	a, count_B1	; incremented at F47D
		cmp	a, #048
		ble	ivc_08
		cmpz	b
		bne	ivc_05
		clr	a
		st	a, count_CC	; incremented at E643

ivc_05:					; CODE XREF: IVc+4Bj
		inc	b
		st	b, unk_19F	; ISC related

ivc_06:					; CODE XREF: IVc+42j
		setb	bit6, flags_4C
		bra	ivc_09
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ivc_07:					; CODE XREF: IVc+33j
		st	a, unk_19F	; ISC related
		clrb	bit6, flags_4C
		bra	ivc_09
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ivc_08:					; CODE XREF: IVc+48j
		cmp	a, #18h
		bgt	ivc_12		; set pin 58
		cmp	#020, RPM	; 1000 RPM
		bcc	ivc_10		; bounce if >= 1000 RPM

ivc_09:					; CODE XREF: IVc+3Bj IVc+56j ...
		clr	count_B1	; incremented at F47D

ivc_10:					; CODE XREF: IVc+66j
		tbbs	bit6, flags_4C,	ivc_13 ; clear pin 58
		tbbc	bit7, flags_4B,	ivc_13 ; clear pin 58
		tbbs	bit3, DOUT, ivc_13 ; clear pin 58
		bra	ivc_12		; set pin 58
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ivc_11:					; CODE XREF: IVc+31j
		clr	count_B1	; incremented at F47D

ivc_12:					; CODE XREF: IVc+61j IVc+73j
		setb	bit3, DOUT	; set pin 58
		bra	ivc_14
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ivc_13:					; CODE XREF: IVc:ivc_10j IVc+6Dj ...
		clrb	bit3, DOUT	; clear	pin 58

ivc_14:					; CODE XREF: IVc+79j
		ld	a, count_CC	; incremented at E643
		cmp	a, #116
		bcs	ISC_alt
		clr	a
		st	a, unk_19F	; ISC related

ISC_alt:				; CODE XREF: IVc+81j
		ld	a, ISC_120	; ISC output bits is lsN
		and	a, #0Fh
		di
		ld	b, PORTB	; Port B Data Register
		and	b, #0F0h
		add	a, b
		st	a, PORTB	; Port B Data Register
		ei
		ld	a, ISC_11F	; ISC related
		and	a, #3Ch
		cmp	a, #08h
		bne	ivc_ret1
		clr	a
		st	a, ISC_120	; ISC output bits is lsN

ivc_ret1:				; CODE XREF: IVc+9Cj
		jsr	write6336
		setb	bit3, flags_4A
		setb	bit1, IRQLL	; Trigger IV6
		reti
; End of function IVc

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR IV6

IV6_TXadc:				; CODE XREF: IV6+11j
		ld	b, flags_75	; flags	relating to ADC	tx'ing
		cmpb	b, #01h
		beq	loc_F3F0

loc_F3D0:				; CODE XREF: IV6+490j
		ld	b, ADC_count
		clr	a
		div	d, #003
		cmpz	a
		bne	loc_F3DE
		ld	x, #0F767h
		add	x, b
		bra	loc_F3E2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F3DE:				; CODE XREF: IV6+472j
		ld	x, #0F764h
		add	x, a

loc_F3E2:				; CODE XREF: IV6+478j
		ld	a, x + 00h
		st	a, ADC_TXed	; MSb signifies	next TX	value is 02
		setb	bit1, SSD	; set ninth bit	high
		and	a, #1Fh
		di
		st	a, SIDR_SODR	; Serial Input/Output Data Register
		clr	b
		bra	loc_F3F6
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F3F0:				; CODE XREF: IV6+46Aj
		add	b, #10h
		cmp	b, #40h
		bcc	loc_F3D0

loc_F3F6:				; CODE XREF: IV6+48Aj
		st	b, flags_75	; flags	relating to ADC	tx'ing
<<<<<<< HEAD
		tbbc	bit1, flags_4A,	loc_F408 ; bits	6,5,4 are inherited from 109. 6	seems to always	be low when no sub throttle exists
		tbbc	bit2, flags_4A,	loc_F408 ; bits	6,5,4 are inherited from 109. 6	seems to always	be low when no sub throttle exists
=======
		tbbc	bit1, flags_4A,	loc_F408
		tbbc	bit2, flags_4A,	loc_F408
>>>>>>> origin/master
		tbs	bit0, PORTA	; Port A Data Register
		beq	loc_F404
		clrb	bit0, PORTA	; tickle the MP908 spark multiplexer/Gn	detector, watchdog

loc_F404:				; CODE XREF: IV6+49Cj
		clrb	bit1, flags_4A
		clrb	bit2, flags_4A

loc_F408:				; CODE XREF: IV6+494j IV6+497j
		ld	b, flags_75	; flags	relating to ADC	tx'ing
		bne	loc_F413
		ld	#30h, SMRC_SIR	; Serial Master	Register Control
		ld	a, SSD		; Serial Status	Data Register
		ld	a, SIDR_SODR	; the ADC may not respond in time, this	could clear all	errors and get the rx interface	ready for the adc data

loc_F413:				; CODE XREF: IV6+4A6j
		ei
		setb	bit3, PORTD_ASRIN
<<<<<<< HEAD
		ld	a, unk_109	; 0 or 128
		ld	b, unk_76	; 0, 1 or very rarely 2
=======
		ld	a, unk_109
		ld	b, unk_76	; some flags which interact with flags_4A
>>>>>>> origin/master
		cmpb	a, #80h
		beq	loc_F425
		tbs	bit1, flags_47	; bit4:	high when hot (but how hot?)
		bne	loc_F433
		bra	loc_F42A
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F425:				; CODE XREF: IV6+4B9j
		tbbc	bit1, flags_47,	loc_F433 ; bit4: high when hot (but how	hot?)
		clrb	bit1, flags_47

loc_F42A:				; CODE XREF: IV6+4BFj
		shl	b
		and	b, #0C0h
		bne	loc_F476
		clrb	bit0, flags_4D
		bra	loc_F476
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F433:				; CODE XREF: IV6+4BDj IV6:loc_F425j
		inc	unk_76		; some flags which interact with flags_4A
		mov	b, a
		and	a, #1Fh
		cmp	a, #021
		bcc	loc_F456
		ld	a, unk_109
<<<<<<< HEAD
		ld	b, VTA2_net	; VTA2-VTA2_min, =255 when sub throttle	disabled/not exist
		inc	b
		bne	loc_F449	; check	to see if sub throttle is used
		and	a, #40h		; bit 6
		bra	loc_F44B	; ---------------------------------------Start sensitive code
=======
		ld	b, VTA2_net	; VTA2-VTA2_min
		inc	b
		bne	loc_F449	; check	to see if sub throttle is used
		and	a, #40h		; bit 6
		bra	loc_F44B
>>>>>>> origin/master
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F449:				; CODE XREF: IV6+4DFj
		and	a, #70h

loc_F44B:				; CODE XREF: IV6+4E3j
<<<<<<< HEAD
		di			; ---------------------------------------Start sensitive code
		ld	b, flags_4A	; working with bits 6,5,4
		and	b, #8Fh		; zero 654
		add	a, b		; take bits 654	from accA
		st	a, flags_4A	; bits 6,5,4 are inherited from	109. 6 seems to	always be low when no sub throttle exists
		ei			; ----------------------------end sensitive code
=======
		di
		ld	b, flags_4A	; working with bits 6,5,4
		and	b, #8Fh		; zero 654
		add	a, b		; take bits 654	from accA
		st	a, flags_4A
		ei
>>>>>>> origin/master
		bra	loc_F478
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F456:				; CODE XREF: IV6+4D6j
		and	b, #0C0h
		add	b, #40h
		bcc	loc_F460
		ld	b, #0C0h
		bra	loc_F466
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F460:				; CODE XREF: IV6+4F6j
		cmp	b, #0C0h
		beq	loc_F466
		bra	loc_F474
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F466:				; CODE XREF: IV6+4FAj IV6+4FEj
		setb	bit0, flags_4D
		clr	a
		st	a, unk_106
		di
		ld	a, flags_4A	; bits 6,5,4 are inherited from	109. 6 seems to	always be low when no sub throttle exists
		and	a, #8Fh
		st	a, flags_4A	; clear	bits 6,5,4
		ei

loc_F474:				; CODE XREF: IV6+500j
		clrb	bit3, PORTD_ASRIN

loc_F476:				; CODE XREF: IV6+4C9j IV6+4CDj
		st	b, unk_76	; some flags which interact with flags_4A

loc_F478:				; CODE XREF: IV6+4F0j
		ld	b, #016
		ld	y, #00A3h
		jsr	satcount	; increment B bytes of ram by 1	starting from Y, saturates at FF
		ld	a, count_126	; from the plots it looks like it increments while the throttle	is closed
		inc	a
		beq	loc_F489
		st	a, count_126	; increments here, saturates at	255

loc_F489:				; CODE XREF: IV6+520j
		clr	a
<<<<<<< HEAD
		tbbc	bit2, flags_45,	loc_F493 ; reset counter if not	IDL
=======
		tbbc	bit2, flags_45,	loc_F493 ; reset counter if bit	clear
>>>>>>> origin/master
		ld	a, count_12C
		inc	a
		beq	loc_F496

loc_F493:				; CODE XREF: IV6+526j
		st	a, count_12C

loc_F496:				; CODE XREF: IV6+52Dj
		di
		ld	b, #003
		ld	y, #01B8h
		jsr	satcount	; increment B bytes of ram by 1	starting from Y, saturates at FF
		ei
<<<<<<< HEAD
		tbbs	bit7, flags_45,	loc_F4D4 ; bounce if TE2 shorted
=======
		tbbs	bit7, flags_45,	loc_F4D4 ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		setb	bit4, PORTB
		ld	a, TIMER	; Timer	MSB (bit11~bit18)
		and	a, #0Ch
		ld	x, #0D2B5h
		ld	y, #0111h

loc_F4AF:				; CODE XREF: IV6+56Ej
		ld	b, #1Ch
		add	y, b
		ld	b, y + 18h	; first	hit is unk_145
		cmpz	a
		beq	loc_F4BC
		cmp	a, b
		bcc	loc_F4C6
		bra	loc_F4BF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F4BC:				; CODE XREF: IV6+551j
		cmpz	b
		beq	loc_F4C6

loc_F4BF:				; CODE XREF: IV6+556j
		ld	b, x + 00h
		di
		or	b, PORTA	; Port A Data Register
		bra	loc_F4CB
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F4C6:				; CODE XREF: IV6+554j IV6+559j
		ld	b, x + 02h
		di
		and	b, PORTA	; Port A Data Register

loc_F4CB:				; CODE XREF: IV6+560j
		st	b, PORTA	; Port A Data Register
		ei
		inc	x
		cmp	y, #0149h
		bcs	loc_F4AF

loc_F4D4:				; CODE XREF: IV6+53Cj
		ld	a, unk_108
		and	a, #80h
		beq	loc_F4DE
		ld	#18h, unk_E4

loc_F4DE:				; CODE XREF: IV6+575j
		jsr	sub_C010
		ld	a, unk_1B1
		inc	a
		cmp	a, #14h
		bcs	loc_F4F0
		clr	a
		ld	b, unk_1B0
		st	b, unk_1B2

loc_F4F0:				; CODE XREF: IV6+583j
		st	a, unk_1B1
		cmp	a, unk_1B2
		bcc	loc_F4FF
		ld	b, #08h
		jsr	orFlags_50	; or b with Flags_50
		bra	loc_F504
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F4FF:				; CODE XREF: IV6+592j
		ld	b, #0F7h
		jsr	andFlags_50	; and b	with Flags_50

loc_F504:				; CODE XREF: IV6+599j
		ld	a, TIMER	; Timer	MSB (bit11~bit18)
		and	a, #3Ch
		shr	a
		shr	a
		shr	a
		bcc	loc_F559
		shr	a
		bcc	loc_F522
		shr	a
		bcc	loc_F516
		shr	a
		bcc	loc_F519

loc_F516:				; CODE XREF: IV6+5ADj
		jmp	loc_F666
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F519:				; CODE XREF: IV6+5B0j
		ld	a, flags_77
		and	a, #0F9h
		st	a, flags_77
		jmp	loc_F666
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F522:				; CODE XREF: IV6+5AAj
		ld	a, flags_77
		and	a, #0F7h
		st	a, flags_77
		bra	loc_F52E
; END OF FUNCTION CHUNK	FOR IV6
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  01h		; data for F53D
		.db  02h
		.db  02h
		.db  04h
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR IV6

loc_F52E:				; CODE XREF: IV6+5C4j
		clr	a
<<<<<<< HEAD
		ld	b, byte_186	; subtracted from timing in NEsub
=======
		ld	b, byte_186	; timing related
>>>>>>> origin/master
		bne	loc_F53B
		cmp	#3Dh, count_C5	; increments at	E478
		bcc	loc_F554
		bra	loc_F556
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F53B:				; CODE XREF: IV6+5CEj
		clr	count_C5	; increments at	E478
		ld	x, #0F52Ah
		cmp	#080, RPM	; 4000 RPM
		bcs	loc_F546

loc_F545:
		inc	a

loc_F546:				; CODE XREF: IV6+5DFj
		tbbc	bit1, flags_41,	loc_F54B ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
		add	a, #02h

loc_F54B:				; CODE XREF: IV6:loc_F546j
		add	x, a
		ld	a, x + 00h
		add	a, unk_F9
		bcc	loc_F554
		ld	a, #0FFh

loc_F554:				; CODE XREF: IV6+5D3j IV6+5ECj
		st	a, unk_F9

loc_F556:				; CODE XREF: IV6+5D5j
		jmp	loc_F666
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F559:				; CODE XREF: IV6+5A7j
		ld	b, #007
		ld	y, #00B3h
		jsr	satcount	; increment B bytes of ram by 1	starting from Y, saturates at FF
		ld	b, #004
		ld	y, #00BAh
		jsr	satuncount	; decrements B bytes of	ram by 1 starting from Y, saturates at 00
		ld	a, unk_138
		inc	a
		beq	loc_F572
		st	a, unk_138

loc_F572:				; CODE XREF: IV6+609j
		ld	a, unk_154
		inc	a
		beq	loc_F57B
		st	a, unk_154

loc_F57B:				; CODE XREF: IV6+612j
		ld	b, #004
		ld	y, #01C0h
<<<<<<< HEAD
		jsr	satcount	; increment oxy	sensor related counters
=======
		jsr	satcount	; increment B bytes of ram by 1	starting from Y, saturates at FF
>>>>>>> origin/master
		ld	a, ISC_11F	; ISC related
		ld	b, unk_11E
		cmp	b, #06h
		bcs	loc_F594
		and	a, #03h
		or	a, #1Ch
		st	a, ISC_11F	; ISC related

loc_F594:				; CODE XREF: IV6+627j
		and	a, #3Ch
		shr	a
		shr	a
		st	a, unk_58
		inc	b
		cmp	a, #05h
		beq	loc_F5A0
		clr	b

loc_F5A0:				; CODE XREF: IV6+639j
		st	b, unk_11E
		tbbc	bit5, RAMST, loc_F5FC ;	Built-in RAM status
<<<<<<< HEAD
		tbbc	bit4, flags_45,	loc_F5AE ; IC303 input chip: B7	/TE2, B6 /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
=======
		tbbc	bit4, flags_45,	loc_F5AE ; IC303 input chip: B7	/TE2, B	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
>>>>>>> origin/master
		cmp	#109, Bvolts	; 8.55V
		bcs	loc_F5FC

loc_F5AE:				; CODE XREF: IV6+642j
		ld	d, unk_DC
		cmpz	b
		beq	loc_F5D9
		bpz	loc_F5C4
		cmp	b, #0D2h
		blta	loc_F5D6
		add	a, b
		bcc	loc_F5C0
		cmp	a, #02h
		bcc	loc_F5D6

loc_F5C0:				; CODE XREF: IV6+656j
		ld	a, #02h
		bra	loc_F5D6
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F5C4:				; CODE XREF: IV6+64Fj
		cmp	b, #2Dh
		bgta	loc_F5D6
		cmp	a, #9Dh
		bcc	loc_F5D9
		add	a, b
		mov	a, b
		sub	b, #9Dh
		bcs	loc_F5D6
		ld	a, #9Dh
		bra	loc_F5D7
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F5D6:				; CODE XREF: IV6+653j IV6+65Aj ...
		clr	b

loc_F5D7:				; CODE XREF: IV6+670j
		st	d, unk_DC

loc_F5D9:				; CODE XREF: IV6+64Dj IV6+666j
		tbbc	bit0, flags_48,	loc_F5E2
		cmp	a, unk_E2
		bcc	loc_F5E2
		ld	a, unk_E2

loc_F5E2:				; CODE XREF: IV6:loc_F5D9j IV6+67Aj
		ld	x, #0C530h
		sub	a, #20h
		bcs	loc_F5FF
		sub	a, unk_DB	; magic	from address 0x80
		beq	loc_F5FC
		bcs	loc_F5FF
		ld	x, #0C527h
		cmp	#78h, unk_DB	; magic	from address 0x80
		bcs	loc_F5FF
		ld	x, #0C51Eh
		bra	loc_F5FF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F5FC:				; CODE XREF: IV6+63Fj IV6+648j ...
		ld	x, #0C515h

loc_F5FF:				; CODE XREF: IV6+683j IV6+689j ...
		ld	b, unk_58
		add	x, b
		ld	a, ISC_11F	; ISC related
		and	a, #03h
		ld	b, x + 00h
		beq	loc_F61E
		cmp	b, #04h
		bne	loc_F649
		inc	a
		and	a, #03h
		mov	d, x
		ld	a, unk_DB	; magic	from address 0x80
		beq	loc_F61A
		dec	a
		bra	loc_F62D
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F61A:				; CODE XREF: IV6+6B1j
		inc	unk_DC
		bra	loc_F638
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F61E:				; CODE XREF: IV6+6A5j
		dec	a
		and	a, #03h
		mov	d, x
		ld	a, unk_DB	; magic	from address 0x80
		cmp	a, #7Dh
		bcs	loc_F62C
		dec	unk_DC
		bra	loc_F638
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F62C:				; CODE XREF: IV6+6C2j
		inc	a

loc_F62D:				; CODE XREF: IV6+6B4j
		mov	a, b
		xor	b, #0FFh
		st	d, word_80
		cmp	d, word_80
		bne	loc_F5FC
		st	a, unk_DB	; magic	from address 0x80

loc_F638:				; CODE XREF: IV6+6B8j IV6+6C6j
		mov	x, d
		cmpz	b
		bne	loc_F649
		cmp	#78h, unk_DB	; magic	from address 0x80
		bcs	loc_F649
<<<<<<< HEAD
		add	a, #020
=======
		add	a, #14h
>>>>>>> origin/master
		st	a, ISC_11F	; ISC related
		mov	x, d
		bra	loc_F65D
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F649:				; CODE XREF: IV6+6A9j IV6+6D6j ...
		add	a, b
		st	a, ISC_11F	; ISC related
		cmp	b, #10h
		bcc	loc_F65A
		cmp	b, #08h
		bne	loc_F65D
		cmp	#072, RPM	; 3600 RPM
		bcs	loc_F65D

loc_F65A:				; CODE XREF: IV6+6EBj
		sub	a, b
		or	a, #0Ch

loc_F65D:				; CODE XREF: IV6+6E3j IV6+6EFj ...
		ld	x, #0C539h
		add	x, a
		ld	a, x + 00h
		st	a, ISC_120	; ISC output bits is lsN

loc_F666:				; CODE XREF: IV6:loc_F516j IV6+5BBj ...
		jmp	IV6_ret		; bomb out
; END OF FUNCTION CHUNK	FOR IV6

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


		; public intCPR0
intCPR0:				; DATA XREF: ROM:FFF0o
		clrb	bit0, IRQL
		tbbc	bit0, LDOUT, intCPR0_1 ; branch	if IGT low
		push	x
		push	y
		jsr	CPR0_sub	; gets called if IGT was high, seems to	handle some housekeeping, IGF counters and bitflags
		pull	y
		pull	x
		tbbc	bit5, flags_40,	intCPR0_end ; B3 : forced timing to 5/10 deg BTDC
		clrc
		bra	intCPR0_3
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intCPR0_1:				; CODE XREF: intCPR0+2j
		setb	bit1, flags_4C
<<<<<<< HEAD
		tbbs	bit0, flags_45,	intCPR0_2 ; IC303 input	chip: B7 /TE2, B6 /TE1,	B5 /NSW, B4 IGSW,  B3, B2 IDL2,	B1 , B0	STA
=======
		tbbs	bit0, flags_45,	intCPR0_2 ; IC303 input	chip: B7 /TE2, B /TE1, B5 /NSW,	B4 IGSW,  B3, B2 IDL2, B1 , B0 STA
>>>>>>> origin/master
		setb	bit2, flags_4C

intCPR0_2:				; CODE XREF: intCPR0+14j
		tbbc	bit6, flags_40,	intCPR0_end ; B3 : forced timing to 5/10 deg BTDC
		setc

intCPR0_3:				; CODE XREF: intCPR0+10j
		bsr	Cmp0IGTdwell	; sets IGt if carry is set

intCPR0_end:				; CODE XREF: intCPR0+Cj
					; intCPR0:intCPR0_2j
		reti
; End of function intCPR0


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; sets IGt if carry is set

Cmp0IGTdwell:				; CODE XREF: NEsub1_18+29p
					; NEsub1_18:NEsub1_divertj ...
		ld	d, IGT_time
		st	d, CPR0		; Timer	comparison #0 MSB
		setb	bit0, DOM
		bcc	IGTdwell1	; IGT output
		setb	bit0, DOUT	; IGT output
		bra	IGTdwell2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IGTdwell1:				; CODE XREF: Cmp0IGTdwell+7j
		clrb	bit0, DOUT	; IGT output

IGTdwell2:				; CODE XREF: Cmp0IGTdwell+Bj
		sub	d, TIMER	; Timer	MSB (bit11~bit18)
		bmi	Cmp0NOW		; oops we missed it!
		bne	IGTdwell_ret
; End of function Cmp0IGTdwell


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Cmp0NOW:				; CODE XREF: ROM:EE20p	ROM:EE27p ...
		ld	d, #00002
		di
		add	d, TIMER	; Timer	MSB (bit11~bit18)
		st	d, CPR0		; Timer	comparison #0 MSB

IGTdwell_ret:				; CODE XREF: Cmp0IGTdwell+13j
		clrb	bit5, flags_40
		clrb	bit6, flags_40
		ei
		ret
; End of function Cmp0NOW


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CPR0_sub:				; CODE XREF: intCPR0+7p
		clr	a
		ld	b, NEcounts
		sub	b, #001
		div	d, #006
		ld	x, #01B7h
		ld	y, #01B9h
		cmp	a, #003		; a is (necounts-1)%6 =	0,1,2,3,4,5
		bcc	CPR0_sub_1	; branch if modulo = 0,1,2
		clr	a
		dec	x
		dec	y

CPR0_sub_1:				; CODE XREF: CPR0_sub+Fj
		ld	b, NEcounts
		beq	CPR0_sub_3
		tbbc	bit1, flags_4C,	CPR0_sub_3 ; bit 7 set when not	running	(300 to	400 RPM	gap)
		clrb	bit1, flags_4C
		cmpz	a
		bne	CPR0_sub_2	; IGF2 flag
		tbbc	bit4, IRQLL, CPR0_sub_4	; IGF1 flag
		clrb	bit1, flags_4E
		clrb	bit1, flags_44
		clrb	bit4, IRQLL	; clear	IGF1 flag
		bra	CPR0_sub_3
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CPR0_sub_2:				; CODE XREF: CPR0_sub+1Ej
		tbbc	bit6, IRQL, CPR0_sub_4 ; IGF2 flag
		clrb	bit2, flags_4E
		clrb	bit2, flags_44
		clrb	bit6, IRQL	; clear	IGF2 flag

CPR0_sub_3:				; CODE XREF: CPR0_sub+16j CPR0_sub+18j ...
		clr	b
		bra	CPR0_sub_6
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CPR0_sub_4:				; CODE XREF: CPR0_sub+20j
					; CPR0_sub:CPR0_sub_2j
		ld	b, x + 00h
		bne	CPR0_sub_5
		st	b, y + 00h

CPR0_sub_5:				; CODE XREF: CPR0_sub+39j
		inc	b
		bne	CPR0_sub_6
		dec	b

CPR0_sub_6:				; CODE XREF: CPR0_sub+35j CPR0_sub+3Ej
		st	b, x + 00h
		cmp	b, #05h
		bcs	CPR0_sub_RET
		cmpz	a
		bne	CPR0_sub_7
		setb	bit1, flags_44
		bra	CPR0_sub_8
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CPR0_sub_7:				; CODE XREF: CPR0_sub+48j
		setb	bit2, flags_44

CPR0_sub_8:				; CODE XREF: CPR0_sub+4Cj
		cmp	b, #09h
		bcs	CPR0_sub_RET
		ld	b, y + 00h
		cmp	b, #3Fh
		bcs	CPR0_sub_RET
		cmp	#063, count_B0	; incremented at F47D
		bcs	CPR0_sub_RET
		cmpz	a
		bne	CPR0_sub_9
		setb	bit1, flags_4E
		bra	CPR0_sub_RET
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CPR0_sub_9:				; CODE XREF: CPR0_sub+60j
		setb	bit2, flags_4E

CPR0_sub_RET:				; CODE XREF: CPR0_sub+45j CPR0_sub+52j ...
		ret
; End of function CPR0_sub


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ

; KS interrupt

		; public intASR1
intASR1:				; DATA XREF: ROM:FFF8o
		ld	d, ASR1N	; ASR1 neg edge	counter	value MSB
		sub	d, lastASR1N
		cmp	#0Eh, count_B2	; incremented at F47D
		bcc	loc_F726
		cmp	d, #00500	; compare to 2ms
		ble	loc_F751	; bomb out carry or zero
		bra	loc_F72F
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F726:				; CODE XREF: intASR1+8j
		cmp	#17h, count_B2	; incremented at F47D
		bcc	loc_F751	; skip here to NOT store a deltaKS value
		cmpz	a
		setc
		bpz	loc_F730

loc_F72F:				; CODE XREF: intASR1+Fj
		clrc

loc_F730:				; CODE XREF: intASR1+18j
		rorc	a
		rorc	b
		clr	badKScount	; Incremented by IV6, cleared by KS interrupt
		cmp	#0FFh, unk_EB
		beq	loc_F73B
		inc	unk_EB

loc_F73B:				; CODE XREF: intASR1+22j
		cmp	#80h, unk_E9
		bcs	loc_F747
		cmp	d, word_1AC	; deltaKS limit	for checking sensor. generated from RPM	lookup table
		bcs	loc_F747
		inc	KS_count	; counts KS interrupts,	reset in IV6

loc_F747:				; CODE XREF: intASR1+29j intASR1+2Ej
		add	d, deltaKS	; Cumulative sum of KS intervals, counted by KS_count, reset in	IV6
		bcs	loc_F751	; skip here to NOT store a deltaKS value
		st	d, deltaKS	; Cumulative sum of KS intervals, counted by KS_count, reset in	IV6
		inc	KS_count	; counts KS interrupts,	reset in IV6

loc_F751:				; CODE XREF: intASR1+Dj intASR1+14j ...
		tbbs	bit0, flags_4C,	loc_F759 ; skip	here to	NOT store a deltaKS value
		tbbs	bit3, flags_4E,	loc_F759 ; bit1	is igf1	related, bit2 igf2 related
		clr	count_B3	; incremented at F55E

loc_F759:				; CODE XREF: intASR1:loc_F751j
					; intASR1+3Fj
		clr	count_B2	; incremented at F47D
		clr	count_C6	; increments at	E478
		ld	d, ASR1N	; ASR1 neg edge	counter	value MSB
		st	d, lastASR1N
		clrb	bit5, IRQLL	; service ASR1 IRQ flag
		reti
; End of function intASR1

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0C1h ; Á		; data for F3DE, d2d3 start
		.db 0C3h ; Ã
byte_F767:	.db 4Fh			; DATA XREF: __RESET:res_05r
		.db  51h ; Q
		.db  45h ; E
		.db  57h ; W
		.db  53h ; S
		.db  55h ; U
		.db  59h ; Y
		.db  5Bh ; [
		.db  5Dh ; ]
		.db  5Fh ; _
		.db  07h		; byet data for	F7DD
		.db  09h
		.db  0Bh
		.db  0Dh		; d2d3 end
		.dw 0FA0Ch		; vector table for F7F5, VTA1
		.dw 0FBB0h		; VTA2
		.dw 0F95Fh		; +B/4
		.dw 0FBD6h		; OXL1
		.dw 0FBFBh		; OXL2
		.dw 0FBE3h		; OXR1
		.dw 0FBF1h		; OXR2
		.dw 0F9BFh		; THW
		.dw 0F992h		; THA
		.dw 0F9ECh		; THG
		.dw 0FC06h		; pin 18
		.dw 0F911h		; pin 17
		.dw 0FBBBh		; pin 16
		.dw 0FBC0h		; atm pressure sensor
		.dw 0FBC5h		; conversion request 1D
		.dw 0FBCAh		; conversion request 1F

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


		; public intSIN0
intSIN0:				; DATA XREF: ROM:FFE0o
		push	x
		push	y
		tbbc	bit6, SSD, sin0_01 ; Serial Status Data	Register
		jmp	sin0_08		; bomb out
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0_01:				; CODE XREF: intSIN0+2j
		ld	a, SIDR_SODR	; Serial Input/Output Data Register
		ld	b, ADC_TXed	; MSb signifies	next TX	value is 02
		bpz	sin0_03		; branch if not	msb
		setb	bit1, SSD	; set ninth bit	high
		ld	#02h, SIDR_SODR	; transmit 02, ADC responds immediately
		ld	b, #012

sin0_02:				; CODE XREF: intSIN0+18j
		dec	b
		beq	sin0_08		; bomb out
		tbbc	bit7, SSD, sin0_02 ; Serial Status Data	Register
		tbbs	bit6, SSD, sin0_08 ; bomb out
		ld	b, SIDR_SODR	; will have 02 response	from ADC, which	was observed to	be EB during testing on	bench

sin0_03:				; CODE XREF: intSIN0+Cj
		mov	d, y
		ld	b, ADC_TXed	; MSb signifies	next TX	value is 02
		push	b		; pushed here for jump table later
		setb	bit7, flags_46
		ld	a, ADC_count
		cmpb	b, #40h
		beq	doJMPtable
		inc	a		; this could be	the driver of ADC conversions
		cmp	a, #1Eh
		bcs	sin0_04
		clr	a
		clrb	bit7, flags_42

sin0_04:				; CODE XREF: intSIN0+2Fj
		st	a, ADC_count
		shr	a
		bcs	doJMPtable
		tbbc	bit7, flags_4C,	TXadcSpecific ;	bit 7 set when not running (300	to 400 RPM gap)
		and	b, #0BFh
		cmp	b, #05h
		beq	doJMPtable
		ld	a, #05h		; tx 05, VTA2
		bra	TXaccA
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TXadcSpecific:				; CODE XREF: intSIN0+39j
		and	a, #03h
		ld	x, #0F771h	; 7,9,b	or D, correlates with oxygen sensors
		add	x, a
		ld	a, x + 00h

TXaccA:					; CODE XREF: intSIN0+44j
		st	a, ADC_TXed	; MSb signifies	next TX	value is 02
		clrb	bit7, flags_46
		di
		ld	#30h, SMRC_SIR	; Serial Master	Register Control
		setb	bit1, SSD	; set ninth bit	high
		and	a, #1Fh
		st	a, SIDR_SODR	; Serial Input/Output Data Register

doJMPtable:				; CODE XREF: intSIN0+2Aj intSIN0+37j ...
		clrb	bit3, IRQLL
		ei
		pull	b		; value	coming off stack here was ADC_TXed at start of interrupt
		ld	x, #0F775h	; jump vector table address
		and	b, #1Eh		; 16 vectors across 32 bytes
		add	x, b
		ld	x, x + 00h
		mov	y, d		; A will have data that	initiated this rx interrupt, B will have either	the unfiltered TX value	that generated that data or 02
		jmp	x + 00h
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0_08:				; CODE XREF: intSIN0+5j intSIN0+16j ...
		ld	a, SIDR_SODR	; bomb out
		jmp	retSerIRQ
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0_09:				; CODE XREF: ROM:F95Cj	ROM:loc_F98Fj ...
		tbbs	bit7, flags_46,	sin0_10	; test bit7 of unk_46, read more data from serial port if set, otherwise terminate interrupt
		jmp	retSerIRQ2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0_10:				; CODE XREF: intSIN0:sin0_09j
		ld	#70h, SMRC_SIR	; Serial Master	Register Control
		ld	a, SSD		; clear	everything
		ld	a, SIDR_SODR	; clear	everything
		setb	bit1, PORTD_ASRIN ; select different target (IC302/IC303)
		ld	a, #012

sin0_11:				; CODE XREF: intSIN0+85j
		tbbs	bit7, SSD, sin0_13 ; bounce if data received
		dec	a
		bne	sin0_11		; bounce if data received

sin0_12:				; CODE XREF: intSIN0:sin0_13j
		ld	a, SIDR_SODR	; Serial Input/Output Data Register
		bra	sin0_14
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0_13:				; CODE XREF: intSIN0:sin0_11j
		tbbs	bit6, SSD, sin0_12 ; bounce if RX error
		ld	a, SIDR_SODR	; Serial Input/Output Data Register
		xor	a, #11100110b
<<<<<<< HEAD
		push	a		; the following	is a 2 cycle debounce routine. flags_1a9 caches	the direct read	from the port, flags_45	only gets the bits which stay high for 2 sucessive reads
		mov	a, b
		xor	a, flags_45	; IC303	input chip: B7 /TE2, B6	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		and	a, flags_1A9	; buffers IC303	inputs for debouncing and storing into flags_45
		and	b, flags_45	; IC303	input chip: B7 /TE2, B6	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		add	a, b
		st	a, flags_45	; IC303	input chip: B7 /TE2, B6	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
		pull	b
		st	b, flags_1A9	; buffers IC303	inputs for debouncing and storing into flags_45
=======
		push	a
		mov	a, b
		xor	a, flags_45	; IC303	input chip: B7 /TE2, B /TE1, B5	/NSW, B4 IGSW,	B3, B2 IDL2, B1	, B0 STA
		and	a, flags_1A9	; flags_45 related (IC303 inputs)
		and	b, flags_45	; IC303	input chip: B7 /TE2, B /TE1, B5	/NSW, B4 IGSW,	B3, B2 IDL2, B1	, B0 STA
		add	a, b
		st	a, flags_45	; IC303	input chip: B7 /TE2, B /TE1, B5	/NSW, B4 IGSW,	B3, B2 IDL2, B1	, B0 STA
		pull	b
		st	b, flags_1A9	; flags_45 related (IC303 inputs)
>>>>>>> origin/master

sin0_14:				; CODE XREF: intSIN0+89j
		clrb	bit1, PORTD_ASRIN
		ld	a, #012

sin0_15:				; CODE XREF: intSIN0+AAj
		tbbs	bit7, SSD, sin0_17 ; Serial Status Data	Register
		dec	a
		bne	sin0_15

sin0_16:				; CODE XREF: intSIN0:sin0_17j
		ld	a, SIDR_SODR	; failure code
		bra	sin0_21		; bit4 is /IDL1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0_17:				; CODE XREF: intSIN0:sin0_15j
		tbbs	bit6, SSD, sin0_16 ; failure code
		ld	a, SIDR_SODR	; Serial Input/Output Data Register
		xor	a, #0Fh
		push	a		; the following	is a 2 cycle debounce routine. flags_1a9 caches	the direct read	from the port, flags_45	only gets the bits which stay high for 2 sucessive reads
		mov	a, b
<<<<<<< HEAD
		xor	a, flags_1AB	; buffers IC302	inputs for debouncing and storing into flags_1AA
		and	a, flags_1AA	; B6 - DI (FPECU), B3~0	are NOT	of oxy heater pin voltages R2, R1, L2, L1 (IC302)
		and	b, flags_1AB	; buffers IC302	inputs for debouncing and storing into flags_1AA
		add	a, b
		st	a, flags_1AB	; buffers IC302	inputs for debouncing and storing into flags_1AA
		pull	b
		st	b, flags_1AA	; B6 - DI (FPECU), B3~0	are NOT	of oxy heater pin voltages R2, R1, L2, L1 (IC302)
=======
		xor	a, flags_1AB	; flags_1AA related
		and	a, flags_1AA	; IC302	input bits B3~0	are NOT	of oxy heater pin voltages
		and	b, flags_1AB	; flags_1AA related
		add	a, b
		st	a, flags_1AB	; flags_1AA related
		pull	b
		st	b, flags_1AA	; IC302	input bits B3~0	are NOT	of oxy heater pin voltages
>>>>>>> origin/master
		cmpb	b, #10h
		beq	sin0_18
		setb	bit0, flags_49
		bra	sin0_19
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0_18:				; CODE XREF: intSIN0+CCj
		clrb	bit0, flags_49

sin0_19:				; CODE XREF: intSIN0+D0j
		cmpb	b, #20h
		beq	sin0_20
		setb	bit2, flags_49
		bra	sin0_21		; bit4 is /IDL1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0_20:				; CODE XREF: intSIN0+D6j
		clrb	bit2, flags_49

sin0_21:				; CODE XREF: intSIN0+AEj intSIN0+DAj
		tbbc	bit4, PBCS, sin0_23 ; bit4 is /IDL1
		tbbs	bit3, flags_42,	sin0_22
		clrb	bit0, flags_41

sin0_22:				; CODE XREF: intSIN0+E1j
		clrb	bit3, flags_42
		bra	sin0_25
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0_23:				; CODE XREF: intSIN0:sin0_21j
		tbbc	bit3, flags_42,	sin0_24
		setb	bit0, flags_41

sin0_24:				; CODE XREF: intSIN0:sin0_23j
		setb	bit3, flags_42

sin0_25:				; CODE XREF: intSIN0+E8j
		tbbs	bit4, flags_45,	sin0_26	; this branch is executed often
		clr	count_AF	; incremented at F47D

sin0_26:				; CODE XREF: intSIN0:sin0_25j
		setb	bit1, SSD	; this branch is executed often
		ld	#0DAh, SIDR_SODR ; transmit DA to ADC
		ld	a, flags_49	; bits 1-3-4-5 are oxl1-oxr1-oxl2-oxr2 - Oxygen	sensors
		ld	y, #012Dh
		jsr	sub_FC0D
		ld	a, flags_49	; bits 1-3-4-5 are oxl1-oxr1-oxl2-oxr2 - Oxygen	sensors
		shr	a
		shr	a
		ld	y, #0149h
		jsr	sub_FC0D
<<<<<<< HEAD
		tbbs	bit0, flags_45,	sin0_27	; IC303	input chip: B7 /TE2, B6	/TE1, B5 /NSW, B4 IGSW,	 B3, B2	IDL2, B1 , B0 STA
=======
		tbbs	bit0, flags_45,	sin0_27	; IC303	input chip: B7 /TE2, B /TE1, B5	/NSW, B4 IGSW,	B3, B2 IDL2, B1	, B0 STA
>>>>>>> origin/master
		cmp	#32h, count_A8	; incremented at F47D
		ble	sin0_29
		clrb	bit7, flags_4A
		bra	sin0_29
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0_27:				; CODE XREF: intSIN0+10Dj
		clr	a
		st	a, count_1BA	; incremented at F49C
<<<<<<< HEAD
		tbs	bit7, flags_4A	; bits 6,5,4 are inherited from	109. 6 seems to	always be low when no sub throttle exists
=======
		tbs	bit7, flags_4A
>>>>>>> origin/master
		bne	sin0_28
		clr	unk_7F
		clr	count_5F	; counts up to 255 since last start, about 15 counts per second
		clr	count_A8	; incremented at F47D
		clr	NEcounts
		clr	NEcountsIV6	; buffered copy	of NEcounts for	IV6 purposes
		clr	count_B0	; incremented at F47D
		clr	a
		st	a, unk_1B6
		st	a, unk_1B7
		clrb	bit1, flags_4C
<<<<<<< HEAD
		tbbc	bit7, flags_4C,	sin0_29	; bit 7	set when not running (300 to 400 RPM gap)
=======
		tbbc	bit7, flags_4C,	sin0_29	; bit 7	demands	a sampling of the oxygen sensors
>>>>>>> origin/master
		setb	bit5, flags_47
		bra	sin0_29
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0_28:				; CODE XREF: intSIN0+11Fj
		cmp	#25h, count_A8	; incremented at F47D
		ble	sin0_29
		ld	#26h, count_A8	; incremented at F47D

sin0_29:				; CODE XREF: intSIN0+113j intSIN0+117j ...
		ld	a, #013

sin0_30:				; CODE XREF: intSIN0+148j
		dec	a
		bne	sin0_30
		tbbc	bit7, SSD, sin0_31 ; Serial Status Data	Register
		tbbc	bit6, SSD, SerialDebug ; Serial	Status Data Register

sin0_31:				; CODE XREF: intSIN0+14Aj
		ld	a, SIDR_SODR	; Serial Input/Output Data Register
		bra	retSerIRQ
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SerialDebug:				; CODE XREF: intSIN0+14Dj
		ld	b, SIDR_SODR	; Serial Input/Output Data Register
		ld	a, SSD		; Serial Status	Data Register
		and	a, #01h
		shl	d
		cmp	d, #003Eh
		bne	txSerDebug
		ld	d, #0FFDCh

txSerDebug:				; CODE XREF: intSIN0+15Ej
		mov	d, x
		ld	d, x + 00h
		clrb	bit1, SSD	; set ninth bit	low
		st	a, SIDR_SODR	; Serial Input/Output Data Register
		clrb	bit1, SSD	; set ninth bit	low
		clrb	bit1, SSD	; set ninth bit	low
		st	b, SIDR_SODR	; Serial Input/Output Data Register

retSerIRQ:				; CODE XREF: intSIN0+6Dj intSIN0+152j
		di
		ld	#01h, flags_75	; flags	relating to ADC	tx'ing
		clrb	bit3, IRQLL
		ei

retSerIRQ2:				; CODE XREF: intSIN0+73j
		pull	y
		pull	x
		setb	bit1, flags_4A
		reti
; End of function intSIN0

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0JMP12:				; called from F7FE adc pin 17 -	PCM absolute pressure sensor denso IS121
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0FBh ; û
		.db  0Fh
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		bcs	loc_F921
		clrb	bit7, flags_43
		tbbs	bit3, flags_4B,	loc_F91F
		clrb	bit2, flags_4F

loc_F91F:				; CODE XREF: ROM:F91Aj
		bra	loc_F939
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F921:				; CODE XREF: ROM:F916j
		tbs	bit7, flags_43	; bit3:	AFM bad	bit4: rev limiter
		bne	loc_F927
		clr	count_B7	; incremented at F55E

loc_F927:				; CODE XREF: ROM:F923j
		tbbs	bit3, flags_4B,	loc_F931
		cmp	#3Dh, count_B7	; incremented at F55E
		bcs	loc_F935	; default value
		bra	loc_F933
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F931:				; CODE XREF: ROM:loc_F927j
		setb	bit6, flags_4D

loc_F933:				; CODE XREF: ROM:F92Fj
		setb	bit2, flags_4F

loc_F935:				; CODE XREF: ROM:F92Dj
		ld	b, #0B4h	; default value
		bra	loc_F95A
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F939:				; CODE XREF: ROM:loc_F91Fj
		cmp	a, #96h
		bcc	loc_F946
		tbbs	bit7, flags_49,	loc_F942 ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		clrb	bit6, flags_4B

loc_F942:				; CODE XREF: ROM:F93Dj
		clrb	bit7, flags_49
		bra	loc_F94D
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F946:				; CODE XREF: ROM:F93Bj
		tbbc	bit7, flags_49,	loc_F94B ; bits	1-3-4-5	are oxl1-oxr1-oxl2-oxr2	- Oxygen sensors
		setb	bit6, flags_4B

loc_F94B:				; CODE XREF: ROM:loc_F946j
		setb	bit7, flags_49

loc_F94D:				; CODE XREF: ROM:F944j
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0D7h ; ×
		.db  71h ; q
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		sub	a, #113		; 71h, range of	A is thus 0~102
		ld	y, #00627
		jsr	MulAbyY		; returns upper	16b in AccD

loc_F95A:				; CODE XREF: ROM:F937j
		st	b, ATM_press	; adc pin 17 - PCM atmospheric pressure	sensor,	debiased and scaled
		jmp	sin0_09		; test bit7 of unk_46, read more data from serial port if set, otherwise terminate interrupt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0JMP03:				; called from F7FE, +B/4, 102==8V
		cmp	a, #102
		bgt	loc_F965
		clr	count_AD	; cleared when below 8V	input, incremented at F47D

loc_F965:				; CODE XREF: ROM:F961j
		tbbs	bit5, RAMST, loc_F976 ;	Built-in RAM status
		clr	count_AE	; incremented at F47D
		cmp	a, #109		; about	8.5V
		bcs	loc_F97C
		tbbs	bit3, flags_41,	loc_F97E ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
		tbbc	bit4, flags_41,	loc_F978 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend
		setb	bit5, RAMST

loc_F976:				; CODE XREF: ROM:loc_F965j
		setb	bit3, flags_41

loc_F978:				; CODE XREF: ROM:F971j
		setb	bit4, flags_41
		bra	loc_F980
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F97C:				; CODE XREF: ROM:F96Cj
		clrb	bit4, flags_41

loc_F97E:				; CODE XREF: ROM:F96Ej
		clrb	bit3, flags_41

loc_F980:				; CODE XREF: ROM:F97Aj
		st	a, Bvolts	; ADC measurement of +B/4. scaling is thus 20*value/255=volts
		tbbs	bit0, flags_45,	loc_F989 ; 11V
		clrb	bit4, flags_4B
		bra	loc_F98F
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F989:				; CODE XREF: ROM:F982j
		cmp	a, #141		; 11V
		bcc	loc_F98F
		setb	bit4, flags_4B

loc_F98F:				; CODE XREF: ROM:F987j	ROM:F98Bj
		jmp	sin0_09		; test bit7 of unk_46, read more data from serial port if set, otherwise terminate interrupt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0JMP09:				; called from F7FE, THA
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0FBh
		.db 07h
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		bcs	THAbad
		clrb	bit6, flags_43
		tbbs	bit3, flags_4B,	loc_F9A0
		clrb	bit1, flags_4F

loc_F9A0:				; CODE XREF: ROM:F99Bj
		bra	THAgood
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

THAbad:					; CODE XREF: ROM:F997j
		tbs	bit6, flags_43	; bit3:	AFM bad	bit4: rev limiter
		bne	loc_F9A8
		clr	count_B7	; incremented at F55E

loc_F9A8:				; CODE XREF: ROM:F9A4j
		tbbs	bit3, flags_4B,	loc_F9B2
		cmp	#3Dh, count_B7	; incremented at F55E
		bcs	loc_F9B6	; default air temp
		bra	loc_F9B4
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F9B2:				; CODE XREF: ROM:loc_F9A8j
		setb	bit6, flags_4D

loc_F9B4:				; CODE XREF: ROM:F9B0j
		setb	bit1, flags_4F

loc_F9B6:				; CODE XREF: ROM:F9AEj
		ld	a, #79h		; default air temp

THAgood:				; CODE XREF: ROM:loc_F9A0j
		xor	a, #0FFh
		st	a, rawTHA	; Contains the NOT of air temp reading from ADC, sensor	is tied	to ground on other side
		jmp	sin0_09		; test bit7 of unk_46, read more data from serial port if set, otherwise terminate interrupt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0JMP08:				; called from F7FE, THW
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 0FBh
		.db 07h
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		bcs	loc_F9CF	; bounce if data was clipped
		clrb	bit5, flags_43
		tbbs	bit3, flags_4B,	loc_F9CD
		clrb	bit0, flags_4F

loc_F9CD:				; CODE XREF: ROM:F9C8j
		bra	loc_F9E5
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F9CF:				; CODE XREF: ROM:F9C4j
		tbs	bit5, flags_43	; bit3:	AFM bad	bit4: rev limiter
		bne	loc_F9D5
		clr	count_B7	; incremented at F55E

loc_F9D5:				; CODE XREF: ROM:F9D1j
		tbbs	bit3, flags_4B,	loc_F9DF
		cmp	#3Dh, count_B7	; incremented at F55E
		bcs	loc_F9E3	; default value	if bad CTS
		bra	loc_F9E1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_F9DF:				; CODE XREF: ROM:loc_F9D5j
		setb	bit6, flags_4D

loc_F9E1:				; CODE XREF: ROM:F9DDj
		setb	bit0, flags_4F

loc_F9E3:				; CODE XREF: ROM:F9DBj
		ld	a, #1Bh		; default value	if bad CTS

loc_F9E5:				; CODE XREF: ROM:loc_F9CDj
		xor	a, #0FFh
		st	a, rawTHW	; Contains the NOT of CTS reading from ADC, sensor is tied to ground on	other side
		jmp	sin0_09		; test bit7 of unk_46, read more data from serial port if set, otherwise terminate interrupt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0JMP10:				; called from F7FE, THG
		ld	y, #0F9F7h
		jsr	TwoDTable	; X value in AccA, integer return in Acca, fraction return in AccB
		st	a, THG		; THG lookup table output from exhaust gas temp	sensor ADC reading
		jmp	sin0_09		; test bit7 of unk_46, read more data from serial port if set, otherwise terminate interrupt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  0Dh		; F9EC,	THG lookup table
		.db 0DCh ; Ü
		.db  13h
		.db 0C8h ; È
		.db  1Bh
		.db 0B4h ; ´
		.db  32h ; 2
		.db  96h ; –
		.db  5Ah ; Z
		.db  78h ; x
		.db  80h ; €
		.db  64h ; d
		.db 0A9h ; ©
		.db  50h ; P
		.db 0DBh ; Û
		.db  32h ; 2
		.db 0F6h ; ö
		.db  14h
		.db 0FCh ; ü
		.db  00h
		.db 0FFh
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0JMP01:				; called from F7FE, VTA1 process
		clrb	bit1, flags_40
		ld	y, #0122h
		jsr	VTAchecksub	; throttle processing sub. accepts an address in Y, AccA is ADC	VTA, B is ADCtx, returns offset	VTA in AccA, plus some crap in B
		ld	y, VTA1_net	; VTA1 - VTA_min
		ld	a, VTA1_flags	; VTA1 Flags
		or	a, VTA2_flags	; VTA2 flags
		cmpb	a, #08h
		bne	loc_FA29
<<<<<<< HEAD
		cmp	y, VTA2_net	; VTA2-VTA2_min, =255 when sub throttle	disabled/not exist
		ble	loc_FA29	; use the smallest throttle angle
		ld	y, VTA2_net	; VTA2-VTA2_min, =255 when sub throttle	disabled/not exist
=======
		cmp	y, VTA2_net	; VTA2-VTA2_min
		ble	loc_FA29	; use the smallest throttle angle
		ld	y, VTA2_net	; VTA2-VTA2_min
>>>>>>> origin/master

loc_FA29:				; CODE XREF: ROM:FA1Fj	ROM:FA24j
		ld	d, VTA_net
		st	y, VTA_net	; only written here
		sub	d, VTA_net	; D now	contains difference last samp -	this samp
		bcc	loc_FA35	; decreasing or	constant
		bpz	loc_FA47	; increasing
		bra	loc_FA3A	; treat	as decreasing anyways
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FA35:				; CODE XREF: ROM:FA2Fj
		cmp	d, #0CC0h
		bcc	loc_FA4A

loc_FA3A:				; CODE XREF: ROM:FA33j
		neg	a
		neg	b
		subc	a, #00h
		add	d, #0CC0h
		jsr	divDby64	; shift	D right	6 times
		cmpz	a
		beq	loc_FA4B

loc_FA47:				; CODE XREF: ROM:FA31j
		ld	b, #0FFh
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  41h ; A		; brn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FA4A:				; CODE XREF: ROM:FA38j
		clr	b

loc_FA4B:				; CODE XREF: ROM:FA45j
		ld	a, VTA1_flags	; VTA1 Flags
		cmpb	a, #40h
		bne	loc_FA56
		cmpb	a, #08h
		beq	loc_FA58

loc_FA56:				; CODE XREF: ROM:FA50j
		ld	b, #33h

loc_FA58:				; CODE XREF: ROM:FA54j
		st	b, unk_6C	; sort of a filtered, saturated	VTA_net
		tbbs	bit7, flags_4C,	loc_FA63 ; bit 7 set when not running (300 to 400 RPM gap)
		ld	a, flags_44	; here bits 5321 prevent a doallinj call
		cmpb	a, #2Eh
		beq	loc_FA67

loc_FA63:				; CODE XREF: ROM:FA5Aj
		clr	unk_D6
		bra	loc_FA8C
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FA67:				; CODE XREF: ROM:FA61j
		cmp	b, #058
		bcc	loc_FA74	; 3600 RPM
		cmp	#18h, unk_D7
		bcs	loc_FA8C	; prevent injection
		clr	unk_D6
		bra	loc_FA8C	; prevent injection
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FA74:				; CODE XREF: ROM:FA69j
		cmp	#072, RPM	; 3600 RPM
		bcc	loc_FA8C	; prevent injection
		cmp	#03h, unk_D6
		bcc	loc_FA8C	; prevent injection
		ld	a, unk_D3	; multiplied by	16 and used for	injectors
		clr	b
		shr	d
		shr	d
		shr	d
		shr	d
		jsr	DoAllInj	; inject the value of unk_D3 * 16
		inc	unk_D6
		clr	unk_D7

loc_FA8C:				; CODE XREF: ROM:FA65j	ROM:FA6Ej ...
		ld	b, unk_6C	; sort of a filtered, saturated	VTA_net
		sub	b, #33h
		bcc	loc_FA93
		neg	b

loc_FA93:				; CODE XREF: ROM:FA90j
		ld	a, #01h
		cmp	#072, RPM	; MSB is RPM/50, LSB is	fraction of 50
		ble	loc_FA9E
		ld	a, #04h
		bra	loc_FAA5
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FA9E:				; CODE XREF: ROM:FA98j
		cmp	#082, VTA_net
		bcs	loc_FAA5	; should always	branch
		ld	a, #02h

loc_FAA5:				; CODE XREF: ROM:FA9Cj	ROM:FAA1j
		cmp	a, b
		ble	loc_FAAE
<<<<<<< HEAD
		tbbs	bit7, flags_4C,	loc_FAAE ; bit 7 set when not running (300 to 400 RPM gap)
=======
		tbbs	bit7, flags_4C,	loc_FAAE ; bit 7 demands a sampling of the oxygen sensors
>>>>>>> origin/master
		tbbc	bit0, flags_41,	loc_FAB0 ; B0 IDL1, b5 indidcates something about ram stats during last	suspend

loc_FAAE:				; CODE XREF: ROM:FAA6j	ROM:FAA8j
		clr	unk_69

loc_FAB0:				; CODE XREF: ROM:FAABj
		jmp	sin0_09		; test bit7 of unk_46, read more data from serial port if set, otherwise terminate interrupt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

VTAchecksub:				; CODE XREF: ROM:FA11p	ROM:FBB5p
		tbbc	bit1, flags_40,	loc_FAC4 ; throttle processing sub. accepts an address in Y, AccA is ADC VTA, B	is ADCtx, returns offset VTA in	AccA, plus some	crap in	B
		tbbc	bit2, flags_45,	loc_FAC4 ; bounce if not IDL2
		cmp	d, #0F0A4h
		bcs	loc_FAC4	; passed inital	check
		clr	a
		st	a, y + 00h
		jmp	loc_FBAA	; bomb out
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FAC4:				; CODE XREF: ROM:VTAchecksubj
					; ROM:FAB6j ...
		mov	d, x		; passed inital	check
		ld	a, y + 00h	; mask out bit 6
		and	a, #0BFh
		tbbc	bit1, flags_40,	loc_FAD1 ; B3 :	forced timing to 5/10 deg BTDC
		tbbc	bit2, flags_45,	loc_FAD6 ; bounce if not IDL2
		bra	loc_FAD4	; set bit 6
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FAD1:				; CODE XREF: ROM:FAC9j
		tbbc	bit0, flags_41,	loc_FAD6 ; always executing this check stack

loc_FAD4:				; CODE XREF: ROM:FACFj
		or	a, #40h		; set bit 6

loc_FAD6:				; CODE XREF: ROM:FACCj	ROM:loc_FAD1j
		cmp	x, #0CCDh	; always executing this	check stack
		bcs	loc_FB2D
		cmp	x, #0FAE1h
		bgt	loc_FB31
		cmpb	a, #40h
		beq	loc_FB12
		and	a, #0FBh
		cmp	x, #4CCDh
		bgt	loc_FB08
		cmp	x, #30A4h
		bgt	loc_FB04
		cmpb	a, #02h
		beq	loc_FAF6
		and	a, #0F7h

loc_FAF6:				; CODE XREF: ROM:FAF2j
		or	a, #02h
		tbbs	bit3, flags_4B,	loc_FB27
		tbbs	bit1, flags_40,	loc_FB01 ; B3 :	forced timing to 5/10 deg BTDC
		clrb	bit3, flags_4F
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  8Ch ; Œ		; cmp x
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FB01:				; CODE XREF: ROM:FAFBj
		clrb	bit4, flags_4F
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  8Ch ; Œ		; cmp x
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FB04:				; CODE XREF: ROM:FAEEj	ROM:FB2Fj
		and	a, #0F9h
		bra	loc_FB27
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FB08:				; CODE XREF: ROM:FAE9j
		cmpb	a, #18h
		bne	loc_FB31
		or	a, #10h
		and	a, #0FDh
		bra	loc_FB29
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FB12:				; CODE XREF: ROM:FAE2j
		and	a, #0FDh
		tbbs	bit1, flags_40,	loc_FB1C ; B3 :	forced timing to 5/10 deg BTDC
		tbbs	bit3, flags_4F,	loc_FB27
		bra	loc_FB1F
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FB1C:				; CODE XREF: ROM:FB14j
		tbbs	bit4, flags_4F,	loc_FB27

loc_FB1F:				; CODE XREF: ROM:FB1Aj
		cmpb	a, #04h
		beq	loc_FB25
		and	a, #0F7h

loc_FB25:				; CODE XREF: ROM:FB21j
		or	a, #04h

loc_FB27:				; CODE XREF: ROM:FAF8j	ROM:FB06j ...
		and	a, #0EFh

loc_FB29:				; CODE XREF: ROM:FB10j
		and	a, #0FEh
		bra	loc_FB51	; loads	a default VTA, returns
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FB2D:				; CODE XREF: ROM:FAD9j
		cmpb	a, #40h
		bne	loc_FB04

loc_FB31:				; CODE XREF: ROM:FADEj	ROM:FB0Aj
		or	a, #08h
		and	a, #0F9h
		cmpb	a, #01h
		bne	loc_FB3D
		clr	count_B7	; incremented at F55E
		or	a, #01h

loc_FB3D:				; CODE XREF: ROM:FB37j
		tbbs	bit3, flags_4B,	loc_FB47
		cmp	#3Dh, count_B7	; incremented at F55E
		bcs	loc_FB51	; loads	a default VTA, returns
		bra	loc_FB49
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FB47:				; CODE XREF: ROM:loc_FB3Dj
		setb	bit6, flags_4D

loc_FB49:				; CODE XREF: ROM:FB45j
		tbbs	bit1, flags_40,	loc_FB4F ; B3 :	forced timing to 5/10 deg BTDC
		setb	bit3, flags_4F
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  8Ch ; Œ		; cmp x, three byte NOP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FB4F:				; CODE XREF: ROM:loc_FB49j
		setb	bit4, flags_4F

loc_FB51:				; CODE XREF: ROM:FB2Bj	ROM:FB43j
		st	a, y + 00h	; loads	a default VTA, returns
		cmpb	a, #08h
		beq	loc_FB60
		ld	b, #044
		st	b, y + 01h
		clr	a
		clr	b
		jmp	VTAcheck_ret	; (vta-y+01) also is written out here
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FB60:				; CODE XREF: ROM:FB55j
		cmpb	a, #10h
		bne	loc_FB8D
		cmpb	a, #40h
		beq	loc_FB8D
		ld	b, y + 04h
		cmp	b, #31h
		bcc	loc_FB74	; recover VTA +	ADCtx from X
		and	a, #0DFh
		st	a, y + 00h
		bra	loc_FB8D
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FB74:				; CODE XREF: ROM:FB6Cj
		mov	x, d		; recover VTA +	ADCtx from X
		add	a, y + 01h
		rorc	a
		add	a, y + 01h
		rorc	a		; filtering new	data with old
		ld	b, y + 00h
		cmpb	b, #20h
		bne	loc_FB87
		inc	y + 01h
		or	b, #20h
		st	b, y + 00h

loc_FB87:				; CODE XREF: ROM:FB7Fj
		cmp	a, y + 01h
		bcc	loc_FB8D	; select the smallest
		st	a, y + 01h	; here is where	VTA gets written out

loc_FB8D:				; CODE XREF: ROM:FB62j	ROM:FB66j ...
		ld	a, y + 01h
		cmp	a, #05h
		bcs	loc_FB97
		cmp	a, #049
		ble	loc_FB9B

loc_FB97:				; CODE XREF: ROM:FB91j
		ld	a, #044
		st	a, y + 01h	; store	a default value

loc_FB9B:				; CODE XREF: ROM:FB95j
		mov	x, d
		sub	a, y + 01h	; could	y+01 be	the offset?
		bcc	loc_FBA2
		clr	a
		clr	b

loc_FBA2:				; CODE XREF: ROM:FB9Ej
		tbbc	bit1, flags_40,	VTAcheck_ret ; (vta-y+01) also is written out here
		add	d, #0312h
		bcc	VTAcheck_ret	; (vta-y+01) also is written out here

loc_FBAA:				; CODE XREF: ROM:FAC1j
		ld	d, #0FFFFh

VTAcheck_ret:				; CODE XREF: ROM:FB5Dj	ROM:loc_FBA2j ...
		st	d, y + 02h	; (vta-y+01) also is written out here
		ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0JMP02:				; called from F7FE, VTA2 process
		setb	bit1, flags_40
		ld	y, #0128h
		jsr	VTAchecksub	; throttle processing sub. accepts an address in Y, AccA is ADC	VTA, B is ADCtx, returns offset	VTA in AccA, plus some crap in B
		jmp	sin0_09		; test bit7 of unk_46, read more data from serial port if set, otherwise terminate interrupt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0JMP13:				; called from F7FE adc pin 16 (0V)
		ld	x, #0114h
		bra	loc_FBCD
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0JMP14:				; called from F7FE adc pin 15 (0V)
		ld	x, #0115h
		bra	loc_FBCD
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0JMP15:				; called from F7FE adc request 1D
		ld	x, #0116h
		bra	loc_FBCD
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0JMP16:				; called from F7FE ADC 1F
		ld	x, #0117h

loc_FBCD:				; CODE XREF: ROM:FBBEj	ROM:FBC3j ...
		mov	a, b
		clr	a
		div	d, #021		; 0.411V per 21	lsbs
		st	b, x + 00h
		jmp	sin0_09		; test bit7 of unk_46, read more data from serial port if set, otherwise terminate interrupt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0JMP04:				; called from F7FE, OXL1, oxygen sensor	left primary sampling
		setb	bit1, flags_49
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 24h			; .70V
		.db 12h			; .35V
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		bcc	loc_FBEE
		clrb	bit1, flags_49
		bra	loc_FBEE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0JMP06:				; called from F7FE, OXR1
		setb	bit3, flags_49
		jsr	SaturateData
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db 24h
		.db 12h
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		bcc	loc_FBEE
		clrb	bit3, flags_49

loc_FBEE:				; CODE XREF: ROM:FBDDj	ROM:FBE1j ...
		jmp	sin0_09		; test bit7 of unk_46, read more data from serial port if set, otherwise terminate interrupt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0JMP07:				; called from F7FE, OXR2
		clrb	bit5, flags_49
		cmp	a, #023		; 0.45V
		bcs	loc_FC03
		setb	bit5, flags_49
		bra	loc_FC03
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0JMP05:				; called from F7FE, OXL2
		clrb	bit4, flags_49
		cmp	a, #023
		bcs	loc_FC03
		setb	bit4, flags_49

loc_FC03:				; CODE XREF: ROM:FBF5j	ROM:FBF9j ...
		jmp	sin0_09		; test bit7 of unk_46, read more data from serial port if set, otherwise terminate interrupt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

sin0JMP11:				; called from F7FE, pin	18 of ADC (0V)
		xor	a, #0FFh
		st	a, ADC_pin18	; 0V NOT'ed, so 255
		jmp	sin0_09		; test bit7 of unk_46, read more data from serial port if set, otherwise terminate interrupt

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sub_FC0D:				; CODE XREF: intSIN0+100p intSIN0+10Ap
		push	a
		mov	s, x
		ld	b, y + 019
		cmpb	b, #02h
		beq	FC0D_ret	; tidy stack
		ld	a, y + 005
		bne	loc_FC30
		ld	a, x + 00h
		shr	a
		bcs	loc_FC26
		cmpb	b, #04h
		beq	FC0D_ret	; tidy stack
		ld	a, #0Fh
		bra	loc_FC2C
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FC26:				; CODE XREF: sub_FC0D+Fj
		cmpb	b, #04h
		bne	FC0D_ret	; tidy stack
		ld	a, #0Fh

loc_FC2C:				; CODE XREF: sub_FC0D+17j
		st	a, y + 005
		bra	FC0D_ret	; tidy stack
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FC30:				; CODE XREF: sub_FC0D+Aj
		dec	a
		st	a, y + 005
		bne	FC0D_ret	; tidy stack
		ld	a, x + 00h
		shr	a
		bcs	loc_FC42
		cmpb	b, #04h
		beq	FC0D_ret	; tidy stack
		and	b, #0FBh
		bra	loc_FC48
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

loc_FC42:				; CODE XREF: sub_FC0D+2Bj
		cmpb	b, #04h
		bne	FC0D_ret	; tidy stack
		or	b, #84h

loc_FC48:				; CODE XREF: sub_FC0D+33j
		or	b, #10h
		st	b, y + 019

FC0D_ret:				; CODE XREF: sub_FC0D+6j sub_FC0D+13j	...
		inc	s		; tidy stack
		ret
; End of function sub_FC0D

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
unk_FF49:	.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  5Fh ; _
		.db  03h
		.db 0D4h ; Ô
		.db 0B6h ; ¶

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


		; public DefaultINT
DefaultINT:				; DATA XREF: ROM:FFE2o	ROM:FFE4o ...
		ld	d, #116Eh	; IV2
					; IV3
					; IV4
					; IV5
					; IV7
					; IV8
					; IVa
		st	d, IRQL		; Interrupt Request Flag MSB
		reti
; End of function DefaultINT


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


		; public __NMI
__NMI:					; DATA XREF: ROM:FFFCo
		ld	s, #02DFh
		ld	d, #__RESET
		push	d
		push	d
		clr	a
		push	a
		clrb	bit7, IMASK
		reti
; End of function __NMI

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		.dw 519Bh		; Used to force	checksum to equal AA55 at D397
		.dw 8243h		; mask rom version!
		.dw intSINx		; 00 - SINx on pin 43
		.dw intSIN0		; 01 - SIN0, possibly others
		.dw DefaultINT		; 02 - /IRL
		.dw DefaultINT		; 03 - /IRP (IGF2)
		.dw DefaultINT		; 04 - ASR3 events (G1)
		.dw DefaultINT		; 05 - ASR0 events (IGF1)
		.dw IV6			; 06 -
		.dw DefaultINT		; 07 - Timer Compare 1
		.dw DefaultINT		; 08 - Timer Compare 2
		.dw intCPR0		; 09 - Timer Compare 0
		.dw DefaultINT		; 0A - Timer Compare 3
		.dw DefaultINT		; 0B - Timer Overflow
		.dw IVc			; 0C - 4ms periodic
		.dw intASR1		; 0D - ASR1 events (KS)
		.dw intASR2		; 0E - ASR2 events (NE)
		.dw __NMI		; 0F - Non maskable interrupt
		.dw __RESET		; Processor reset
; end of 'ROM'


		.end
